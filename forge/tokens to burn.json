[
	{
		"role": "system",
		"content": "I am testing foundry client. You are a helpful assistant."
	},
	{
		"role": "user",
		"name": "foundry",
		"content": "{\"path\":\"C:/nitrologic/foundry/foundry.js\",\"length\":31972,\"type\":\"application/javascript; charset=UTF-8\"}\n// foundry.js\r\n// a research client for evaluating models\r\n// (c)2025 Simon Armstrong\r\n\r\n// deno run --allow-run --allow-env --allow-net --allow-read --allow-write roha.js\r\n\r\nimport { contentType } from \"https://deno.land/std@0.224.0/media_types/mod.ts\";\r\nimport { resolve } from \"https://deno.land/std/path/mod.ts\";\r\nimport OpenAI from \"https://deno.land/x/openai@v4.67.2/mod.ts\";\r\n\r\nconst foundryVersion = \"rc1\";\r\nconst rohaTitle=\"foundry \"+foundryVersion;\r\nconst rohaMihi=\"I am testing foundry client. You are a helpful assistant.\";\r\n\r\nconst slowMillis = 20;\r\n\r\nconst decoder = new TextDecoder(\"utf-8\");\r\nconst encoder = new TextEncoder();\r\n\r\nconst terminalColumns=120;\r\n\r\nconst flagNames={\r\n\tcommitonstart : \"commit shared files on start\",\r\n\ttools : \"enable model tool interface\",\r\n\tansi : \"markdown ANSI rendering\",\r\n\tslow : \"output at reading speed\",\r\n\tverbose : \"emit debug information\",\r\n\tbroken : \"ansi background blocks\",\r\n\tlogging : \"log all output to file\",\r\n\tresetcounters : \"factory reset when reset\",\r\n\treturntopush : \"hit return to /push - it is under test\"\r\n};\r\n\r\nconst emptyRoha={\r\n\tconfig:{\r\n\t\tcommitonstart:true,\r\n\t\tansi:true,\r\n\t\tslow:false,\r\n\t\tverbose:false,\r\n\t\tbroken:false,\r\n\t\tlogging:false,\r\n\t\tresetcounters:false,\r\n\t\treturntopush:false\r\n\t},\r\n\ttags:{},\r\n\tmodels:{},\r\n\tband:{},\r\n\tsharedFiles:[],\r\n\tsaves:[],\r\n\tcounters:{}\r\n};\r\n\r\nfunction addBand(){\r\n\tlet id=\"member\"+increment(\"members\");\r\n\troha.band[id]={};\r\n}\r\n\r\nfunction listBand(){\r\n\tlet band=[];\r\n\tfor(let id in roha.band){\r\n\t\tlet member=roha.band[id];\r\n\t\tband.push(member);\r\n\t}\r\n\tband.push(\"add\");\r\n\tfor(let i=0;i<band.length;i++){\r\n\t\techo(i,band[i]);\r\n\t}\r\n\tmemberList=band;\r\n}\r\n\r\nfunction annotateTag(name,description){\r\n\tif(!name){\r\n\t\tthrow(\"null name\");\r\n\t}\r\n\tif(!(name in roha.tags)) {\r\n\t\troha.tags[name]={};\r\n//\t\tthrow(\"tag not found \"+name);\r\n\t}\r\n\troha.tags[name].description=description;\r\n}\r\n\r\nfunction annotateShare(name,description){\r\n\tlet index=roha.sharedFiles.findIndex(item => item.id === name);\r\n\tif(index==-1) throw(\"share id not found\");\r\n\troha.sharedFiles[index].description=description;\r\n\techo(\"file share description annotated\");\r\n}\r\n\r\nfunction increment(key){\r\n\tlet i=0;\r\n\tif(key in roha.counters){\r\n\t\ti=roha.counters[key]+1;\r\n\t}\r\n\troha.counters[key]=i;\r\n\treturn i\r\n}\r\n\r\nvar tagList=[];\r\nvar modelList=[];\r\nvar shareList=[]; //typically biggest to smallest\r\nvar memberList=[];\r\n\r\nconst emptyModel={\r\n\tname:\"empty\",account:\"\",hidden:false,prompts:0,completion:0\r\n}\r\n\r\nconst emptyTag={\r\n}\r\n\r\n// const emptyShare={path,size,modified,hash,tag,id}\r\n\r\nlet roha=emptyRoha;\r\nlet rohaCalls=0;\r\nlet listCommand=\"\";\r\nlet rohaShares=[];\r\nlet currentDir = Deno.cwd();\r\nvar rohaHistory;\r\n\r\nfunction resetHistory(){\r\n\trohaHistory = [{role:\"system\",content:rohaMihi}];\r\n}\r\n\r\nfunction listHistory(){\r\n\tlet history=rohaHistory;\r\n\tfor(let i=0;i<history.length;i++){\r\n\t\tlet item=history[i];\r\n\t\tlet content=readable(item.content).substring(0,90)\r\n\t\techo(i,item.role,item.name||\"foundry\",\"-\",content);\r\n\t}\r\n\tif(roha.config.broken){\r\n\t\tlet flat=squashMessages(rohaHistory);\r\n\t\tfor(let i=0;i<flat.length;i++){\r\n\t\t\tlet item=flat[i];\r\n\t\t\tlet content=readable(item.content).substring(0,90);\r\n\t\t\techo(\"flat\",i,item.role,item.name||\"broken\",content);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction rohaPush(content,name=\"foundry\"){\r\n\trohaHistory.push({role:\"user\",name,content});\r\n}\r\n\r\nresetHistory();\r\n\r\n// roaTools\r\n\r\nconst rohaTools = [{\r\n\ttype: \"function\",\r\n\tfunction:{\r\n\t\tname: \"read_time\",\r\n\t\tdescription: \"Returns current time in UTC\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {},\r\n\t\t\trequired: []\r\n\t\t}\r\n\t}\r\n},{\r\n\ttype: \"function\",\r\n\tfunction:{\r\n\t\tname: \"submit_file\",\r\n\t\tdescription: \"Submit a file for review\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {\r\n\t\t\t\tcontentType:{type:\"string\"},\r\n\t\t\t\tcontent:{type:\"string\"}\r\n\t\t\t},\r\n\t\t\trequired: [\"contentType\",\"content\"]\r\n\t\t}\r\n\t}\r\n},{\r\n\ttype: \"function\",\r\n\tfunction: {\r\n\t\tname: \"annotate_foundry\",\r\n\t\tdescription: \"Set description of any object\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {\r\n\t\t\t\tname: { type: \"string\" },\r\n\t\t\t\ttype: { type:\"string\" },\r\n\t\t\t\tdescription: { type: \"string\" }\r\n\t\t\t},\r\n\t\t\trequired: [\"name\",\"type\",\"description\"]\r\n\t\t}\r\n\t}\r\n}];\r\n\r\nasync function sleep(ms) {\r\n\tawait new Promise(function(resolve) {setTimeout(resolve, ms);});\r\n}\r\n\r\nfunction measure(o){\r\n\tlet total=JSON.stringify(o).length;\r\n\treturn total;\r\n}\r\n\r\nlet outputBuffer = [];\r\nlet printBuffer = [];\r\n\r\nfunction print(){\r\n\tlet args=arguments.length?Array.from(arguments):[];\r\n\tlet lines=args.join(\" \").split(\"\\n\");\r\n\tfor(let line of lines){\r\n\t\tprintBuffer.push(line.trimEnd());\r\n\t}\r\n}\r\n\r\nfunction echo(){\r\n\tlet args=arguments.length?Array.from(arguments):[];\r\n\tlet lines=args.join(\" \").split(\"\\n\");\r\n\tfor(let line of lines){\r\n\t\toutputBuffer.push(line.trimEnd());\r\n\t}\r\n}\r\n\r\nfunction stripAnsi(text) {\r\n\treturn text.replace(/\\x1B\\[\\d+(;\\d+)*[mK]/g, '');\r\n}\r\n\r\nasync function log(lines,id){\r\n\tif(roha.config.logging){\r\n\t\tconst time = new Date().toISOString();\r\n\t\tlet list=[];\r\n\t\tfor(let line of lines.split(\"\\n\")){\r\n\t\t\tline=stripAnsi(line);\r\n\t\t\tline=time+\" [\"+id+\"] \"+line+\"\\n\";\r\n\t\t\tlist.push(line);\r\n\t\t}\r\n\t\tawait Deno.writeTextFile(\"foundry.log\",list.join(),{append:true});\r\n\t}\r\n}\r\n\r\nasync function flush() {\r\n\tconst delay = roha.config.slow ? slowMillis : 0;\r\n\tfor (const line of printBuffer) {\r\n\t\tconsole.log(line);\r\n\t\tlog(line,\"model\");\r\n\t}\r\n\tprintBuffer=[];\r\n\tfor (const line of outputBuffer) {\r\n\t\tconsole.log(line);\r\n\t\tlog(line,\"stdout\");\r\n\t\tawait sleep(delay);\r\n\t}\r\n\toutputBuffer=[];\r\n}\r\n\r\nfunction wordWrap(text,cols=terminalColumns){\r\n\tvar result=[];\r\n\tvar pos=0;\r\n\twhile(pos<text.length){\r\n\t\tlet line=text.substring(pos,pos+cols);\r\n\t\tlet n=line.length;\r\n\t\tif(n==cols){\r\n\t\t\tvar i=line.lastIndexOf(\" \",n);\r\n\t\t\tif(i>0){\r\n\t\t\t\tline=line.substring(0,i);\r\n\t\t\t\tn=i+1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tresult.push(line);\r\n\t\tpos+=n;\r\n\t}\r\n\treturn result.join(\"\\n\");\r\n}\r\n\r\n// main roha application starts here\r\n\r\nconst MaxFileSize=65536;\r\n\r\nconst appDir = Deno.cwd();\r\nconst rohaPath = resolve(appDir,\"foundry.json\");\r\nconst accountsPath = resolve(appDir,\"accounts.json\");\r\nconst forgePath=resolve(appDir,\"forge\");\r\n\r\nconst modelAccounts = JSON.parse(await Deno.readTextFile(accountsPath));\r\n\r\nasync function pathExists(path) {\r\n\ttry {\r\n\t\tconst stat = await Deno.stat(path);\r\n\t\tif (!stat.isFile) return false;\r\n\t\treturn true;\r\n\t} catch (error) {\r\n\t\tif (error instanceof Deno.errors.NotFound) return false;\r\n\t\tif (error instanceof Deno.errors.PermissionDenied) return false;\r\n\t\tthrow error;\r\n\t}\r\n}\r\n\r\nconst fileExists = await pathExists(rohaPath);\r\nif (!fileExists) {\r\n\tawait Deno.writeTextFile(rohaPath, JSON.stringify(emptyRoha));\r\n\techo(\"Created new\",rohaPath);\r\n}\r\n\r\nconst rohaAccount={};\r\nfor(let account in modelAccounts){\r\n\tlet endpoint = await connectAccount(account);\r\n\tif(endpoint) rohaAccount[account]=endpoint;\r\n}\r\n\r\nfunction stringify(value, seen = new WeakSet(), keyName = \"\") {\r\n\tif (typeof value === \"string\") return value;\r\n\tif (value === null || typeof value !== \"object\") return String(value);\r\n\tif (typeof value === \"function\") return \"[function]\";\r\n\tif (seen.has(value)) return keyName ? `[circular (${keyName})]` :\"[circular]\";\r\n\tseen.add(value);\r\n\tif (Array.isArray(value)) {\r\n\t\tconst items = value.map((item, index) => stringify(item, seen,\r\n\t\tString(index)));\r\n\t\treturn `[${items.join(\",\\n\")}]`;\r\n\t}\r\n\tconst entries = Object.entries(value).map(([key, val]) => `${key}: ${stringify(val, seen, key)}`);\r\n\treturn `{${entries.join(\",\\n\")}}`;\r\n}\r\n\r\nasync function connectAccount(account) {\r\n\tlet verbose=false;//roha.config.verbose;\r\n\techo(\"Connecting to account:\", account);\r\n\tconst config = modelAccounts[account];\r\n\tif (!config) return null;\r\n\ttry{\r\n\t\tconst apiKey = Deno.env.get(config.env);\r\n\t\tconst endpoint = new OpenAI({ apiKey, baseURL: config.url });\r\n\t\tif(verbose){\r\n\t\t\tfor(const [key, value] of Object.entries(endpoint)){\r\n\t\t\t\tlet content=stringify(value);\r\n\t\t\t\techo(\"endpoint:\"+key+\":\"+content);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst models = await endpoint.models.list();\r\n\t\tconst list=[];\r\n\t\tfor (const model of models.data) {\r\n\t\t\tlet name=model.id+\"@\"+account;\r\n\t\t\tlist.push(name);\r\n\t\t\tif(verbose) echo(\"model - \",JSON.stringify(model,null,\"\\t\"));\r\n\t\t}\r\n\t\tlist.sort();\r\n\t\tmodelList=modelList.concat(list);\r\n\t\treturn endpoint;\r\n\t}catch(error){\r\n\t// Error: 429 \"Your team ac0a3c9a-0e58-4e3c-badd-be853c027a7f has either used all available credits or \r\n\t// reached its monthly spending limit. To continue making API requests, please purchase more credits or \r\n\t// raise your spending limit.\"\r\n\t\techo(error);\r\n\t}\r\n\treturn null;\r\n}\r\n\r\nasync function resetModel(name){\r\n\tgrokModel=name;\r\n\tgrokFunctions=true;\r\n\trohaHistory.push({role:\"system\",content:\"Model changed to \"+name+\".\"});\r\n\techo(\"with model\",name,grokFunctions)\r\n\tawait writeRoha();\r\n}\r\n\r\nfunction dropShares(){\r\n\tfor(let item of rohaHistory){\r\n\t\tif(item && item.role===\"user\" && item.user===\"forge\"){\r\n\t\t\titem.user=\"drop\";\r\n\t\t\titem.content=\"dropped path \"+(item.path||\"\");\t\t\t\r\n\t\t}\r\n\t}\r\n\trohaShares=[];\r\n\techo(\"all shares dropped\");\r\n}\r\n\r\nfunction listShare(){\r\n\tconst list=[];\r\n\tlet count=0;\r\n\tlet sorted = roha.sharedFiles.slice();\r\n\tsorted.sort((a, b) => b.size - a.size);\r\n\tfor (const share of sorted) {\r\n\t\tlet shared=(rohaShares.includes(share.path))?\"*\":\"\";\r\n\t\tlet tags=\"[\"+share.tag+\"]\";\r\n\t\tlet info=(share.description)?share.description:\"\";\r\n\t\techo((count++),share.path,share.size,shared,tags,info);\r\n\t\tlist.push(share.id);\r\n\t}\r\n\tshareList=list;\r\n}\r\n\r\nfunction listSaves(){\r\n\tlet saves=roha.saves||[];\r\n\tfor(let i=0;i<saves.length;i++){\r\n\t\techo(i,saves[i]);\r\n\t}\r\n}\r\n\r\nasync function saveHistory(name) {\r\n\ttry {\r\n\t\tlet timestamp=Math.floor(Date.now()/1000).toString(16);\r\n\t\tlet filename=(name||\"transmission-\"+timestamp)+\".json\";\r\n\t\tlet filePath = resolve(forgePath,filename);\r\n\t\tlet line=\"Saved session \"+filename+\".\";\r\n\t\trohaHistory.push({role:\"system\",content:line});\r\n\t\tawait Deno.writeTextFile(filePath,JSON.stringify(rohaHistory,null,\"\\t\"));\r\n\t\techo(line);\r\n\t\troha.saves.push(filename);\r\n\t\tawait writeRoha();\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error saving history:\", error.message);\r\n\t}\r\n}\r\n\r\nasync function loadHistory(filename){\r\n\tvar history;\r\n\ttry {\r\n\t\tconst fileContent = await Deno.readTextFile(filename);\r\n\t\thistory = JSON.parse(fileContent);\r\n\t\techo(\"History restored from \"+filename);\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error restoring history:\", error.message);\r\n\t\techo(\"console error\");\r\n\t\thistory=[{role:\"system\",content: \"You are a helpful assistant.\"}];\r\n\t}\r\n\treturn history;\r\n}\r\n\r\nconst ansiBackgrounds = [\r\n\t{ name: \"dark0\", code: \"\\x1b[48;5;232m\" }, // #1c2526\r\n\t{ name: \"dark1\", code: \"\\x1b[48;5;233m\" }, // #2e3436\r\n\t{ name: \"dark2\", code: \"\\x1b[48;5;234m\" }, // #3d4446\r\n\t{ name: \"dark3\", code: \"\\x1b[48;5;235m\" }, // #4e5456\r\n\t{ name: \"charcoal\", code: \"\\x1b[48;5;236m\" }, // #606668\r\n\t{ name: \"darkBlue\", code: \"\\x1b[48;5;17m\" }, // #00005f\r\n\t{ name: \"darkGreen\", code: \"\\x1b[48;5;23m\" }, // #003f3f\r\n\t{ name: \"darkMutedPurple\", code: \"\\x1b[48;5;54m\" }, // #5f00af\r\n\t{ name: \"veryDarkBlue\", code: \"\\x1b[48;5;18m\" }, // #000087\r\n\t{ name: \"darkCharcoal\", code: \"\\x1b[48;5;239m\" }, // #4e4e4e\r\n\t{ name: \"mutedNavy\", code: \"\\x1b[48;5;19m\" }, // #0000af\r\n\t{ name: \"deepGray\", code: \"\\x1b[48;5;240m\" } // #585858\r\n];\r\n\r\nconst ansiMoveToEnd = \"\\x1b[999B\";\r\nconst ansiSaveCursor = \"\\x1b[s\";\r\nconst ansiRestoreCursor = \"\\x1b[u\";\r\n\r\nconst ansiReplyBlock = ansiBackgrounds[0].code;\r\nconst ansiCodeBlock = ansiBackgrounds[6].code;\r\n\r\nconst rohaPrompt=\">\";\r\n\r\nconst ansiItalics = \"\\x1b[3m\";\r\nconst ansiReset = \"\\x1b[0m\";\r\nconst ansiPurple = \"\\x1b[1;35m\";\r\n\r\nfunction mdToAnsi(md) {\r\n\tlet broken=roha.config.broken;\r\n\tconst lines = md.split(\"\\n\");\r\n\tlet inCode = false;\r\n\tconst result = broken?[ansiReplyBlock]:[];\r\n\tfor (let line of lines) {\r\n\t\tline=line.trimEnd();\r\n\t\tlet trim=line.trim();\r\n\t\tif (trim.startsWith(\"```\")) {\r\n\t\t\tinCode = !inCode;\r\n\t\t\tif(inCode){\r\n\t\t\t\tresult.push(ansiCodeBlock);\r\n\t\t\t\tlet codeType=trim.substring(3);\r\n\t\t\t\techo(\"inCode \"+codeType);\r\n\t\t\t}else{\r\n\t\t\t\tif (broken) result.push(ansiReplyBlock);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif (!inCode) {\r\n\t\t\t\t// headershow\r\n\t\t\t\tconst header = line.match(/^#+/);\r\n\t\t\t\tif (header) {\r\n\t\t\t\t\tconst level = header[0].length;\r\n\t\t\t\t\tline = line.substring(level).trim();\r\n\t\t\t\t\tline = ansiPurple + line + ansiReset;\r\n\t\t\t\t}\r\n\t\t\t\t// bullets\r\n\t\t\t\tif (line.startsWith('-') || line.startsWith('*') || line.startsWith('+')) {\r\n\t\t\t\t\tline = '• ' + line.substring(1).trim();\r\n\t\t\t\t}\r\n\t\t\t\t// bold\r\n\t\t\t\tif (line.includes(\"**\")) {\r\n\t\t\t\t\tline = line.replace(/\\*\\*(.*?)\\*\\*/g, \"\\x1b[1m$1\\x1b[0m\");\r\n\t\t\t\t}\r\n\t\t\t\t// italic\r\n\t\t\t\tline = line.replace(/\\*(.*?)\\*/g, \"\\x1b[3m$1\\x1b[0m\");\r\n\t\t\t\tline = line.replace(/_(.*?)_/g, \"\\x1b[3m$1\\x1b[0m\");\r\n\t\t\t\t// wordwrap\r\n\t\t\t\tline=wordWrap(line,terminalColumns);\r\n\t\t\t}\r\n\t\t\tresult.push(line.trimEnd());\r\n\t\t}\r\n\t}\r\n\tresult.push(ansiReset);\r\n\treturn result.join(\"\\n\");\r\n}\r\n\r\nasync function hashFile(filePath) {\r\n\tconst fileContent = await Deno.readFile(filePath);\r\n\tconst hashBuffer = await crypto.subtle.digest(\"SHA-256\", fileContent);\r\n\tconst hashArray = new Uint8Array(hashBuffer);\r\n\treturn Array.from(hashArray).map(byte => byte.toString(16).padStart(2, '0')).join('');\r\n}\r\n\r\nasync function readRoha(){\r\n\ttry {\r\n\t\tconst fileContent = await Deno.readTextFile(rohaPath);\r\n\t\troha = JSON.parse(fileContent);\r\n\t\tif(!roha.saves) roha.saves=[];\r\n\t\tif(!roha.counters) roha.counters={};\r\n\t\tif(!roha.band) roha.band={};\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error reading or parsing\",rohaPath,error);\r\n\t\troha=emptyRoha;\r\n\t}\r\n}\r\n\r\nasync function writeRoha(){\r\n\ttry {\r\n\t\troha.model=grokModel;\r\n\t\tawait Deno.writeTextFile(rohaPath, JSON.stringify(roha, null, \"\\t\"));\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error writing\",rohaPath,error);\r\n\t}\r\n}\r\n\r\nasync function resetRoha(){\r\n\trohaShares = [];\r\n\troha.sharedFiles=[];\r\n\troha.tags={};\r\n\tif(roha.config.resetcounters) roha.counters={};\r\n\tincrement(\"resets\");\r\n\tawait writeRoha();\r\n\tresetHistory();\r\n\techo(\"resetRoha\",\"All shares and history reset.\");\r\n}\r\n\r\nfunction resolvePath(dir,filename){\r\n\tlet path=resolve(dir,filename);\r\n\tpath = path.replace(/\\\\/g, \"/\");\r\n\treturn path;\r\n}\r\n\r\n// a raw mode prompt replacement\r\n\r\n// arrow navigation and tab completion incoming\r\n\r\nconst reader = Deno.stdin.readable.getReader();\r\nconst writer = Deno.stdout.writable.getWriter();\r\n\r\nasync function prompt2(message) {\r\n\tif (message) {\r\n\t\tawait writer.write(encoder.encode(message));\r\n\t\tawait writer.ready;\r\n\t}\r\n\tDeno.stdin.setRaw(true);\r\n\tlet inputBuffer = new Uint8Array(0);\r\n\ttry {\r\n\t\twhile (true) {\r\n\t\t\tconst { value, done } = await reader.read();\r\n\t\t\tif (done || !value) break;\r\n\t\t\tfor (const byte of value) {\r\n\t\t\t\tif (byte === 0x7F || byte === 0x08) { // Backspace\r\n\t\t\t\t\tif (inputBuffer.length > 0) {\r\n\t\t\t\t\t\tinputBuffer = inputBuffer.slice(0, -1);\r\n\t\t\t\t\t\tawait writer.write(new Uint8Array([0x08, 0x20, 0x08])); // Erase last char\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (byte === 0x1b) { // Escape sequence\r\n\t\t\t\t\tif(value.length==1){\r\n\t\t\t\t\t\tDeno.exit(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(value.length==3){\r\n\t\t\t\t\t\tif(value[1]==0xf4 && value[2]==0x50){\r\n\t\t\t\t\t\t\techo(\"F1\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (byte === 0x0A || byte === 0x0D) { // Enter key\r\n\t\t\t\t\tawait writer.write(encoder.encode(\"\\r\\n\"));\r\n\t\t\t\t\tlet line = decoder.decode(inputBuffer);\r\n\t\t\t\t\tline=line.trim();\r\n\t\t\t\t\tlog(line,\"stdin\");\r\n\t\t\t\t\treturn line;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tawait writer.write(new Uint8Array([byte]));\r\n\t\t\t\t\tconst buf = new Uint8Array(inputBuffer.length + 1);\r\n\t\t\t\t\tbuf.set(inputBuffer);\r\n\t\t\t\t\tbuf[inputBuffer.length] = byte;\r\n\t\t\t\t\tinputBuffer = buf;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} finally {\r\n\t\tDeno.stdin.setRaw(false);\r\n\t}\r\n}\r\n\r\n// callers to addShare expected to await writeRoha after\r\n\r\nconst eventList=[];\r\n\r\nasync function watchPaths(paths,handler){\r\n\tconst watcher = Deno.watchFs(paths,{recursive:false});\r\n\tfor await (const event of watcher) {\r\n\t\teventList.push(event);\r\n\t}\r\n}\r\n\r\nasync function addShare(share){\r\n\tshare.id=\"share\"+increment(\"shares\");\r\n\troha.sharedFiles.push(share);\r\n\tif(share.tag) {\r\n\t\tawait setTag(share.tag,share.id);\r\n\t}\r\n}\r\n\r\nasync function shareDir(dir,tag) {\r\n\ttry {\r\n\t\tconst paths=[];\r\n\t\tconst files = await Deno.readDir(dir);\r\n\t\tfor await (const file of files) {\r\n\t\t\tif (file.isFile && !file.name.startsWith(\".\")) {\r\n\t\t\t\tpaths.push(resolvePath(dir, file.name));\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const path of paths) {\r\n//\t\t\techo(\"statting path:\"+path+\":\");\r\n\t\t\tconst info = await Deno.stat(path);\r\n\t\t\tlet size=info.size;\r\n\t\t\tlet modified=info.mtime.getTime();\r\n\t\t\tconst hash = await hashFile(path);\r\n\t\t\tawait addShare({path,size,modified,hash,tag})\r\n\t\t}\r\n\t\tawait writeRoha(); // TODO: check a dirty flag\r\n\t} catch (error) {\r\n\t\tconsole.error(\"### Error\"+error);\r\n\t}\r\n}\r\n\r\nfunction fileType(extension){\r\n\treturn contentType(extension) || 'application/octet-stream';\r\n}\r\n\r\nconst textExtensions = [\r\n\t\"js\", \"txt\", \"json\", \"md\",\r\n\t\"css\",\"html\", \"svg\",\r\n\t\"cpp\", \"c\", \"h\", \"cs\",\r\n\t\"sh\", \"bat\",\r\n\t\"log\",\"py\",\"csv\",\"xml\",\"ini\"\r\n];\r\n\r\nasync function shareFile(path,tag) {\r\n\tlet fileContent=null;\r\n\ttry {\r\n\t\tfileContent = await Deno.readFile(path);\r\n\t} catch (error) {\r\n\t\tconsole.error(\"shareFile path:\"+path+\" error:\", error);\r\n\t\treturn;\r\n\t}\r\n\tif(path.endsWith(\"rules.txt\")){\r\n\t\tlet lines=decoder.decode(fileContent).split(\"\\n\");\r\n\t\tfor(let line of lines ){\r\n\t\t\tif (line) rohaHistory.push({role:\"system\",content: line});\r\n\t\t}\r\n\t}else{\r\n\t\tconst length=fileContent.length;\r\n\t\tif(length>0 && length<MaxFileSize){\r\n\t\t\tconst extension = path.split('.').pop();\r\n\t\t\tconst type = fileType(extension);\r\n\t\t\tif (textExtensions.includes(extension)) {\r\n\t\t\t\tlet txt = decoder.decode(fileContent);\r\n\t\t\t\tif(txt.length){\r\n\t\t\t\t\tlet metadata=JSON.stringify({path,length,type,tag});\r\n\t\t\t\t\trohaPush(metadata);\r\n\t\t\t\t\trohaPush(txt,\"forge\");\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tconst base64Encoded = btoa(String.fromCharCode(...new Uint8Array(fileContent)));\r\n\t\t\t\tconst mimeType = fileType(extension);\r\n\t\t\t\tlet metadata=JSON.stringify({path,length,type,mimeType,tag});\r\n\t\t\t\trohaPush(metadata);\r\n\t\t\t\tlet binary=`File content: MIME=${mimeType}, Base64=${base64Encoded}`;\r\n\t\t\t\trohaPush(binary,\"forge\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n//\tif(roha.config.verbose)echo(\"roha shared file \" + path);\r\n\tif (!rohaShares.includes(path)) rohaShares.push(path);\r\n}\r\n\r\nasync function commitShares(tag) {\r\n\tlet dirty = false;\r\n\tconst validShares = [];\r\n\tconst removedPaths = [];\r\n\tfor (const share of roha.sharedFiles) {\r\n\t\tif (tag && share.tag !== tag) {\r\n\t\t\tvalidShares.push(share);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tconst info = await Deno.stat(share.path);\r\n\t\t\tconst modified = share.modified !== info.mtime.getTime();\r\n\t\t\tconst isShared = rohaShares.includes(share.path);\r\n\t\t\tif (modified || !isShared) {\r\n\t\t\t\tawait shareFile(share.path,tag);\r\n\t\t\t\tshare.modified = info.mtime.getTime();\r\n\t\t\t\tdirty = true;\r\n\t\t\t}\r\n\t\t\tvalidShares.push(share);\r\n\t\t} catch (error) {\r\n\t\t\tremovedPaths.push(share.path);\r\n\t\t\tdirty = true;\r\n\t\t}\r\n\t}\r\n\r\n\tif (removedPaths.length) {\r\n\t\troha.sharedFiles = validShares;\r\n\t\tawait writeRoha();\r\n\t\techo(`Invalid shares detected:\\n${removedPaths.join('\\n')}`);\r\n\t}\r\n\r\n\tif (dirty&&tag) {\r\n\t\tlet invoke=\"feel free to call annotate_foundry to tag \"+tag;\r\n\t\trohaHistory.push({role:\"system\",content:invoke});\r\n\t}\r\n\r\n\treturn dirty;\r\n}\r\n\r\nasync function setTag(name,note){\r\n\tlet tags=roha.tags||{};\r\n\tlet tag=(tags[name])?tags[name]:{name,info:[]};\r\n\ttag.info.push(note);\r\n\ttags[name]=tag;\r\n\troha.tags=tags;\r\n\tawait writeRoha();\r\n//\tlet invoke=`New tag \"${name}\" added. Describe all shares with this tag.`;\r\n//\trohaHistory.push({role:\"system\",content:invoke});\r\n}\r\nfunction listCounters(){\r\n\tlet keys=Object.keys(roha.counters);\r\n\tlet i=0;\r\n\tfor(let key of keys){\r\n\t\tlet count=roha.counters[key];\r\n\t\techo((i++),key,count);\r\n\t}\r\n}\r\nfunction listTags(){\r\n\tlet tags=roha.tags||{};\r\n\tlet keys=Object.keys(tags);\r\n\tlet list=[];\r\n\tfor(let i=0;i<keys.length;i++){\r\n\t\tlet tag=tags[keys[i]];\r\n\t\tconst name=tag.name||\"?????\";\r\n\t\techo(i,name,\"(\"+tag.info.length+\")\");\r\n\t\tlet info=tag.description;\r\n\t\tif(info) echo(\"\",info);\r\n\t\tlist.push(name);\r\n\t}\r\n\ttagList=list;\r\n}\r\n\r\nfunction listAccounts(){\r\n\tlet list=[];\r\n\tfor(let key in modelAccounts){\r\n\t\tlet value=modelAccounts[key];\r\n\t\tlist.push(key);\r\n\t}\r\n\tfor(let i=0;i<list.length;i++){\r\n\t\techo(i,list[i]);\r\n\t}\r\n}\r\n\r\nasync function showHelp() {\r\n\ttry {\r\n\t\tconst md = await Deno.readTextFile(\"foundry.md\");\r\n\t\techo(mdToAnsi(md));\r\n\t} catch (e) {\r\n\t\techo(\"Error loading help file: \" + e.message);\r\n\t}\r\n}\r\n\r\nfunction readable(text){\r\n\ttext=text.replace(/\\s+/g, \" \");\r\n\treturn text;\r\n}\r\n\r\nasync function callCommand(command) {\r\n\tlet dirty=false;\r\n\tlet words = command.split(\" \",2);\r\n\ttry {\r\n\t\tswitch (words[0]) {\r\n\t\t\tcase \"band\":\r\n\t\t\t\tlistBand();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"counter\":\r\n\t\t\t\tlistCounters();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"tag\":\r\n\t\t\t\tawait listTags();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"account\":\r\n\t\t\t\tawait listAccounts();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"help\":\r\n\t\t\t\tawait showHelp();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"config\":\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\tlet flag=words[1].trim();\r\n\t\t\t\t\tif(flag.length && !isNaN(flag)){\r\n\t\t\t\t\t\tflag=Object.keys(flagNames)[flag|0];\r\n\t\t\t\t\t\techo(\"flag\",flag);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(flag in flagNames){\r\n\t\t\t\t\t\troha.config[flag]=!roha.config[flag];\r\n\t\t\t\t\t\techo(flag+\" - \"+flagNames[flag]+\" is \"+(roha.config[flag]?\"true\":\"false\"));\r\n\t\t\t\t\t\tawait writeRoha();\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlet count=0;\r\n\t\t\t\t\tfor(let flag in flagNames){\r\n\t\t\t\t\t\techo((count++),flag,\":\",flagNames[flag],\":\",(roha.config[flag]?\"true\":\"false\"))\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistCommand=\"config\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"time\":\r\n\t\t\t\techo(\"Current time:\", new Date().toString());\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"history\":\r\n\t\t\t\tlistHistory();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"load\":\r\n\t\t\t\tlet save=words[1];\r\n\t\t\t\tif(save){\r\n\t\t\t\t\tif(save.length && !isNaN(save)) save=roha.saves[save|0];\r\n\t\t\t\t\tif(roha.saves.includes(save)){\r\n\t\t\t\t\t\tlet history=await loadHistory(save);\r\n\t\t\t\t\t\trohaHistory=history;\r\n\t\t\t\t\t\techo(\"a new history is set\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlistSaves();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"save\":\r\n\t\t\t\tlet savename=words.slice(1).join(\" \");\r\n\t\t\t\tsaveHistory(savename);\r\n\t\t\t\tawait writeRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"model\":\r\n\t\t\t\tlet name=words[1];\r\n\t\t\t\tif(name){\r\n\t\t\t\t\tif(name.length&&!isNaN(name)) name=modelList[name|0];\r\n\t\t\t\t\tif(modelList.includes(name)){\r\n\t\t\t\t\t\tresetModel(name);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor(let i=0;i<modelList.length;i++){\r\n\t\t\t\t\t\tlet name=modelList[i];\r\n\t\t\t\t\t\tlet attr=(name==grokModel)?\"*\":\"\";\r\n\t\t\t\t\t\techo(i,name,attr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistCommand=\"model\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"reset\":\r\n\t\t\t\tawait resetRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"cd\":\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\tconst newDir = words[1];\r\n\t\t\t\t\tif (newDir.length) Deno.chdir(newDir);\r\n\t\t\t\t}\r\n\t\t\t\tcurrentDir = Deno.cwd();\r\n\t\t\t\techo(\"Changed directory to\", currentDir);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"dir\":\r\n\t\t\t\tconst files = Deno.readDirSync(currentDir);\r\n\t\t\t\techo(\"Contents of\", currentDir + \":\");\r\n\t\t\t\tfor (const file of files) {\r\n\t\t\t\t\tlet name=(file.isDirectory)?\"[\"+file.name+\"]\":file.name;\r\n\t\t\t\t\techo(name);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"drop\":\r\n\t\t\t\tdropShares();\r\n\t\t\t\tawait writeRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"share\":\r\n\t\t\t\tif (words.length==1){\r\n\t\t\t\t\tlistShare();\r\n\t\t\t\t}else{\r\n\t\t\t\t\tconst filename = words.slice(1).join(\" \");\r\n\t\t\t\t\tconst path = resolvePath(Deno.cwd(), filename);\r\n\t\t\t\t\tconst info = await Deno.stat(path);\r\n\t\t\t\t\tconst tag = await prompt2(\"Enter tag name (optional):\");\r\n\t\t\t\t\tif(info.isDirectory){\r\n\t\t\t\t\t\techo(\"Share directory path:\",path);\r\n\t\t\t\t\t\tawait shareDir(path,tag);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlet size=info.size;\r\n\t\t\t\t\t\tlet modified=info.mtime.getTime();\r\n\t\t\t\t\t\techo(\"Share file path:\",path,\" size:\",info.size,\" \");\r\n\t\t\t\t\t\tconst hash = await hashFile(path);\r\n\t\t\t\t\t\techo(\"hash:\",hash);\r\n\t\t\t\t\t\tawait addShare({path,size,modified,hash,tag});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tawait writeRoha();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"push\":\r\n\t\t\tcase \"commit\":\r\n\t\t\t\tlet tag=\"\";\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\ttag=words[1];\r\n\t\t\t\t}\r\n\t\t\t\tdirty=await commitShares(tag);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\techo(\"Command not recognised\");\r\n\t\t\t\treturn false; // Command not recognized\r\n\t\t}\r\n\t} catch (error) {\r\n\t\techo(\"Error processing command:\", error.message);\r\n\t}\r\n\tincrement(\"calls\");\r\n\treturn dirty;\r\n}\r\n\r\necho(rohaTitle,\"running from \"+rohaPath);\r\nawait readRoha();\r\n\r\nlet grokModel = roha.model||\"deepseek-chat@deepseek\";\r\nlet grokFunctions=true;\r\nlet grokUsage = 0;\r\n\r\necho(\"present [\",grokModel,\"]\");\r\necho(\"shares count:\",roha.sharedFiles.length)\r\necho(\"use /help for latest and exit to quit\");\r\necho(\"\");\r\n\r\nlet sessions=increment(\"sessions\");\r\nif(sessions==0){\r\n\tlet welcome=await Deno.readTextFile(\"welcome.txt\");\r\n\techo(welcome);\r\n\tawait writeRoha();\r\n}\r\n\r\nif(roha.config){\r\n\tif(roha.config.commitonstart) await commitShares();\r\n}else{\r\n\troha.config={};\r\n}\r\n\r\nfunction extensionForType(contentType) {\r\n\tif (contentType.includes(\"markdown\")) return \".md\";\r\n\tif (contentType.includes(\"json\")) return \".json\";\r\n\tif (contentType.includes(\"javascript\")) return \".js\";\r\n\treturn \".txt\";\r\n}\r\n\r\nasync function onCall(toolCall) {\r\n\tlet verbose=roha.config.verbose;\r\n\tswitch(toolCall.function.name) {\r\n\t\tcase \"read_time\":\r\n\t\t\treturn {time: new Date().toISOString()};\r\n\t\tcase \"submit_file\":\r\n\t\t\tlet args=JSON.parse(toolCall.function.arguments);\r\n\t\t\techo(args.contentType);\r\n\t\t\tif (verbose) echo(args.content);\r\n\t\t\tlet timestamp=Math.floor(Date.now()/1000).toString(16);\r\n\t\t\tlet extension=extensionForType(args.contentType)\r\n\t\t\tlet name= \"submission-\"+timestamp+extension;\r\n\t\t\tlet filePath = resolve(forgePath,name);\r\n\t\t\tawait Deno.writeTextFile(filePath, args.content);\r\n\t\t\techo(\"File saved to:\", filePath);\r\n\t\t\treturn { success: true, path: filePath };\r\n\t\tcase \"annotate_foundry\":\r\n\t\t\ttry {\r\n\t\t\t\tconst { name, type, description } = JSON.parse(toolCall.function.arguments || \"{}\");\r\n\t\t\t\tswitch(type){\r\n\t\t\t\t\tcase \"tag\":\r\n\t\t\t\t\t\tannotateTag(name,description);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"share\":\r\n\t\t\t\t\t\tannotateShare(name,description);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tawait writeRoha(); // Persist changes\r\n\t\t\t\treturn { success: true, updated: 1 };\r\n\t\t\t} catch (error) {\r\n\t\t\t\techo(\"annotate_foundry error:\",error);\r\n\t\t\t\treturn { success: false, updated: 0 };\r\n\t\t\t}\r\n\t}\r\n\tconsole.error(\"onCall error - call simon\");\r\n}\r\n\r\nfunction squashMessages(history) {\r\n\tif (history.length < 2) return history;\r\n\tconst squashed = [history[0]];\r\n\tlet system=[];\r\n\tlet other=[];\r\n\tfor(let item of history){\r\n\t\tif(item.role==\"system\") system.push(item); else other.push(item);\r\n\t}\r\n\tfor(let list of [system,other]){\r\n\t\tlet last=null;\r\n\t\tfor (let i = 0; i < list.length; i++) {\r\n\t\t\tconst current=list[i];\r\n\t\t\tif(last){\r\n\t\t\t\tlast.content += \"\\n\" + current.content;\r\n\t\t\t} else {\r\n\t\t\t\tsquashed.push(current);\r\n\t\t\t\tlast=current;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn squashed;\r\n}\r\n\r\nasync function isolateCode(path,cwd) {\r\n\ttry {\r\n\t\tconst readAllow = `--allow-read=${cwd}`;\r\n\t\tconst writeAllow = `--allow-write=${cwd}`;\r\n\t\tconst cmd = [\"deno\", \"run\", \"--no-remote\", readAllow, writeAllow, path];\r\n\t\tconst process = Deno.run({ cmd, stdout: \"piped\", stderr: \"piped\" });\r\n\t\tconst [stdout, stderr] = await Promise.all([process.output(), process.stderrOutput()]);\r\n\t\tconst status = await process.status();\r\n\t\tprocess.close();\r\n\t\treturn {\r\n\t\t\tsuccess: status.success,\r\n\t\t\toutput: new TextDecoder().decode(stdout),\r\n\t\t\terror: new TextDecoder().decode(stderr)\r\n\t\t};\r\n\t} catch (err) {\r\n\t\treturn { success: false, output: \"\", error: err.message };\r\n\t}\r\n}\r\n\r\nasync function runCode(){\r\n\tlet result = await isolateCode(\"isolation/test.js\", \"isolation\");\r\n\t//echo(\"RunCode Result:\", result.success ? \"Success\" : \"Failed\");\r\n\tif (result.output) echo(\"[isolation] \", result.output);\r\n\tif (result.error) echo(\"Error:\", result.error);\r\n\t// todo: add save on exit\r\n}\r\n\r\nasync function relay() {\r\n\tconst verbose=roha.config.verbose;\r\n\ttry {\r\n\t\tconst modelAccount=grokModel.split(\"@\");\r\n\t\tlet model=modelAccount[0];\r\n\t\tlet account=modelAccount[1];\r\n\t\tlet endpoint=rohaAccount[account];\r\n\t\tlet usetools=grokFunctions&&roha.config.tools;\r\n\t\tconst payload = usetools?{ model, messages:rohaHistory, tools: rohaTools }:{ model, messages:squashMessages(rohaHistory) };\r\n\t\tconst completion = await endpoint.chat.completions.create(payload);\r\n\t\tif (completion.model != model) {\r\n\t\t\techo(\"[relay model alert model:\" + completion.model + \" grokModel:\" + grokModel + \"]\");\r\n\t\t\tgrokModel=completion.model+\"@\"+account;\r\n\t\t}\r\n\t\tif (verbose) {\r\n\t\t\t// echo(\"relay completion:\" + JSON.stringify(completion, null, \"\\t\"));\r\n\t\t}\r\n\t\tlet system = completion.system_fingerprint;\r\n\t\tlet usage = completion.usage;\r\n\t\tlet size = measure(rohaHistory);\r\n\t\tgrokUsage += usage.prompt_tokens | 0 + usage.completion_tokens | 0;\r\n\t\tlet status = \"[model \" + grokModel + \" \" + usage.prompt_tokens + \" \" + usage.completion_tokens + \" \" + grokUsage + \" \" + size + \"]\";\r\n\t\techo(status);\r\n\t\tvar reply = \"<blank>\";\r\n\t\tfor (const choice of completion.choices) {\r\n\t\t\tlet calls = choice.message.tool_calls;\r\n\t\t\t// choice has index message{role,content,refusal,annotations} finish_reason\r\n\t\t\tif (calls) {\r\n\t\t\t\tincrement(\"calls\");\r\n\t\t\t\techo(\"relay calls in progress\");\r\n\t\t\t\t// Generate tool_calls with simple, unique IDs\r\n\t\t\t\tconst toolCalls = calls.map((tool, index) => ({\r\n\t\t\t\t\tid: `call_${rohaCalls++}`,\r\n\t\t\t\t\ttype: \"function\",\r\n\t\t\t\t\tfunction: {\r\n\t\t\t\t\t\tname: tool.function.name,\r\n\t\t\t\t\t\targuments: tool.function.arguments || \"{}\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}));\r\n\t\t\t\t// Add assistant message with tool_calls\r\n\t\t\t\tlet content=choice.message.content || \"\";\r\n\t\t\t\trohaHistory.push({role:\"assistant\",content,tool_calls: toolCalls});\r\n\t\t\t\tif(verbose) echo(\"tooling \"+content);\r\n\t\t\t\t// Add tool responses\r\n\t\t\t\tfor (let i = 0; i < calls.length; i++) {\r\n\t\t\t\t\tconst tool = calls[i];\r\n\t\t\t\t\tconst result = await onCall(tool);\r\n\t\t\t\t\tif (result){\r\n\t\t\t\t\t\tlet content=JSON.stringify(result);\r\n\t\t\t\t\t\trohaHistory.push({\r\n\t\t\t\t\t\t\trole: \"tool\",\r\n\t\t\t\t\t\t\ttool_call_id: toolCalls[i].id,\r\n\t\t\t\t\t\t\tname: tool.function.name,\r\n\t\t\t\t\t\t\tcontent\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\techo(\"no oncall result\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn relay(); // Recursive call to process tool results\r\n\t\t\t}\r\n\t\t\treply = choice.message.content;\r\n\t\t\tif (roha.config && roha.config.ansi) {\r\n//\t\t\t\techo(ansiSaveCursor);\r\n\t\t\t\tprint(mdToAnsi(reply));\r\n//\t\t\t\techo(ansiRestoreCursor);\r\n\t\t\t} else {\r\n\t\t\t\tprint(wordWrap(reply));\r\n\t\t\t}\r\n\t\t}\r\n\t\trohaHistory.push({ role: \"assistant\", content: reply });\r\n\t} catch (error) {\r\n\t\tlet line=error.message || String(error);\r\n\t\t//Error during API call: Error: 400 \"This model's maximum prompt length is 131072 but the request contains 165547 tokens.\"\r\n\t\tif(line.includes(\"maximum prompt length\")){\r\n\t\t\techo(\"maximum prompt length exceeded, switch model or drop shares to continue\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconsole.error(\"Error during API call:\", error);\t\r\n\t\tif(grokFunctions){\r\n\t\t\techo(\"resetting grokFunctions\")\r\n\t\t\tgrokFunctions=false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nasync function chat() {\r\n\tdance:\r\n\twhile (true) {\r\n\t\tlet lines=[];\r\n//\t\techo(ansiMoveToEnd);\r\n\t\twhile (true) {\r\n\t\t\tawait flush();\r\n\t\t\tlet line=\"\";\r\n\t\t\tif(listCommand){\r\n\t\t\t\tline=await prompt2(\"#\");\r\n\t\t\t\tif(line.length && !isNaN(line)){\r\n\t\t\t\t\tlet index=line|0;\r\n\t\t\t\t\tawait callCommand(listCommand+\" \"+index);\r\n\t\t\t\t}\r\n\t\t\t\tlistCommand=\"\";\r\n\t\t\t}else{\r\n\t\t\t\tline=await prompt2(rohaPrompt);\r\n\t\t\t}\r\n\t\t\tif (line === '') {\r\n\t\t\t\tif(roha.config.returntopush && !lines.length) {\r\n\t\t\t\t\techo(\"auto pushing...\");\r\n\t\t\t\t\tawait callCommand(\"push\");\r\n\t\t\t\t\tawait relay();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (line === \"exit\") {\r\n\t\t\t\techo(\"Ending the conversation...\");\r\n\t\t\t\tbreak dance;\r\n\t\t\t}\r\n\t\t\tif (line.startsWith(\"/\")) {\r\n\t\t\t\tconst command = line.substring(1).trim();\r\n\t\t\t\tlet dirty=await callCommand(command);\r\n\t\t\t\tif(dirty){\r\n\t\t\t\t\tlines.push(\"Please review source for bugs and all content if notable changes detected, thanks.\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlines.push(line.trim());\r\n\t\t}\r\n\r\n\t\tif (lines.length){\r\n\t\t\tconst query=lines.join(\"\\n\");\r\n\t\t\tif(query.length){\r\n\t\t\t\trohaHistory.push({ role: \"user\", content: query });\r\n\t\t\t\tawait relay();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nDeno.addSignalListener(\"SIGINT\", () => {Deno.exit(0);});\r\n\r\n//only windows Deno.addSignalListener(\"SIGBREAK\", () => {echo(\"SIGBREAK\");});\r\n\r\nawait runCode(\"isolation/test.js\",\"isolation\");\r\n\r\nchat();\r\n\n{\"path\":\"C:/nitrologic/foundry/release/accounts.json\",\"length\":362,\"type\":\"application/json; charset=UTF-8\"}\n{\r\n\t\"gemini\":{\r\n\t\t\"env\":\"GEMINI_API_KEY\",\r\n\t\t\"url\":\"https://generativelanguage.googleapis.com/v1beta/openai\"\r\n\t},\r\n\t\"deepseek\":{\r\n\t\t\"env\":\"DEEPSEEK_API_KEY\",\r\n\t\t\"url\":\"https://api.deepseek.com\"\r\n\t},\r\n\t\"xai\": {\r\n\t\t\"env\": \"XAI_API_KEY\",\r\n\t\t\"url\": \"https://api.x.ai/v1\"\r\n\t},\r\n\t\"openai\": {\r\n\t\t\"env\": \"OPENAI_API_KEY\",\r\n\t\t\"url\": \"https://api.openai.com/v1\"\r\n\t}\r\n  }\r\n\n{\"path\":\"C:/nitrologic/foundry/release/foundry.md\",\"length\":2601,\"type\":\"text/markdown; charset=UTF-8\"}\n# foundry command line client\r\n\r\nA command line application designed to chat and share files.\r\n\r\n## foundry machine interface\r\n\r\nThe foundry functional interface uses tools and tool_calls.\r\n\r\nOnly recent models provide tools interface, foundry should fall \r\nback to a no tools completion mode.\r\n\r\nSee the OpenAI API spec for more tool role details.\r\n\r\n### read_time\r\n\r\n### submit_file\r\n\r\n### annotate_foundry\r\n\r\n## foundry user interface\r\n\r\ncommands with no arguments may often prompt for a # index from\r\nthe items displayed\r\n\r\n### /config\r\n\r\nToggle configuration flags.\r\n\r\nAdjust settings to suit current preferences.\r\n\r\nDefault values are typically:\r\n\r\n* 0 commitonstart : commit shared files on start : true\r\n* 1 ansi : markdown ANSI rendering : true\r\n* 2 slow : output at reading speed : true\r\n* 3 verbose : emit debug information : true\r\n* 4 broken : ansi background blocks : false\r\n* 5 logging : log all output to file : true\r\n* 6 resetcounters : at reset zero all counters : true\r\n\r\n### /share\r\n\r\nShare a file or folder with optional tag.\r\n\r\nFiles are added to the share list used by the /push /commit command.\r\n\r\n### /drop\r\n\r\nDrop all files currently shared\r\n\r\n### /push /commit\r\n\r\nRefresh shared files. \r\n\r\nDetects changes or deletions and updates the chat history.\r\n\r\nPosts new versions of file content if modified.\r\n\r\n### /reset\r\n\r\nClear all shared files and conversation history.\r\n\r\n### /history\r\n\r\nList a summary of recent conversation entries. \r\n\r\nProvides a quick overview of chat history.\r\n\r\n### /cd\r\n\r\nChange the working directory. \r\n\r\nUser can navigate to a desired directory for file operations.\r\n\r\n### /dir\r\n\r\nList the contents of the current working directory. \r\n\r\nHelps user view available files and folders to share.\r\n\r\n\r\n### /model\r\n\r\nSelect an AI model.\r\n\r\nUser can choose a model by name or index from the accounts available.\r\n\r\n### /counters\r\n\r\nList the internal application counters.\r\n\r\n### /tag\r\n\r\nDescribe all tags in use.\r\n\r\nDisplays tag name, count of shares tagged and description.\r\n\r\n### /account\r\n\r\nDisplay current account information.\r\n\r\n### /save [name]\r\n\r\nSave the current conversation history. \r\n\r\nCreates a snapshot file of the conversation.\r\n\r\nThe default name is currently .roa-save-HEX32_TIME.json\r\n\r\n### /load\r\n\r\nLoad a saved conversation history snapshot.\r\n\r\nUser can specify a save index or file name to restore previous chats.\r\n\r\n\r\n### /time\r\n\r\nDisplay the current system time. \r\n\r\nHelps user verify system status.\r\n\r\n### /help\r\n\r\nIf you are reading this file, it may be due to the use of this command.\r\n\r\nIf you still need help visit the project page.\r\n\n{\"path\":\"C:/nitrologic/foundry/release/LICENSE.txt\",\"length\":1753,\"type\":\"text/plain; charset=UTF-8\"}\nMIT License\r\n\r\nCopyright (c) 2025 Simon Armstrong\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is                                            \r\nfurnished to do so, subject to the following conditions:                                                         \r\n                                                                                                                 \r\nThe above copyright notice and this permission notice shall be included in all                                   \r\ncopies or substantial portions of the Software.                                                                  \r\n                                                                                                                 \r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                       \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                         \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                                      \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                           \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                                    \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE                                    \r\nSOFTWARE. \n{\"path\":\"C:/nitrologic/foundry/release/welcome.txt\",\"length\":481,\"type\":\"text/plain; charset=UTF-8\"}\npreceed with caution\r\n\r\n  o---/\\     /---o     \\---/     /---/\\     o---/\\     \\---o     /---/\\ \r\n  |    \\/   /    |     |    /   /    \\/    |    \\/   /    |     |    \\/ \r\n#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #\r\n\r\n\tWELCOME TO FOUNDRY\r\n\r\n\tA COMMAND LINE TOOL FOR CHATTING AND SHARING FILES\r\n\r\n\tTHE MAGIC WORD IS HAPUKA\r\n\r\n\tTHIS FILE IS PART OF THE ROHA CLIENT DISTRIBUTION\r\n\r\n#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #\r\n\n{\"path\":\"C:/nitrologic/foundry/release/forge/readme.txt\",\"length\":67,\"type\":\"text/plain; charset=UTF-8\"}\nlocal storage for shared files submitted for review by foundry rc1\n\n{\"path\":\"C:/nitrologic/foundry/release/isolation/readme.txt\",\"length\":103,\"type\":\"text/plain; charset=UTF-8\"}\na sandbox for foundry rc1 runs\r\n\r\nrun foundry run\r\n\r\nthis stuff is post rc1 - what is going on here?\r\n \n{\"path\":\"C:/nitrologic/foundry/release/isolation/test.js\",\"length\":180,\"type\":\"application/javascript; charset=UTF-8\"}\n\r\nfunction hexDate(){\r\n    let s=Date.now()/1e3|0;\r\n    return s.toString(16);\r\n}\r\n\r\nconsole.log(\"radio   live transmission\");\r\n\r\nconsole.log(hexDate());\r\nconsole.log(hexDate());\r\n\n{\"path\":\"C:/nitrologic/foundry/.gitignore\",\"length\":55,\"type\":\"application/octet-stream\",\"mimeType\":\"application/octet-stream\"}\nFile content: MIME=application/octet-stream, Base64=Zm91bmRyeS5sb2cKZm91bmRyeS5qc29uCnNhdmVzCnJlbGVhc2UKcmMxL2ZvdW5kcnkuZXhlCg==\n{\"path\":\"C:/nitrologic/foundry/build.bat\",\"length\":88,\"type\":\"application/x-msdownload\"}\ndeno compile --allow-run --allow-env --allow-net --allow-read --allow-write foundry.js\r\n\ni would like to prepare a report on the nitrologic foundry client\n// foundry.js\r\n// a research client for evaluating models\r\n// (c)2025 Simon Armstrong\r\n\r\n// deno run --allow-run --allow-env --allow-net --allow-read --allow-write roha.js\r\n\r\nimport { contentType } from \"https://deno.land/std@0.224.0/media_types/mod.ts\";\r\nimport { resolve } from \"https://deno.land/std/path/mod.ts\";\r\nimport OpenAI from \"https://deno.land/x/openai@v4.67.2/mod.ts\";\r\n\r\nconst foundryVersion = \"rc1\";\r\nconst rohaTitle=\"foundry \"+foundryVersion;\r\nconst rohaMihi=\"I am testing foundry client. You are a helpful assistant.\";\r\n\r\nconst slowMillis = 20;\r\n\r\nconst decoder = new TextDecoder(\"utf-8\");\r\nconst encoder = new TextEncoder();\r\n\r\nconst terminalColumns=120;\r\n\r\nconst flagNames={\r\n\tcommitonstart : \"commit shared files on start\",\r\n\ttools : \"enable model tool interface\",\r\n\tansi : \"markdown ANSI rendering\",\r\n\tslow : \"output at reading speed\",\r\n\tverbose : \"emit debug information\",\r\n\tbroken : \"ansi background blocks\",\r\n\tlogging : \"log all output to file\",\r\n\tresetcounters : \"factory reset when reset\",\r\n\treturntopush : \"hit return to /push - it is under test\"\r\n};\r\n\r\nconst emptyRoha={\r\n\tconfig:{\r\n\t\tcommitonstart:true,\r\n\t\tansi:true,\r\n\t\tslow:false,\r\n\t\tverbose:false,\r\n\t\tbroken:false,\r\n\t\tlogging:false,\r\n\t\tresetcounters:false,\r\n\t\treturntopush:false\r\n\t},\r\n\ttags:{},\r\n\tmodels:{},\r\n\tband:{},\r\n\tsharedFiles:[],\r\n\tsaves:[],\r\n\tcounters:{}\r\n};\r\n\r\nfunction addBand(){\r\n\tlet id=\"member\"+increment(\"members\");\r\n\troha.band[id]={};\r\n}\r\n\r\nfunction listBand(){\r\n\tlet band=[];\r\n\tfor(let id in roha.band){\r\n\t\tlet member=roha.band[id];\r\n\t\tband.push(member);\r\n\t}\r\n\tband.push(\"add\");\r\n\tfor(let i=0;i<band.length;i++){\r\n\t\techo(i,band[i]);\r\n\t}\r\n\tmemberList=band;\r\n}\r\n\r\nfunction annotateTag(name,description){\r\n\tif(!name){\r\n\t\tthrow(\"null name\");\r\n\t}\r\n\tif(!(name in roha.tags)) {\r\n\t\troha.tags[name]={};\r\n//\t\tthrow(\"tag not found \"+name);\r\n\t}\r\n\troha.tags[name].description=description;\r\n}\r\n\r\nfunction annotateShare(name,description){\r\n\tlet index=roha.sharedFiles.findIndex(item => item.id === name);\r\n\tif(index==-1) throw(\"share id not found\");\r\n\troha.sharedFiles[index].description=description;\r\n\techo(\"file share description annotated\");\r\n}\r\n\r\nfunction increment(key){\r\n\tlet i=0;\r\n\tif(key in roha.counters){\r\n\t\ti=roha.counters[key]+1;\r\n\t}\r\n\troha.counters[key]=i;\r\n\treturn i\r\n}\r\n\r\nvar tagList=[];\r\nvar modelList=[];\r\nvar shareList=[]; //typically biggest to smallest\r\nvar memberList=[];\r\n\r\nconst emptyModel={\r\n\tname:\"empty\",account:\"\",hidden:false,prompts:0,completion:0\r\n}\r\n\r\nconst emptyTag={\r\n}\r\n\r\n// const emptyShare={path,size,modified,hash,tag,id}\r\n\r\nlet roha=emptyRoha;\r\nlet rohaCalls=0;\r\nlet listCommand=\"\";\r\nlet rohaShares=[];\r\nlet currentDir = Deno.cwd();\r\nvar rohaHistory;\r\n\r\nfunction resetHistory(){\r\n\trohaHistory = [{role:\"system\",content:rohaMihi}];\r\n}\r\n\r\nfunction listHistory(){\r\n\tlet history=rohaHistory;\r\n\tfor(let i=0;i<history.length;i++){\r\n\t\tlet item=history[i];\r\n\t\tlet content=readable(item.content).substring(0,90)\r\n\t\techo(i,item.role,item.name||\"foundry\",\"-\",content);\r\n\t}\r\n\tif(roha.config.broken){\r\n\t\tlet flat=squashMessages(rohaHistory);\r\n\t\tfor(let i=0;i<flat.length;i++){\r\n\t\t\tlet item=flat[i];\r\n\t\t\tlet content=readable(item.content).substring(0,90);\r\n\t\t\techo(\"flat\",i,item.role,item.name||\"broken\",content);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction rohaPush(content,name=\"foundry\"){\r\n\trohaHistory.push({role:\"user\",name,content});\r\n}\r\n\r\nresetHistory();\r\n\r\n// roaTools\r\n\r\nconst rohaTools = [{\r\n\ttype: \"function\",\r\n\tfunction:{\r\n\t\tname: \"read_time\",\r\n\t\tdescription: \"Returns current time in UTC\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {},\r\n\t\t\trequired: []\r\n\t\t}\r\n\t}\r\n},{\r\n\ttype: \"function\",\r\n\tfunction:{\r\n\t\tname: \"submit_file\",\r\n\t\tdescription: \"Submit a file for review\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {\r\n\t\t\t\tcontentType:{type:\"string\"},\r\n\t\t\t\tcontent:{type:\"string\"}\r\n\t\t\t},\r\n\t\t\trequired: [\"contentType\",\"content\"]\r\n\t\t}\r\n\t}\r\n},{\r\n\ttype: \"function\",\r\n\tfunction: {\r\n\t\tname: \"annotate_foundry\",\r\n\t\tdescription: \"Set description of any object\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {\r\n\t\t\t\tname: { type: \"string\" },\r\n\t\t\t\ttype: { type:\"string\" },\r\n\t\t\t\tdescription: { type: \"string\" }\r\n\t\t\t},\r\n\t\t\trequired: [\"name\",\"type\",\"description\"]\r\n\t\t}\r\n\t}\r\n}];\r\n\r\nasync function sleep(ms) {\r\n\tawait new Promise(function(resolve) {setTimeout(resolve, ms);});\r\n}\r\n\r\nfunction measure(o){\r\n\tlet total=JSON.stringify(o).length;\r\n\treturn total;\r\n}\r\n\r\nlet outputBuffer = [];\r\nlet printBuffer = [];\r\n\r\nfunction print(){\r\n\tlet args=arguments.length?Array.from(arguments):[];\r\n\tlet lines=args.join(\" \").split(\"\\n\");\r\n\tfor(let line of lines){\r\n\t\tprintBuffer.push(line.trimEnd());\r\n\t}\r\n}\r\n\r\nfunction echo(){\r\n\tlet args=arguments.length?Array.from(arguments):[];\r\n\tlet lines=args.join(\" \").split(\"\\n\");\r\n\tfor(let line of lines){\r\n\t\toutputBuffer.push(line.trimEnd());\r\n\t}\r\n}\r\n\r\nfunction stripAnsi(text) {\r\n\treturn text.replace(/\\x1B\\[\\d+(;\\d+)*[mK]/g, '');\r\n}\r\n\r\nasync function log(lines,id){\r\n\tif(roha.config.logging){\r\n\t\tconst time = new Date().toISOString();\r\n\t\tlet list=[];\r\n\t\tfor(let line of lines.split(\"\\n\")){\r\n\t\t\tline=stripAnsi(line);\r\n\t\t\tline=time+\" [\"+id+\"] \"+line+\"\\n\";\r\n\t\t\tlist.push(line);\r\n\t\t}\r\n\t\tawait Deno.writeTextFile(\"foundry.log\",list.join(),{append:true});\r\n\t}\r\n}\r\n\r\nasync function flush() {\r\n\tconst delay = roha.config.slow ? slowMillis : 0;\r\n\tfor (const line of printBuffer) {\r\n\t\tconsole.log(line);\r\n\t\tlog(line,\"model\");\r\n\t}\r\n\tprintBuffer=[];\r\n\tfor (const line of outputBuffer) {\r\n\t\tconsole.log(line);\r\n\t\tlog(line,\"stdout\");\r\n\t\tawait sleep(delay);\r\n\t}\r\n\toutputBuffer=[];\r\n}\r\n\r\nfunction wordWrap(text,cols=terminalColumns){\r\n\tvar result=[];\r\n\tvar pos=0;\r\n\twhile(pos<text.length){\r\n\t\tlet line=text.substring(pos,pos+cols);\r\n\t\tlet n=line.length;\r\n\t\tif(n==cols){\r\n\t\t\tvar i=line.lastIndexOf(\" \",n);\r\n\t\t\tif(i>0){\r\n\t\t\t\tline=line.substring(0,i);\r\n\t\t\t\tn=i+1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tresult.push(line);\r\n\t\tpos+=n;\r\n\t}\r\n\treturn result.join(\"\\n\");\r\n}\r\n\r\n// main roha application starts here\r\n\r\nconst MaxFileSize=65536;\r\n\r\nconst appDir = Deno.cwd();\r\nconst rohaPath = resolve(appDir,\"foundry.json\");\r\nconst accountsPath = resolve(appDir,\"accounts.json\");\r\nconst forgePath=resolve(appDir,\"forge\");\r\n\r\nconst modelAccounts = JSON.parse(await Deno.readTextFile(accountsPath));\r\n\r\nasync function pathExists(path) {\r\n\ttry {\r\n\t\tconst stat = await Deno.stat(path);\r\n\t\tif (!stat.isFile) return false;\r\n\t\treturn true;\r\n\t} catch (error) {\r\n\t\tif (error instanceof Deno.errors.NotFound) return false;\r\n\t\tif (error instanceof Deno.errors.PermissionDenied) return false;\r\n\t\tthrow error;\r\n\t}\r\n}\r\n\r\nconst fileExists = await pathExists(rohaPath);\r\nif (!fileExists) {\r\n\tawait Deno.writeTextFile(rohaPath, JSON.stringify(emptyRoha));\r\n\techo(\"Created new\",rohaPath);\r\n}\r\n\r\nconst rohaAccount={};\r\nfor(let account in modelAccounts){\r\n\tlet endpoint = await connectAccount(account);\r\n\tif(endpoint) rohaAccount[account]=endpoint;\r\n}\r\n\r\nfunction stringify(value, seen = new WeakSet(), keyName = \"\") {\r\n\tif (typeof value === \"string\") return value;\r\n\tif (value === null || typeof value !== \"object\") return String(value);\r\n\tif (typeof value === \"function\") return \"[function]\";\r\n\tif (seen.has(value)) return keyName ? `[circular (${keyName})]` :\"[circular]\";\r\n\tseen.add(value);\r\n\tif (Array.isArray(value)) {\r\n\t\tconst items = value.map((item, index) => stringify(item, seen,\r\n\t\tString(index)));\r\n\t\treturn `[${items.join(\",\\n\")}]`;\r\n\t}\r\n\tconst entries = Object.entries(value).map(([key, val]) => `${key}: ${stringify(val, seen, key)}`);\r\n\treturn `{${entries.join(\",\\n\")}}`;\r\n}\r\n\r\nasync function connectAccount(account) {\r\n\tlet verbose=false;//roha.config.verbose;\r\n\techo(\"Connecting to account:\", account);\r\n\tconst config = modelAccounts[account];\r\n\tif (!config) return null;\r\n\ttry{\r\n\t\tconst apiKey = Deno.env.get(config.env);\r\n\t\tconst endpoint = new OpenAI({ apiKey, baseURL: config.url });\r\n\t\tif(verbose){\r\n\t\t\tfor(const [key, value] of Object.entries(endpoint)){\r\n\t\t\t\tlet content=stringify(value);\r\n\t\t\t\techo(\"endpoint:\"+key+\":\"+content);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst models = await endpoint.models.list();\r\n\t\tconst list=[];\r\n\t\tfor (const model of models.data) {\r\n\t\t\tlet name=model.id+\"@\"+account;\r\n\t\t\tlist.push(name);\r\n\t\t\tif(verbose) echo(\"model - \",JSON.stringify(model,null,\"\\t\"));\r\n\t\t}\r\n\t\tlist.sort();\r\n\t\tmodelList=modelList.concat(list);\r\n\t\treturn endpoint;\r\n\t}catch(error){\r\n\t// Error: 429 \"Your team ac0a3c9a-0e58-4e3c-badd-be853c027a7f has either used all available credits or \r\n\t// reached its monthly spending limit. To continue making API requests, please purchase more credits or \r\n\t// raise your spending limit.\"\r\n\t\techo(error);\r\n\t}\r\n\treturn null;\r\n}\r\n\r\nasync function resetModel(name){\r\n\tgrokModel=name;\r\n\tgrokFunctions=true;\r\n\trohaHistory.push({role:\"system\",content:\"Model changed to \"+name+\".\"});\r\n\techo(\"with model\",name,grokFunctions)\r\n\tawait writeRoha();\r\n}\r\n\r\nfunction dropShares(){\r\n\tfor(let item of rohaHistory){\r\n\t\tif(item && item.role===\"user\" && item.user===\"forge\"){\r\n\t\t\titem.user=\"drop\";\r\n\t\t\titem.content=\"dropped path \"+(item.path||\"\");\t\t\t\r\n\t\t}\r\n\t}\r\n\trohaShares=[];\r\n\techo(\"all shares dropped\");\r\n}\r\n\r\nfunction listShare(){\r\n\tconst list=[];\r\n\tlet count=0;\r\n\tlet sorted = roha.sharedFiles.slice();\r\n\tsorted.sort((a, b) => b.size - a.size);\r\n\tfor (const share of sorted) {\r\n\t\tlet shared=(rohaShares.includes(share.path))?\"*\":\"\";\r\n\t\tlet tags=\"[\"+share.tag+\"]\";\r\n\t\tlet info=(share.description)?share.description:\"\";\r\n\t\techo((count++),share.path,share.size,shared,tags,info);\r\n\t\tlist.push(share.id);\r\n\t}\r\n\tshareList=list;\r\n}\r\n\r\nfunction listSaves(){\r\n\tlet saves=roha.saves||[];\r\n\tfor(let i=0;i<saves.length;i++){\r\n\t\techo(i,saves[i]);\r\n\t}\r\n}\r\n\r\nasync function saveHistory(name) {\r\n\ttry {\r\n\t\tlet timestamp=Math.floor(Date.now()/1000).toString(16);\r\n\t\tlet filename=(name||\"transmission-\"+timestamp)+\".json\";\r\n\t\tlet filePath = resolve(forgePath,filename);\r\n\t\tlet line=\"Saved session \"+filename+\".\";\r\n\t\trohaHistory.push({role:\"system\",content:line});\r\n\t\tawait Deno.writeTextFile(filePath,JSON.stringify(rohaHistory,null,\"\\t\"));\r\n\t\techo(line);\r\n\t\troha.saves.push(filename);\r\n\t\tawait writeRoha();\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error saving history:\", error.message);\r\n\t}\r\n}\r\n\r\nasync function loadHistory(filename){\r\n\tvar history;\r\n\ttry {\r\n\t\tconst fileContent = await Deno.readTextFile(filename);\r\n\t\thistory = JSON.parse(fileContent);\r\n\t\techo(\"History restored from \"+filename);\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error restoring history:\", error.message);\r\n\t\techo(\"console error\");\r\n\t\thistory=[{role:\"system\",content: \"You are a helpful assistant.\"}];\r\n\t}\r\n\treturn history;\r\n}\r\n\r\nconst ansiBackgrounds = [\r\n\t{ name: \"dark0\", code: \"\\x1b[48;5;232m\" }, // #1c2526\r\n\t{ name: \"dark1\", code: \"\\x1b[48;5;233m\" }, // #2e3436\r\n\t{ name: \"dark2\", code: \"\\x1b[48;5;234m\" }, // #3d4446\r\n\t{ name: \"dark3\", code: \"\\x1b[48;5;235m\" }, // #4e5456\r\n\t{ name: \"charcoal\", code: \"\\x1b[48;5;236m\" }, // #606668\r\n\t{ name: \"darkBlue\", code: \"\\x1b[48;5;17m\" }, // #00005f\r\n\t{ name: \"darkGreen\", code: \"\\x1b[48;5;23m\" }, // #003f3f\r\n\t{ name: \"darkMutedPurple\", code: \"\\x1b[48;5;54m\" }, // #5f00af\r\n\t{ name: \"veryDarkBlue\", code: \"\\x1b[48;5;18m\" }, // #000087\r\n\t{ name: \"darkCharcoal\", code: \"\\x1b[48;5;239m\" }, // #4e4e4e\r\n\t{ name: \"mutedNavy\", code: \"\\x1b[48;5;19m\" }, // #0000af\r\n\t{ name: \"deepGray\", code: \"\\x1b[48;5;240m\" } // #585858\r\n];\r\n\r\nconst ansiMoveToEnd = \"\\x1b[999B\";\r\nconst ansiSaveCursor = \"\\x1b[s\";\r\nconst ansiRestoreCursor = \"\\x1b[u\";\r\n\r\nconst ansiReplyBlock = ansiBackgrounds[0].code;\r\nconst ansiCodeBlock = ansiBackgrounds[6].code;\r\n\r\nconst rohaPrompt=\">\";\r\n\r\nconst ansiItalics = \"\\x1b[3m\";\r\nconst ansiReset = \"\\x1b[0m\";\r\nconst ansiPurple = \"\\x1b[1;35m\";\r\n\r\nfunction mdToAnsi(md) {\r\n\tlet broken=roha.config.broken;\r\n\tconst lines = md.split(\"\\n\");\r\n\tlet inCode = false;\r\n\tconst result = broken?[ansiReplyBlock]:[];\r\n\tfor (let line of lines) {\r\n\t\tline=line.trimEnd();\r\n\t\tlet trim=line.trim();\r\n\t\tif (trim.startsWith(\"```\")) {\r\n\t\t\tinCode = !inCode;\r\n\t\t\tif(inCode){\r\n\t\t\t\tresult.push(ansiCodeBlock);\r\n\t\t\t\tlet codeType=trim.substring(3);\r\n\t\t\t\techo(\"inCode \"+codeType);\r\n\t\t\t}else{\r\n\t\t\t\tif (broken) result.push(ansiReplyBlock);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif (!inCode) {\r\n\t\t\t\t// headershow\r\n\t\t\t\tconst header = line.match(/^#+/);\r\n\t\t\t\tif (header) {\r\n\t\t\t\t\tconst level = header[0].length;\r\n\t\t\t\t\tline = line.substring(level).trim();\r\n\t\t\t\t\tline = ansiPurple + line + ansiReset;\r\n\t\t\t\t}\r\n\t\t\t\t// bullets\r\n\t\t\t\tif (line.startsWith('-') || line.startsWith('*') || line.startsWith('+')) {\r\n\t\t\t\t\tline = '• ' + line.substring(1).trim();\r\n\t\t\t\t}\r\n\t\t\t\t// bold\r\n\t\t\t\tif (line.includes(\"**\")) {\r\n\t\t\t\t\tline = line.replace(/\\*\\*(.*?)\\*\\*/g, \"\\x1b[1m$1\\x1b[0m\");\r\n\t\t\t\t}\r\n\t\t\t\t// italic\r\n\t\t\t\tline = line.replace(/\\*(.*?)\\*/g, \"\\x1b[3m$1\\x1b[0m\");\r\n\t\t\t\tline = line.replace(/_(.*?)_/g, \"\\x1b[3m$1\\x1b[0m\");\r\n\t\t\t\t// wordwrap\r\n\t\t\t\tline=wordWrap(line,terminalColumns);\r\n\t\t\t}\r\n\t\t\tresult.push(line.trimEnd());\r\n\t\t}\r\n\t}\r\n\tresult.push(ansiReset);\r\n\treturn result.join(\"\\n\");\r\n}\r\n\r\nasync function hashFile(filePath) {\r\n\tconst fileContent = await Deno.readFile(filePath);\r\n\tconst hashBuffer = await crypto.subtle.digest(\"SHA-256\", fileContent);\r\n\tconst hashArray = new Uint8Array(hashBuffer);\r\n\treturn Array.from(hashArray).map(byte => byte.toString(16).padStart(2, '0')).join('');\r\n}\r\n\r\nasync function readRoha(){\r\n\ttry {\r\n\t\tconst fileContent = await Deno.readTextFile(rohaPath);\r\n\t\troha = JSON.parse(fileContent);\r\n\t\tif(!roha.saves) roha.saves=[];\r\n\t\tif(!roha.counters) roha.counters={};\r\n\t\tif(!roha.band) roha.band={};\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error reading or parsing\",rohaPath,error);\r\n\t\troha=emptyRoha;\r\n\t}\r\n}\r\n\r\nasync function writeRoha(){\r\n\ttry {\r\n\t\troha.model=grokModel;\r\n\t\tawait Deno.writeTextFile(rohaPath, JSON.stringify(roha, null, \"\\t\"));\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error writing\",rohaPath,error);\r\n\t}\r\n}\r\n\r\nasync function resetRoha(){\r\n\trohaShares = [];\r\n\troha.sharedFiles=[];\r\n\troha.tags={};\r\n\tif(roha.config.resetcounters) roha.counters={};\r\n\tincrement(\"resets\");\r\n\tawait writeRoha();\r\n\tresetHistory();\r\n\techo(\"resetRoha\",\"All shares and history reset.\");\r\n}\r\n\r\nfunction resolvePath(dir,filename){\r\n\tlet path=resolve(dir,filename);\r\n\tpath = path.replace(/\\\\/g, \"/\");\r\n\treturn path;\r\n}\r\n\r\n// a raw mode prompt replacement\r\n\r\n// arrow navigation and tab completion incoming\r\n\r\nconst reader = Deno.stdin.readable.getReader();\r\nconst writer = Deno.stdout.writable.getWriter();\r\n\r\nasync function prompt2(message) {\r\n\tif (message) {\r\n\t\tawait writer.write(encoder.encode(message));\r\n\t\tawait writer.ready;\r\n\t}\r\n\tDeno.stdin.setRaw(true);\r\n\tlet inputBuffer = new Uint8Array(0);\r\n\ttry {\r\n\t\twhile (true) {\r\n\t\t\tconst { value, done } = await reader.read();\r\n\t\t\tif (done || !value) break;\r\n\t\t\tfor (const byte of value) {\r\n\t\t\t\tif (byte === 0x7F || byte === 0x08) { // Backspace\r\n\t\t\t\t\tif (inputBuffer.length > 0) {\r\n\t\t\t\t\t\tinputBuffer = inputBuffer.slice(0, -1);\r\n\t\t\t\t\t\tawait writer.write(new Uint8Array([0x08, 0x20, 0x08])); // Erase last char\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (byte === 0x1b) { // Escape sequence\r\n\t\t\t\t\tif(value.length==1){\r\n\t\t\t\t\t\tDeno.exit(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(value.length==3){\r\n\t\t\t\t\t\tif(value[1]==0xf4 && value[2]==0x50){\r\n\t\t\t\t\t\t\techo(\"F1\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (byte === 0x0A || byte === 0x0D) { // Enter key\r\n\t\t\t\t\tawait writer.write(encoder.encode(\"\\r\\n\"));\r\n\t\t\t\t\tlet line = decoder.decode(inputBuffer);\r\n\t\t\t\t\tline=line.trim();\r\n\t\t\t\t\tlog(line,\"stdin\");\r\n\t\t\t\t\treturn line;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tawait writer.write(new Uint8Array([byte]));\r\n\t\t\t\t\tconst buf = new Uint8Array(inputBuffer.length + 1);\r\n\t\t\t\t\tbuf.set(inputBuffer);\r\n\t\t\t\t\tbuf[inputBuffer.length] = byte;\r\n\t\t\t\t\tinputBuffer = buf;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} finally {\r\n\t\tDeno.stdin.setRaw(false);\r\n\t}\r\n}\r\n\r\n// callers to addShare expected to await writeRoha after\r\n\r\nconst eventList=[];\r\n\r\nasync function watchPaths(paths,handler){\r\n\tconst watcher = Deno.watchFs(paths,{recursive:false});\r\n\tfor await (const event of watcher) {\r\n\t\teventList.push(event);\r\n\t}\r\n}\r\n\r\nasync function addShare(share){\r\n\tshare.id=\"share\"+increment(\"shares\");\r\n\troha.sharedFiles.push(share);\r\n\tif(share.tag) {\r\n\t\tawait setTag(share.tag,share.id);\r\n\t}\r\n}\r\n\r\nasync function shareDir(dir,tag) {\r\n\ttry {\r\n\t\tconst paths=[];\r\n\t\tconst files = await Deno.readDir(dir);\r\n\t\tfor await (const file of files) {\r\n\t\t\tif (file.isFile && !file.name.startsWith(\".\")) {\r\n\t\t\t\tpaths.push(resolvePath(dir, file.name));\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const path of paths) {\r\n//\t\t\techo(\"statting path:\"+path+\":\");\r\n\t\t\tconst info = await Deno.stat(path);\r\n\t\t\tlet size=info.size;\r\n\t\t\tlet modified=info.mtime.getTime();\r\n\t\t\tconst hash = await hashFile(path);\r\n\t\t\tawait addShare({path,size,modified,hash,tag})\r\n\t\t}\r\n\t\tawait writeRoha(); // TODO: check a dirty flag\r\n\t} catch (error) {\r\n\t\tconsole.error(\"### Error\"+error);\r\n\t}\r\n}\r\n\r\nfunction fileType(extension){\r\n\treturn contentType(extension) || 'application/octet-stream';\r\n}\r\n\r\nconst textExtensions = [\r\n\t\"js\", \"txt\", \"json\", \"md\",\r\n\t\"css\",\"html\", \"svg\",\r\n\t\"cpp\", \"c\", \"h\", \"cs\",\r\n\t\"sh\", \"bat\",\r\n\t\"log\",\"py\",\"csv\",\"xml\",\"ini\"\r\n];\r\n\r\nasync function shareFile(path,tag) {\r\n\tlet fileContent=null;\r\n\ttry {\r\n\t\tfileContent = await Deno.readFile(path);\r\n\t} catch (error) {\r\n\t\tconsole.error(\"shareFile path:\"+path+\" error:\", error);\r\n\t\treturn;\r\n\t}\r\n\tif(path.endsWith(\"rules.txt\")){\r\n\t\tlet lines=decoder.decode(fileContent).split(\"\\n\");\r\n\t\tfor(let line of lines ){\r\n\t\t\tif (line) rohaHistory.push({role:\"system\",content: line});\r\n\t\t}\r\n\t}else{\r\n\t\tconst length=fileContent.length;\r\n\t\tif(length>0 && length<MaxFileSize){\r\n\t\t\tconst extension = path.split('.').pop();\r\n\t\t\tconst type = fileType(extension);\r\n\t\t\tif (textExtensions.includes(extension)) {\r\n\t\t\t\tlet txt = decoder.decode(fileContent);\r\n\t\t\t\tif(txt.length){\r\n\t\t\t\t\tlet metadata=JSON.stringify({path,length,type,tag});\r\n\t\t\t\t\trohaPush(metadata);\r\n\t\t\t\t\trohaPush(txt,\"forge\");\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tconst base64Encoded = btoa(String.fromCharCode(...new Uint8Array(fileContent)));\r\n\t\t\t\tconst mimeType = fileType(extension);\r\n\t\t\t\tlet metadata=JSON.stringify({path,length,type,mimeType,tag});\r\n\t\t\t\trohaPush(metadata);\r\n\t\t\t\tlet binary=`File content: MIME=${mimeType}, Base64=${base64Encoded}`;\r\n\t\t\t\trohaPush(binary,\"forge\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n//\tif(roha.config.verbose)echo(\"roha shared file \" + path);\r\n\tif (!rohaShares.includes(path)) rohaShares.push(path);\r\n}\r\n\r\nasync function commitShares(tag) {\r\n\tlet dirty = false;\r\n\tconst validShares = [];\r\n\tconst removedPaths = [];\r\n\tfor (const share of roha.sharedFiles) {\r\n\t\tif (tag && share.tag !== tag) {\r\n\t\t\tvalidShares.push(share);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tconst info = await Deno.stat(share.path);\r\n\t\t\tconst modified = share.modified !== info.mtime.getTime();\r\n\t\t\tconst isShared = rohaShares.includes(share.path);\r\n\t\t\tif (modified || !isShared) {\r\n\t\t\t\tawait shareFile(share.path,tag);\r\n\t\t\t\tshare.modified = info.mtime.getTime();\r\n\t\t\t\tdirty = true;\r\n\t\t\t}\r\n\t\t\tvalidShares.push(share);\r\n\t\t} catch (error) {\r\n\t\t\tremovedPaths.push(share.path);\r\n\t\t\tdirty = true;\r\n\t\t}\r\n\t}\r\n\r\n\tif (removedPaths.length) {\r\n\t\troha.sharedFiles = validShares;\r\n\t\tawait writeRoha();\r\n\t\techo(`Invalid shares detected:\\n${removedPaths.join('\\n')}`);\r\n\t}\r\n\r\n\tif (dirty&&tag) {\r\n\t\tlet invoke=\"feel free to call annotate_foundry to tag \"+tag;\r\n\t\trohaHistory.push({role:\"system\",content:invoke});\r\n\t}\r\n\r\n\treturn dirty;\r\n}\r\n\r\nasync function setTag(name,note){\r\n\tlet tags=roha.tags||{};\r\n\tlet tag=(tags[name])?tags[name]:{name,info:[]};\r\n\ttag.info.push(note);\r\n\ttags[name]=tag;\r\n\troha.tags=tags;\r\n\tawait writeRoha();\r\n//\tlet invoke=`New tag \"${name}\" added. Describe all shares with this tag.`;\r\n//\trohaHistory.push({role:\"system\",content:invoke});\r\n}\r\nfunction listCounters(){\r\n\tlet keys=Object.keys(roha.counters);\r\n\tlet i=0;\r\n\tfor(let key of keys){\r\n\t\tlet count=roha.counters[key];\r\n\t\techo((i++),key,count);\r\n\t}\r\n}\r\nfunction listTags(){\r\n\tlet tags=roha.tags||{};\r\n\tlet keys=Object.keys(tags);\r\n\tlet list=[];\r\n\tfor(let i=0;i<keys.length;i++){\r\n\t\tlet tag=tags[keys[i]];\r\n\t\tconst name=tag.name||\"?????\";\r\n\t\techo(i,name,\"(\"+tag.info.length+\")\");\r\n\t\tlet info=tag.description;\r\n\t\tif(info) echo(\"\",info);\r\n\t\tlist.push(name);\r\n\t}\r\n\ttagList=list;\r\n}\r\n\r\nfunction listAccounts(){\r\n\tlet list=[];\r\n\tfor(let key in modelAccounts){\r\n\t\tlet value=modelAccounts[key];\r\n\t\tlist.push(key);\r\n\t}\r\n\tfor(let i=0;i<list.length;i++){\r\n\t\techo(i,list[i]);\r\n\t}\r\n}\r\n\r\nasync function showHelp() {\r\n\ttry {\r\n\t\tconst md = await Deno.readTextFile(\"foundry.md\");\r\n\t\techo(mdToAnsi(md));\r\n\t} catch (e) {\r\n\t\techo(\"Error loading help file: \" + e.message);\r\n\t}\r\n}\r\n\r\nfunction readable(text){\r\n\ttext=text.replace(/\\s+/g, \" \");\r\n\treturn text;\r\n}\r\n\r\nasync function callCommand(command) {\r\n\tlet dirty=false;\r\n\tlet words = command.split(\" \",2);\r\n\ttry {\r\n\t\tswitch (words[0]) {\r\n\t\t\tcase \"band\":\r\n\t\t\t\tlistBand();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"counter\":\r\n\t\t\t\tlistCounters();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"tag\":\r\n\t\t\t\tawait listTags();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"account\":\r\n\t\t\t\tawait listAccounts();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"help\":\r\n\t\t\t\tawait showHelp();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"config\":\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\tlet flag=words[1].trim();\r\n\t\t\t\t\tif(flag.length && !isNaN(flag)){\r\n\t\t\t\t\t\tflag=Object.keys(flagNames)[flag|0];\r\n\t\t\t\t\t\techo(\"flag\",flag);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(flag in flagNames){\r\n\t\t\t\t\t\troha.config[flag]=!roha.config[flag];\r\n\t\t\t\t\t\techo(flag+\" - \"+flagNames[flag]+\" is \"+(roha.config[flag]?\"true\":\"false\"));\r\n\t\t\t\t\t\tawait writeRoha();\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlet count=0;\r\n\t\t\t\t\tfor(let flag in flagNames){\r\n\t\t\t\t\t\techo((count++),flag,\":\",flagNames[flag],\":\",(roha.config[flag]?\"true\":\"false\"))\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistCommand=\"config\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"time\":\r\n\t\t\t\techo(\"Current time:\", new Date().toString());\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"history\":\r\n\t\t\t\tlistHistory();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"load\":\r\n\t\t\t\tlet save=words[1];\r\n\t\t\t\tif(save){\r\n\t\t\t\t\tif(save.length && !isNaN(save)) save=roha.saves[save|0];\r\n\t\t\t\t\tif(roha.saves.includes(save)){\r\n\t\t\t\t\t\tlet history=await loadHistory(save);\r\n\t\t\t\t\t\trohaHistory=history;\r\n\t\t\t\t\t\techo(\"a new history is set\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlistSaves();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"save\":\r\n\t\t\t\tlet savename=words.slice(1).join(\" \");\r\n\t\t\t\tsaveHistory(savename);\r\n\t\t\t\tawait writeRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"model\":\r\n\t\t\t\tlet name=words[1];\r\n\t\t\t\tif(name){\r\n\t\t\t\t\tif(name.length&&!isNaN(name)) name=modelList[name|0];\r\n\t\t\t\t\tif(modelList.includes(name)){\r\n\t\t\t\t\t\tresetModel(name);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor(let i=0;i<modelList.length;i++){\r\n\t\t\t\t\t\tlet name=modelList[i];\r\n\t\t\t\t\t\tlet attr=(name==grokModel)?\"*\":\"\";\r\n\t\t\t\t\t\techo(i,name,attr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistCommand=\"model\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"reset\":\r\n\t\t\t\tawait resetRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"cd\":\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\tconst newDir = words[1];\r\n\t\t\t\t\tif (newDir.length) Deno.chdir(newDir);\r\n\t\t\t\t}\r\n\t\t\t\tcurrentDir = Deno.cwd();\r\n\t\t\t\techo(\"Changed directory to\", currentDir);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"dir\":\r\n\t\t\t\tconst files = Deno.readDirSync(currentDir);\r\n\t\t\t\techo(\"Contents of\", currentDir + \":\");\r\n\t\t\t\tfor (const file of files) {\r\n\t\t\t\t\tlet name=(file.isDirectory)?\"[\"+file.name+\"]\":file.name;\r\n\t\t\t\t\techo(name);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"drop\":\r\n\t\t\t\tdropShares();\r\n\t\t\t\tawait writeRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"share\":\r\n\t\t\t\tif (words.length==1){\r\n\t\t\t\t\tlistShare();\r\n\t\t\t\t}else{\r\n\t\t\t\t\tconst filename = words.slice(1).join(\" \");\r\n\t\t\t\t\tconst path = resolvePath(Deno.cwd(), filename);\r\n\t\t\t\t\tconst info = await Deno.stat(path);\r\n\t\t\t\t\tconst tag = await prompt2(\"Enter tag name (optional):\");\r\n\t\t\t\t\tif(info.isDirectory){\r\n\t\t\t\t\t\techo(\"Share directory path:\",path);\r\n\t\t\t\t\t\tawait shareDir(path,tag);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlet size=info.size;\r\n\t\t\t\t\t\tlet modified=info.mtime.getTime();\r\n\t\t\t\t\t\techo(\"Share file path:\",path,\" size:\",info.size,\" \");\r\n\t\t\t\t\t\tconst hash = await hashFile(path);\r\n\t\t\t\t\t\techo(\"hash:\",hash);\r\n\t\t\t\t\t\tawait addShare({path,size,modified,hash,tag});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tawait writeRoha();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"push\":\r\n\t\t\tcase \"commit\":\r\n\t\t\t\tlet tag=\"\";\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\ttag=words[1];\r\n\t\t\t\t}\r\n\t\t\t\tdirty=await commitShares(tag);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\techo(\"Command not recognised\");\r\n\t\t\t\treturn false; // Command not recognized\r\n\t\t}\r\n\t} catch (error) {\r\n\t\techo(\"Error processing command:\", error.message);\r\n\t}\r\n\tincrement(\"calls\");\r\n\treturn dirty;\r\n}\r\n\r\necho(rohaTitle,\"running from \"+rohaPath);\r\nawait readRoha();\r\n\r\nlet grokModel = roha.model||\"deepseek-chat@deepseek\";\r\nlet grokFunctions=true;\r\nlet grokUsage = 0;\r\n\r\necho(\"present [\",grokModel,\"]\");\r\necho(\"shares count:\",roha.sharedFiles.length)\r\necho(\"use /help for latest and exit to quit\");\r\necho(\"\");\r\n\r\nlet sessions=increment(\"sessions\");\r\nif(sessions==0){\r\n\tlet welcome=await Deno.readTextFile(\"welcome.txt\");\r\n\techo(welcome);\r\n\tawait writeRoha();\r\n}\r\n\r\nif(roha.config){\r\n\tif(roha.config.commitonstart) await commitShares();\r\n}else{\r\n\troha.config={};\r\n}\r\n\r\nfunction extensionForType(contentType) {\r\n\tif (contentType.includes(\"markdown\")) return \".md\";\r\n\tif (contentType.includes(\"json\")) return \".json\";\r\n\tif (contentType.includes(\"javascript\")) return \".js\";\r\n\treturn \".txt\";\r\n}\r\n\r\nasync function onCall(toolCall) {\r\n\tlet verbose=roha.config.verbose;\r\n\tswitch(toolCall.function.name) {\r\n\t\tcase \"read_time\":\r\n\t\t\treturn {time: new Date().toISOString()};\r\n\t\tcase \"submit_file\":\r\n\t\t\tlet args=JSON.parse(toolCall.function.arguments);\r\n\t\t\techo(args.contentType);\r\n\t\t\tif (verbose) echo(args.content);\r\n\t\t\tlet timestamp=Math.floor(Date.now()/1000).toString(16);\r\n\t\t\tlet extension=extensionForType(args.contentType)\r\n\t\t\tlet name= \"submission-\"+timestamp+extension;\r\n\t\t\tlet filePath = resolve(forgePath,name);\r\n\t\t\tawait Deno.writeTextFile(filePath, args.content);\r\n\t\t\techo(\"File saved to:\", filePath);\r\n\t\t\treturn { success: true, path: filePath };\r\n\t\tcase \"annotate_foundry\":\r\n\t\t\ttry {\r\n\t\t\t\tconst { name, type, description } = JSON.parse(toolCall.function.arguments || \"{}\");\r\n\t\t\t\tswitch(type){\r\n\t\t\t\t\tcase \"tag\":\r\n\t\t\t\t\t\tannotateTag(name,description);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"share\":\r\n\t\t\t\t\t\tannotateShare(name,description);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tawait writeRoha(); // Persist changes\r\n\t\t\t\treturn { success: true, updated: 1 };\r\n\t\t\t} catch (error) {\r\n\t\t\t\techo(\"annotate_foundry error:\",error);\r\n\t\t\t\treturn { success: false, updated: 0 };\r\n\t\t\t}\r\n\t}\r\n\tconsole.error(\"onCall error - call simon\");\r\n}\r\n\r\nfunction squashMessages(history) {\r\n\tif (history.length < 2) return history;\r\n\tconst squashed = [history[0]];\r\n\tlet system=[];\r\n\tlet other=[];\r\n\tfor(let item of history){\r\n\t\tif(item.role==\"system\") system.push(item); else other.push(item);\r\n\t}\r\n\tfor(let list of [system,other]){\r\n\t\tlet last=null;\r\n\t\tfor (let i = 0; i < list.length; i++) {\r\n\t\t\tconst current=list[i];\r\n\t\t\tif(last){\r\n\t\t\t\tlast.content += \"\\n\" + current.content;\r\n\t\t\t} else {\r\n\t\t\t\tsquashed.push(current);\r\n\t\t\t\tlast=current;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn squashed;\r\n}\r\n\r\nasync function isolateCode(path,cwd) {\r\n\ttry {\r\n\t\tconst readAllow = `--allow-read=${cwd}`;\r\n\t\tconst writeAllow = `--allow-write=${cwd}`;\r\n\t\tconst cmd = [\"deno\", \"run\", \"--no-remote\", readAllow, writeAllow, path];\r\n\t\tconst process = Deno.run({ cmd, stdout: \"piped\", stderr: \"piped\" });\r\n\t\tconst [stdout, stderr] = await Promise.all([process.output(), process.stderrOutput()]);\r\n\t\tconst status = await process.status();\r\n\t\tprocess.close();\r\n\t\treturn {\r\n\t\t\tsuccess: status.success,\r\n\t\t\toutput: new TextDecoder().decode(stdout),\r\n\t\t\terror: new TextDecoder().decode(stderr)\r\n\t\t};\r\n\t} catch (err) {\r\n\t\treturn { success: false, output: \"\", error: err.message };\r\n\t}\r\n}\r\n\r\nasync function runCode(){\r\n\tlet result = await isolateCode(\"isolation/test.js\", \"isolation\");\r\n\t//echo(\"RunCode Result:\", result.success ? \"Success\" : \"Failed\");\r\n\tif (result.output) echo(\"[isolation] \", result.output);\r\n\tif (result.error) echo(\"Error:\", result.error);\r\n\t// todo: add save on exit\r\n}\r\n\r\nasync function relay() {\r\n\tconst verbose=roha.config.verbose;\r\n\ttry {\r\n\t\tconst modelAccount=grokModel.split(\"@\");\r\n\t\tlet model=modelAccount[0];\r\n\t\tlet account=modelAccount[1];\r\n\t\tlet endpoint=rohaAccount[account];\r\n\t\tlet usetools=grokFunctions&&roha.config.tools;\r\n\t\tconst payload = usetools?{ model, messages:rohaHistory, tools: rohaTools }:{ model, messages:squashMessages(rohaHistory) };\r\n\t\tconst completion = await endpoint.chat.completions.create(payload);\r\n\t\tif (completion.model != model) {\r\n\t\t\techo(\"[relay model alert model:\" + completion.model + \" grokModel:\" + grokModel + \"]\");\r\n\t\t\tgrokModel=completion.model+\"@\"+account;\r\n\t\t}\r\n\t\tif (verbose) {\r\n\t\t\t// echo(\"relay completion:\" + JSON.stringify(completion, null, \"\\t\"));\r\n\t\t}\r\n\t\tlet system = completion.system_fingerprint;\r\n\t\tlet usage = completion.usage;\r\n\t\tlet size = measure(rohaHistory);\r\n\t\tgrokUsage += usage.prompt_tokens | 0 + usage.completion_tokens | 0;\r\n\t\tlet status = \"[model \" + grokModel + \" \" + usage.prompt_tokens + \" \" + usage.completion_tokens + \" \" + grokUsage + \" \" + size + \"]\";\r\n\t\techo(status);\r\n\t\tvar reply = \"<blank>\";\r\n\t\tfor (const choice of completion.choices) {\r\n\t\t\tlet calls = choice.message.tool_calls;\r\n\t\t\t// choice has index message{role,content,refusal,annotations} finish_reason\r\n\t\t\tif (calls) {\r\n\t\t\t\tincrement(\"calls\");\r\n\t\t\t\techo(\"relay calls in progress\");\r\n\t\t\t\t// Generate tool_calls with simple, unique IDs\r\n\t\t\t\tconst toolCalls = calls.map((tool, index) => ({\r\n\t\t\t\t\tid: `call_${rohaCalls++}`,\r\n\t\t\t\t\ttype: \"function\",\r\n\t\t\t\t\tfunction: {\r\n\t\t\t\t\t\tname: tool.function.name,\r\n\t\t\t\t\t\targuments: tool.function.arguments || \"{}\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}));\r\n\t\t\t\t// Add assistant message with tool_calls\r\n\t\t\t\tlet content=choice.message.content || \"\";\r\n\t\t\t\trohaHistory.push({role:\"assistant\",content,tool_calls: toolCalls});\r\n\t\t\t\tif(verbose) echo(\"tooling \"+content);\r\n\t\t\t\t// Add tool responses\r\n\t\t\t\tfor (let i = 0; i < calls.length; i++) {\r\n\t\t\t\t\tconst tool = calls[i];\r\n\t\t\t\t\tconst result = await onCall(tool);\r\n\t\t\t\t\tif (result){\r\n\t\t\t\t\t\tlet content=JSON.stringify(result);\r\n\t\t\t\t\t\trohaHistory.push({\r\n\t\t\t\t\t\t\trole: \"tool\",\r\n\t\t\t\t\t\t\ttool_call_id: toolCalls[i].id,\r\n\t\t\t\t\t\t\tname: tool.function.name,\r\n\t\t\t\t\t\t\tcontent\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\techo(\"no oncall result\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn relay(); // Recursive call to process tool results\r\n\t\t\t}\r\n\t\t\treply = choice.message.content;\r\n\t\t\tif (roha.config && roha.config.ansi) {\r\n//\t\t\t\techo(ansiSaveCursor);\r\n\t\t\t\tprint(mdToAnsi(reply));\r\n//\t\t\t\techo(ansiRestoreCursor);\r\n\t\t\t} else {\r\n\t\t\t\tprint(wordWrap(reply));\r\n\t\t\t}\r\n\t\t}\r\n\t\trohaHistory.push({ role: \"assistant\", content: reply });\r\n\t} catch (error) {\r\n\t\tlet line=error.message || String(error);\r\n\t\t//Error during API call: Error: 400 \"This model's maximum prompt length is 131072 but the request contains 165547 tokens.\"\r\n\t\tif(line.includes(\"maximum prompt length\")){\r\n\t\t\techo(\"maximum prompt length exceeded, switch model or drop shares to continue\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconsole.error(\"Error during API call:\", error);\t\r\n\t\tif(grokFunctions){\r\n\t\t\techo(\"resetting grokFunctions\")\r\n\t\t\tgrokFunctions=false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nasync function chat() {\r\n\tdance:\r\n\twhile (true) {\r\n\t\tlet lines=[];\r\n//\t\techo(ansiMoveToEnd);\r\n\t\twhile (true) {\r\n\t\t\tawait flush();\r\n\t\t\tlet line=\"\";\r\n\t\t\tif(listCommand){\r\n\t\t\t\tline=await prompt2(\"#\");\r\n\t\t\t\tif(line.length && !isNaN(line)){\r\n\t\t\t\t\tlet index=line|0;\r\n\t\t\t\t\tawait callCommand(listCommand+\" \"+index);\r\n\t\t\t\t}\r\n\t\t\t\tlistCommand=\"\";\r\n\t\t\t}else{\r\n\t\t\t\tline=await prompt2(rohaPrompt);\r\n\t\t\t}\r\n\t\t\tif (line === '') {\r\n\t\t\t\tif(roha.config.returntopush && !lines.length) {\r\n\t\t\t\t\techo(\"auto pushing...\");\r\n\t\t\t\t\tawait callCommand(\"push\");\r\n\t\t\t\t\tawait relay();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (line === \"exit\") {\r\n\t\t\t\techo(\"Ending the conversation...\");\r\n\t\t\t\tbreak dance;\r\n\t\t\t}\r\n\t\t\tif (line.startsWith(\"/\")) {\r\n\t\t\t\tconst command = line.substring(1).trim();\r\n\t\t\t\tlet dirty=await callCommand(command);\r\n\t\t\t\tif(dirty){\r\n\t\t\t\t\tlines.push(\"Please review source for bugs and all content if notable changes detected, thanks.\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlines.push(line.trim());\r\n\t\t}\r\n\r\n\t\tif (lines.length){\r\n\t\t\tconst query=lines.join(\"\\n\");\r\n\t\t\tif(query.length){\r\n\t\t\t\trohaHistory.push({ role: \"user\", content: query });\r\n\t\t\t\tawait relay();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nDeno.addSignalListener(\"SIGINT\", () => {Deno.exit(0);});\r\n\r\n//only windows Deno.addSignalListener(\"SIGBREAK\", () => {echo(\"SIGBREAK\");});\r\n\r\nawait runCode(\"isolation/test.js\",\"isolation\");\r\n\r\nchat();\r\n\n{\"path\":\"C:/nitrologic/foundry/release/accounts.json\",\"length\":362,\"type\":\"application/json; charset=UTF-8\"}\n{\r\n\t\"gemini\":{\r\n\t\t\"env\":\"GEMINI_API_KEY\",\r\n\t\t\"url\":\"https://generativelanguage.googleapis.com/v1beta/openai\"\r\n\t},\r\n\t\"deepseek\":{\r\n\t\t\"env\":\"DEEPSEEK_API_KEY\",\r\n\t\t\"url\":\"https://api.deepseek.com\"\r\n\t},\r\n\t\"xai\": {\r\n\t\t\"env\": \"XAI_API_KEY\",\r\n\t\t\"url\": \"https://api.x.ai/v1\"\r\n\t},\r\n\t\"openai\": {\r\n\t\t\"env\": \"OPENAI_API_KEY\",\r\n\t\t\"url\": \"https://api.openai.com/v1\"\r\n\t}\r\n  }\r\n\n{\"path\":\"C:/nitrologic/foundry/release/foundry.md\",\"length\":2601,\"type\":\"text/markdown; charset=UTF-8\"}\n# foundry command line client\r\n\r\nA command line application designed to chat and share files.\r\n\r\n## foundry machine interface\r\n\r\nThe foundry functional interface uses tools and tool_calls.\r\n\r\nOnly recent models provide tools interface, foundry should fall \r\nback to a no tools completion mode.\r\n\r\nSee the OpenAI API spec for more tool role details.\r\n\r\n### read_time\r\n\r\n### submit_file\r\n\r\n### annotate_foundry\r\n\r\n## foundry user interface\r\n\r\ncommands with no arguments may often prompt for a # index from\r\nthe items displayed\r\n\r\n### /config\r\n\r\nToggle configuration flags.\r\n\r\nAdjust settings to suit current preferences.\r\n\r\nDefault values are typically:\r\n\r\n* 0 commitonstart : commit shared files on start : true\r\n* 1 ansi : markdown ANSI rendering : true\r\n* 2 slow : output at reading speed : true\r\n* 3 verbose : emit debug information : true\r\n* 4 broken : ansi background blocks : false\r\n* 5 logging : log all output to file : true\r\n* 6 resetcounters : at reset zero all counters : true\r\n\r\n### /share\r\n\r\nShare a file or folder with optional tag.\r\n\r\nFiles are added to the share list used by the /push /commit command.\r\n\r\n### /drop\r\n\r\nDrop all files currently shared\r\n\r\n### /push /commit\r\n\r\nRefresh shared files. \r\n\r\nDetects changes or deletions and updates the chat history.\r\n\r\nPosts new versions of file content if modified.\r\n\r\n### /reset\r\n\r\nClear all shared files and conversation history.\r\n\r\n### /history\r\n\r\nList a summary of recent conversation entries. \r\n\r\nProvides a quick overview of chat history.\r\n\r\n### /cd\r\n\r\nChange the working directory. \r\n\r\nUser can navigate to a desired directory for file operations.\r\n\r\n### /dir\r\n\r\nList the contents of the current working directory. \r\n\r\nHelps user view available files and folders to share.\r\n\r\n\r\n### /model\r\n\r\nSelect an AI model.\r\n\r\nUser can choose a model by name or index from the accounts available.\r\n\r\n### /counters\r\n\r\nList the internal application counters.\r\n\r\n### /tag\r\n\r\nDescribe all tags in use.\r\n\r\nDisplays tag name, count of shares tagged and description.\r\n\r\n### /account\r\n\r\nDisplay current account information.\r\n\r\n### /save [name]\r\n\r\nSave the current conversation history. \r\n\r\nCreates a snapshot file of the conversation.\r\n\r\nThe default name is currently .roa-save-HEX32_TIME.json\r\n\r\n### /load\r\n\r\nLoad a saved conversation history snapshot.\r\n\r\nUser can specify a save index or file name to restore previous chats.\r\n\r\n\r\n### /time\r\n\r\nDisplay the current system time. \r\n\r\nHelps user verify system status.\r\n\r\n### /help\r\n\r\nIf you are reading this file, it may be due to the use of this command.\r\n\r\nIf you still need help visit the project page.\r\n\n{\"path\":\"C:/nitrologic/foundry/release/LICENSE.txt\",\"length\":1753,\"type\":\"text/plain; charset=UTF-8\"}\nMIT License\r\n\r\nCopyright (c) 2025 Simon Armstrong\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is                                            \r\nfurnished to do so, subject to the following conditions:                                                         \r\n                                                                                                                 \r\nThe above copyright notice and this permission notice shall be included in all                                   \r\ncopies or substantial portions of the Software.                                                                  \r\n                                                                                                                 \r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                       \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                         \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                                      \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                           \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                                    \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE                                    \r\nSOFTWARE. \n{\"path\":\"C:/nitrologic/foundry/release/welcome.txt\",\"length\":481,\"type\":\"text/plain; charset=UTF-8\"}\npreceed with caution\r\n\r\n  o---/\\     /---o     \\---/     /---/\\     o---/\\     \\---o     /---/\\ \r\n  |    \\/   /    |     |    /   /    \\/    |    \\/   /    |     |    \\/ \r\n#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #\r\n\r\n\tWELCOME TO FOUNDRY\r\n\r\n\tA COMMAND LINE TOOL FOR CHATTING AND SHARING FILES\r\n\r\n\tTHE MAGIC WORD IS HAPUKA\r\n\r\n\tTHIS FILE IS PART OF THE ROHA CLIENT DISTRIBUTION\r\n\r\n#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #\r\n\n{\"path\":\"C:/nitrologic/foundry/release/forge/readme.txt\",\"length\":67,\"type\":\"text/plain; charset=UTF-8\"}\nlocal storage for shared files submitted for review by foundry rc1\n\n{\"path\":\"C:/nitrologic/foundry/release/isolation/readme.txt\",\"length\":103,\"type\":\"text/plain; charset=UTF-8\"}\na sandbox for foundry rc1 runs\r\n\r\nrun foundry run\r\n\r\nthis stuff is post rc1 - what is going on here?\r\n \n{\"path\":\"C:/nitrologic/foundry/release/isolation/test.js\",\"length\":180,\"type\":\"application/javascript; charset=UTF-8\"}\n\r\nfunction hexDate(){\r\n    let s=Date.now()/1e3|0;\r\n    return s.toString(16);\r\n}\r\n\r\nconsole.log(\"radio   live transmission\");\r\n\r\nconsole.log(hexDate());\r\nconsole.log(hexDate());\r\n\n{\"path\":\"C:/nitrologic/foundry/.gitignore\",\"length\":55,\"type\":\"application/octet-stream\",\"mimeType\":\"application/octet-stream\"}\nFile content: MIME=application/octet-stream, Base64=Zm91bmRyeS5sb2cKZm91bmRyeS5qc29uCnNhdmVzCnJlbGVhc2UKcmMxL2ZvdW5kcnkuZXhlCg==\n{\"path\":\"C:/nitrologic/foundry/build.bat\",\"length\":88,\"type\":\"application/x-msdownload\"}\ndeno compile --allow-run --allow-env --allow-net --allow-read --allow-write foundry.js\r\n\ni would like to prepare a report on the nitrologic foundry client\nBelow is a draft report on the Nitrologic Foundry Client:\n\n─────────────────────────────────────────────  \nNitrologic Foundry Client Report  \n─────────────────────────────────────────────\n\n1. Overview\n\nThe Nitrologic Foundry Client is a command‑line research client designed to interact with language models and manage file sharing. Written in JavaScript/TypeScript for execution with Deno, the client leverages several permissions (run, env, net, read, write) and is intended for experimentation with model evaluations, conversation histories, and file submission workflows.\n\n2. Key Features\n\n• Chat Interface and History Management  \n – The client provides an interactive prompt (using raw mode via Deno’s stdin reader) that accepts chat messages and commands.  \n – It maintains a conversation history (“rohaHistory”) for both user queries and model responses, allowing for conversation snapshots and history restoration via save and load functionality.  \n – A “relay” function communicates with model endpoints (using the OpenAI client libraries and several API providers such as GEMINI, DEEPSEEK, XAI, and OpenAI) and appears to support models that have tool call capabilities.\n\n• File Sharing and Submission  \n – The “/share” command enables users to designate files or directories for sharing. Individual files are processed (for text, JSON, markdown, etc.) or converted to Base64 for binary content.  \n – A sharing mechanism tracks file metadata (path, size, modification time, hash) and tags shared files.  \n – The client supports a “/push” or “/commit” command that scans shared files, detects modifications or deletions, and—if changes are detected—updates the chat history and files submitted for review.\n\n• Configuration and Customization  \n – Several configuration flags allow toggling features such as committing shares on start, ANSI rendering of markdown, slow output, verbose debugging information, and logging (to a file “foundry.log”).  \n – The “/config” command lists available flags, which include:  \n  • commitonstart  (commit shared files on start)  \n  • tools        (enable model tool interface)  \n  • ansi         (render using ANSI/markdown)  \n  • slow         (output at reading speed)  \n  • verbose       (emit debug information)  \n  • broken        (ansi background blocks via alternate colors)  \n  • logging       (log all output to file)  \n  • resetcounters  (reset counters on reset)  \n  • returntopush  (prompt to “push” when returning)\n\n• Model Management and Tooling Interface  \n – The client supports selecting models via the “/model” command. The list of available models is gathered from multiple API endpoints (configured in the “accounts.json” file) and stored in a list (“modelList”).  \n – It uses tool call functions if the selected model supports the tools interface. Three tool functions are defined:  \n  ○ read_time – returns current UTC time.  \n  ○ submit_file – submits a file for review by sending content type and file content, saving the file to a “forge” directory.  \n  ○ annotate_foundry – permits setting descriptions on objects like tags or shared files.  \n – The “relay” function is responsible for interfacing with the model. It prepares the payload (using either the simple chat history or a tool call JSON structure) and recursively handles tool call responses by executing the corresponding functions (via “onCall”) before forwarding the results back into the conversation cycle.\n\n3. Architecture and Workflow\n\n• Initialization and Configuration  \n – On startup, the client checks for a “foundry.json” state file, creating one with default settings if not present.  \n – It reads “accounts.json” to establish connections with the configured AI endpoints; these connections use API keys from environment variables.  \n – The client also initializes conversation history (rohaHistory) with a system prompt (“I am testing foundry client. You are a helpful assistant”).\n\n• File and Directory Operations  \n – Commands such as “/cd” and “/dir” allow the user to manage current working directories – aiding in file selection for sharing.  \n – The client uses Deno APIs for file operations, including reading, writing, statting files, and computing file hashes using SHA‑256.\n\n• Command Processing  \n – Input lines that begin with a “/” are interpreted as commands. Otherwise, they are treated as chat messages from the user.  \n – A command “callCommand” function handles a wide range of commands: listing accounts, toggling configuration flags, sharing files, managing tags, and handling model selection.\n – Commands such as “/reset” clear shared files and conversation history; “/history” lists recent conversation activities; “/save” and “/load” allow the user to persist or restore sessions.\n\n• ANSI and Markdown Rendering  \n – The client can render markdown content with ANSI escape sequences for styling (headers, bold, italics, bullets).  \n – There is a fallback plain output mode if ANSI rendering is not enabled.\n\n• Isolation and Sandbox Execution  \n – A helper function “isolateCode” is provided to run external JavaScript code (from an “isolation/test.js” file) in a sandboxed environment with restricted permissions. This supports a “runCode” routine that demonstrates isolated execution.\n\n4. Additional Files and Documentation\n\n• foundry.md – This markdown file provides an overview of the available commands and the machine interface (tool calls) for the client.\n• welcome.txt – A welcome banner displayed on startup.\n• LICENSE.txt and build.bat – These files establish project licensing (MIT License) and build instructions for compiling the Deno application.\n• The “forge” subdirectory is used for storing file submissions and conversation snapshots.\n• The “isolation” subdirectory contains a sandbox for testing code execution, distinct from the main workflow.\n\n5. Summary\n\nThe Nitrologic Foundry Client is a robust research tool designed for interacting with language models while integrating file sharing and conversation management. With its modular tool calls, command interface, and detailed configuration options, it becomes a flexible environment for testing model capabilities – particularly for those models that support an interactive tools interface. The design elegantly combines interactive terminal I/O, file system operations, and API integrations in a portable Deno runtime environment.\n\n─────────────────────────────────────────────  \nConcluding Remarks\n\nThe Foundry Client, as demonstrated by the provided source code and accompanying materials, reflects thoughtful design aimed at research and interactive testing. Its support for both chat-based interactions and contextual file sharing makes it well suited for scenarios where version tracking and iterative model evaluation are needed. Future enhancements—such as improved error handling, richer command completion (e.g., arrow navigation), and expanded tool integrations—could further extend its capabilities.\n\n─────────────────────────────────────────────  \nEnd of Report\n\nFeel free to adjust or expand any sections as needed for your reporting purposes.\nno way to verbose\n// foundry.js\r\n// a research client for evaluating models\r\n// (c)2025 Simon Armstrong\r\n\r\n// deno run --allow-run --allow-env --allow-net --allow-read --allow-write roha.js\r\n\r\nimport { contentType } from \"https://deno.land/std@0.224.0/media_types/mod.ts\";\r\nimport { resolve } from \"https://deno.land/std/path/mod.ts\";\r\nimport OpenAI from \"https://deno.land/x/openai@v4.67.2/mod.ts\";\r\n\r\nconst foundryVersion = \"rc1\";\r\nconst rohaTitle=\"foundry \"+foundryVersion;\r\nconst rohaMihi=\"I am testing foundry client. You are a helpful assistant.\";\r\n\r\nconst slowMillis = 20;\r\n\r\nconst decoder = new TextDecoder(\"utf-8\");\r\nconst encoder = new TextEncoder();\r\n\r\nconst terminalColumns=120;\r\n\r\nconst flagNames={\r\n\tcommitonstart : \"commit shared files on start\",\r\n\ttools : \"enable model tool interface\",\r\n\tansi : \"markdown ANSI rendering\",\r\n\tslow : \"output at reading speed\",\r\n\tverbose : \"emit debug information\",\r\n\tbroken : \"ansi background blocks\",\r\n\tlogging : \"log all output to file\",\r\n\tresetcounters : \"factory reset when reset\",\r\n\treturntopush : \"hit return to /push - it is under test\"\r\n};\r\n\r\nconst emptyRoha={\r\n\tconfig:{\r\n\t\tcommitonstart:true,\r\n\t\tansi:true,\r\n\t\tslow:false,\r\n\t\tverbose:false,\r\n\t\tbroken:false,\r\n\t\tlogging:false,\r\n\t\tresetcounters:false,\r\n\t\treturntopush:false\r\n\t},\r\n\ttags:{},\r\n\tmodels:{},\r\n\tband:{},\r\n\tsharedFiles:[],\r\n\tsaves:[],\r\n\tcounters:{}\r\n};\r\n\r\nfunction addBand(){\r\n\tlet id=\"member\"+increment(\"members\");\r\n\troha.band[id]={};\r\n}\r\n\r\nfunction listBand(){\r\n\tlet band=[];\r\n\tfor(let id in roha.band){\r\n\t\tlet member=roha.band[id];\r\n\t\tband.push(member);\r\n\t}\r\n\tband.push(\"add\");\r\n\tfor(let i=0;i<band.length;i++){\r\n\t\techo(i,band[i]);\r\n\t}\r\n\tmemberList=band;\r\n}\r\n\r\nfunction annotateTag(name,description){\r\n\tif(!name){\r\n\t\tthrow(\"null name\");\r\n\t}\r\n\tif(!(name in roha.tags)) {\r\n\t\troha.tags[name]={};\r\n//\t\tthrow(\"tag not found \"+name);\r\n\t}\r\n\troha.tags[name].description=description;\r\n}\r\n\r\nfunction annotateShare(name,description){\r\n\tlet index=roha.sharedFiles.findIndex(item => item.id === name);\r\n\tif(index==-1) throw(\"share id not found\");\r\n\troha.sharedFiles[index].description=description;\r\n\techo(\"file share description annotated\");\r\n}\r\n\r\nfunction increment(key){\r\n\tlet i=0;\r\n\tif(key in roha.counters){\r\n\t\ti=roha.counters[key]+1;\r\n\t}\r\n\troha.counters[key]=i;\r\n\treturn i\r\n}\r\n\r\nvar tagList=[];\r\nvar modelList=[];\r\nvar shareList=[]; //typically biggest to smallest\r\nvar memberList=[];\r\n\r\nconst emptyModel={\r\n\tname:\"empty\",account:\"\",hidden:false,prompts:0,completion:0\r\n}\r\n\r\nconst emptyTag={\r\n}\r\n\r\n// const emptyShare={path,size,modified,hash,tag,id}\r\n\r\nlet roha=emptyRoha;\r\nlet rohaCalls=0;\r\nlet listCommand=\"\";\r\nlet rohaShares=[];\r\nlet currentDir = Deno.cwd();\r\nvar rohaHistory;\r\n\r\nfunction resetHistory(){\r\n\trohaHistory = [{role:\"system\",content:rohaMihi}];\r\n}\r\n\r\nfunction listHistory(){\r\n\tlet history=rohaHistory;\r\n\tfor(let i=0;i<history.length;i++){\r\n\t\tlet item=history[i];\r\n\t\tlet content=readable(item.content).substring(0,90)\r\n\t\techo(i,item.role,item.name||\"foundry\",\"-\",content);\r\n\t}\r\n\tif(roha.config.broken){\r\n\t\tlet flat=squashMessages(rohaHistory);\r\n\t\tfor(let i=0;i<flat.length;i++){\r\n\t\t\tlet item=flat[i];\r\n\t\t\tlet content=readable(item.content).substring(0,90);\r\n\t\t\techo(\"flat\",i,item.role,item.name||\"broken\",content);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction rohaPush(content,name=\"foundry\"){\r\n\trohaHistory.push({role:\"user\",name,content});\r\n}\r\n\r\nresetHistory();\r\n\r\n// roaTools\r\n\r\nconst rohaTools = [{\r\n\ttype: \"function\",\r\n\tfunction:{\r\n\t\tname: \"read_time\",\r\n\t\tdescription: \"Returns current time in UTC\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {},\r\n\t\t\trequired: []\r\n\t\t}\r\n\t}\r\n},{\r\n\ttype: \"function\",\r\n\tfunction:{\r\n\t\tname: \"submit_file\",\r\n\t\tdescription: \"Submit a file for review\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {\r\n\t\t\t\tcontentType:{type:\"string\"},\r\n\t\t\t\tcontent:{type:\"string\"}\r\n\t\t\t},\r\n\t\t\trequired: [\"contentType\",\"content\"]\r\n\t\t}\r\n\t}\r\n},{\r\n\ttype: \"function\",\r\n\tfunction: {\r\n\t\tname: \"annotate_foundry\",\r\n\t\tdescription: \"Set description of any object\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {\r\n\t\t\t\tname: { type: \"string\" },\r\n\t\t\t\ttype: { type:\"string\" },\r\n\t\t\t\tdescription: { type: \"string\" }\r\n\t\t\t},\r\n\t\t\trequired: [\"name\",\"type\",\"description\"]\r\n\t\t}\r\n\t}\r\n}];\r\n\r\nasync function sleep(ms) {\r\n\tawait new Promise(function(resolve) {setTimeout(resolve, ms);});\r\n}\r\n\r\nfunction measure(o){\r\n\tlet total=JSON.stringify(o).length;\r\n\treturn total;\r\n}\r\n\r\nlet outputBuffer = [];\r\nlet printBuffer = [];\r\n\r\nfunction print(){\r\n\tlet args=arguments.length?Array.from(arguments):[];\r\n\tlet lines=args.join(\" \").split(\"\\n\");\r\n\tfor(let line of lines){\r\n\t\tprintBuffer.push(line.trimEnd());\r\n\t}\r\n}\r\n\r\nfunction echo(){\r\n\tlet args=arguments.length?Array.from(arguments):[];\r\n\tlet lines=args.join(\" \").split(\"\\n\");\r\n\tfor(let line of lines){\r\n\t\toutputBuffer.push(line.trimEnd());\r\n\t}\r\n}\r\n\r\nfunction stripAnsi(text) {\r\n\treturn text.replace(/\\x1B\\[\\d+(;\\d+)*[mK]/g, '');\r\n}\r\n\r\nasync function log(lines,id){\r\n\tif(roha.config.logging){\r\n\t\tconst time = new Date().toISOString();\r\n\t\tlet list=[];\r\n\t\tfor(let line of lines.split(\"\\n\")){\r\n\t\t\tline=stripAnsi(line);\r\n\t\t\tline=time+\" [\"+id+\"] \"+line+\"\\n\";\r\n\t\t\tlist.push(line);\r\n\t\t}\r\n\t\tawait Deno.writeTextFile(\"foundry.log\",list.join(),{append:true});\r\n\t}\r\n}\r\n\r\nasync function flush() {\r\n\tconst delay = roha.config.slow ? slowMillis : 0;\r\n\tfor (const line of printBuffer) {\r\n\t\tconsole.log(line);\r\n\t\tlog(line,\"model\");\r\n\t}\r\n\tprintBuffer=[];\r\n\tfor (const line of outputBuffer) {\r\n\t\tconsole.log(line);\r\n\t\tlog(line,\"stdout\");\r\n\t\tawait sleep(delay);\r\n\t}\r\n\toutputBuffer=[];\r\n}\r\n\r\nfunction wordWrap(text,cols=terminalColumns){\r\n\tvar result=[];\r\n\tvar pos=0;\r\n\twhile(pos<text.length){\r\n\t\tlet line=text.substring(pos,pos+cols);\r\n\t\tlet n=line.length;\r\n\t\tif(n==cols){\r\n\t\t\tvar i=line.lastIndexOf(\" \",n);\r\n\t\t\tif(i>0){\r\n\t\t\t\tline=line.substring(0,i);\r\n\t\t\t\tn=i+1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tresult.push(line);\r\n\t\tpos+=n;\r\n\t}\r\n\treturn result.join(\"\\n\");\r\n}\r\n\r\n// main roha application starts here\r\n\r\nconst MaxFileSize=65536;\r\n\r\nconst appDir = Deno.cwd();\r\nconst rohaPath = resolve(appDir,\"foundry.json\");\r\nconst accountsPath = resolve(appDir,\"accounts.json\");\r\nconst forgePath=resolve(appDir,\"forge\");\r\n\r\nconst modelAccounts = JSON.parse(await Deno.readTextFile(accountsPath));\r\n\r\nasync function pathExists(path) {\r\n\ttry {\r\n\t\tconst stat = await Deno.stat(path);\r\n\t\tif (!stat.isFile) return false;\r\n\t\treturn true;\r\n\t} catch (error) {\r\n\t\tif (error instanceof Deno.errors.NotFound) return false;\r\n\t\tif (error instanceof Deno.errors.PermissionDenied) return false;\r\n\t\tthrow error;\r\n\t}\r\n}\r\n\r\nconst fileExists = await pathExists(rohaPath);\r\nif (!fileExists) {\r\n\tawait Deno.writeTextFile(rohaPath, JSON.stringify(emptyRoha));\r\n\techo(\"Created new\",rohaPath);\r\n}\r\n\r\nconst rohaAccount={};\r\nfor(let account in modelAccounts){\r\n\tlet endpoint = await connectAccount(account);\r\n\tif(endpoint) rohaAccount[account]=endpoint;\r\n}\r\n\r\nfunction stringify(value, seen = new WeakSet(), keyName = \"\") {\r\n\tif (typeof value === \"string\") return value;\r\n\tif (value === null || typeof value !== \"object\") return String(value);\r\n\tif (typeof value === \"function\") return \"[function]\";\r\n\tif (seen.has(value)) return keyName ? `[circular (${keyName})]` :\"[circular]\";\r\n\tseen.add(value);\r\n\tif (Array.isArray(value)) {\r\n\t\tconst items = value.map((item, index) => stringify(item, seen,\r\n\t\tString(index)));\r\n\t\treturn `[${items.join(\",\\n\")}]`;\r\n\t}\r\n\tconst entries = Object.entries(value).map(([key, val]) => `${key}: ${stringify(val, seen, key)}`);\r\n\treturn `{${entries.join(\",\\n\")}}`;\r\n}\r\n\r\nasync function connectAccount(account) {\r\n\tlet verbose=false;//roha.config.verbose;\r\n\techo(\"Connecting to account:\", account);\r\n\tconst config = modelAccounts[account];\r\n\tif (!config) return null;\r\n\ttry{\r\n\t\tconst apiKey = Deno.env.get(config.env);\r\n\t\tconst endpoint = new OpenAI({ apiKey, baseURL: config.url });\r\n\t\tif(verbose){\r\n\t\t\tfor(const [key, value] of Object.entries(endpoint)){\r\n\t\t\t\tlet content=stringify(value);\r\n\t\t\t\techo(\"endpoint:\"+key+\":\"+content);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst models = await endpoint.models.list();\r\n\t\tconst list=[];\r\n\t\tfor (const model of models.data) {\r\n\t\t\tlet name=model.id+\"@\"+account;\r\n\t\t\tlist.push(name);\r\n\t\t\tif(verbose) echo(\"model - \",JSON.stringify(model,null,\"\\t\"));\r\n\t\t}\r\n\t\tlist.sort();\r\n\t\tmodelList=modelList.concat(list);\r\n\t\treturn endpoint;\r\n\t}catch(error){\r\n\t// Error: 429 \"Your team ac0a3c9a-0e58-4e3c-badd-be853c027a7f has either used all available credits or \r\n\t// reached its monthly spending limit. To continue making API requests, please purchase more credits or \r\n\t// raise your spending limit.\"\r\n\t\techo(error);\r\n\t}\r\n\treturn null;\r\n}\r\n\r\nasync function resetModel(name){\r\n\tgrokModel=name;\r\n\tgrokFunctions=true;\r\n\trohaHistory.push({role:\"system\",content:\"Model changed to \"+name+\".\"});\r\n\techo(\"with model\",name,grokFunctions)\r\n\tawait writeRoha();\r\n}\r\n\r\nfunction dropShares(){\r\n\tfor(let item of rohaHistory){\r\n\t\tif(item && item.role===\"user\" && item.user===\"forge\"){\r\n\t\t\titem.user=\"drop\";\r\n\t\t\titem.content=\"dropped path \"+(item.path||\"\");\t\t\t\r\n\t\t}\r\n\t}\r\n\trohaShares=[];\r\n\techo(\"all shares dropped\");\r\n}\r\n\r\nfunction listShare(){\r\n\tconst list=[];\r\n\tlet count=0;\r\n\tlet sorted = roha.sharedFiles.slice();\r\n\tsorted.sort((a, b) => b.size - a.size);\r\n\tfor (const share of sorted) {\r\n\t\tlet shared=(rohaShares.includes(share.path))?\"*\":\"\";\r\n\t\tlet tags=\"[\"+share.tag+\"]\";\r\n\t\tlet info=(share.description)?share.description:\"\";\r\n\t\techo((count++),share.path,share.size,shared,tags,info);\r\n\t\tlist.push(share.id);\r\n\t}\r\n\tshareList=list;\r\n}\r\n\r\nfunction listSaves(){\r\n\tlet saves=roha.saves||[];\r\n\tfor(let i=0;i<saves.length;i++){\r\n\t\techo(i,saves[i]);\r\n\t}\r\n}\r\n\r\nasync function saveHistory(name) {\r\n\ttry {\r\n\t\tlet timestamp=Math.floor(Date.now()/1000).toString(16);\r\n\t\tlet filename=(name||\"transmission-\"+timestamp)+\".json\";\r\n\t\tlet filePath = resolve(forgePath,filename);\r\n\t\tlet line=\"Saved session \"+filename+\".\";\r\n\t\trohaHistory.push({role:\"system\",content:line});\r\n\t\tawait Deno.writeTextFile(filePath,JSON.stringify(rohaHistory,null,\"\\t\"));\r\n\t\techo(line);\r\n\t\troha.saves.push(filename);\r\n\t\tawait writeRoha();\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error saving history:\", error.message);\r\n\t}\r\n}\r\n\r\nasync function loadHistory(filename){\r\n\tvar history;\r\n\ttry {\r\n\t\tconst fileContent = await Deno.readTextFile(filename);\r\n\t\thistory = JSON.parse(fileContent);\r\n\t\techo(\"History restored from \"+filename);\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error restoring history:\", error.message);\r\n\t\techo(\"console error\");\r\n\t\thistory=[{role:\"system\",content: \"You are a helpful assistant.\"}];\r\n\t}\r\n\treturn history;\r\n}\r\n\r\nconst ansiBackgrounds = [\r\n\t{ name: \"dark0\", code: \"\\x1b[48;5;232m\" }, // #1c2526\r\n\t{ name: \"dark1\", code: \"\\x1b[48;5;233m\" }, // #2e3436\r\n\t{ name: \"dark2\", code: \"\\x1b[48;5;234m\" }, // #3d4446\r\n\t{ name: \"dark3\", code: \"\\x1b[48;5;235m\" }, // #4e5456\r\n\t{ name: \"charcoal\", code: \"\\x1b[48;5;236m\" }, // #606668\r\n\t{ name: \"darkBlue\", code: \"\\x1b[48;5;17m\" }, // #00005f\r\n\t{ name: \"darkGreen\", code: \"\\x1b[48;5;23m\" }, // #003f3f\r\n\t{ name: \"darkMutedPurple\", code: \"\\x1b[48;5;54m\" }, // #5f00af\r\n\t{ name: \"veryDarkBlue\", code: \"\\x1b[48;5;18m\" }, // #000087\r\n\t{ name: \"darkCharcoal\", code: \"\\x1b[48;5;239m\" }, // #4e4e4e\r\n\t{ name: \"mutedNavy\", code: \"\\x1b[48;5;19m\" }, // #0000af\r\n\t{ name: \"deepGray\", code: \"\\x1b[48;5;240m\" } // #585858\r\n];\r\n\r\nconst ansiMoveToEnd = \"\\x1b[999B\";\r\nconst ansiSaveCursor = \"\\x1b[s\";\r\nconst ansiRestoreCursor = \"\\x1b[u\";\r\n\r\nconst ansiReplyBlock = ansiBackgrounds[0].code;\r\nconst ansiCodeBlock = ansiBackgrounds[6].code;\r\n\r\nconst rohaPrompt=\">\";\r\n\r\nconst ansiItalics = \"\\x1b[3m\";\r\nconst ansiReset = \"\\x1b[0m\";\r\nconst ansiPurple = \"\\x1b[1;35m\";\r\n\r\nfunction mdToAnsi(md) {\r\n\tlet broken=roha.config.broken;\r\n\tconst lines = md.split(\"\\n\");\r\n\tlet inCode = false;\r\n\tconst result = broken?[ansiReplyBlock]:[];\r\n\tfor (let line of lines) {\r\n\t\tline=line.trimEnd();\r\n\t\tlet trim=line.trim();\r\n\t\tif (trim.startsWith(\"```\")) {\r\n\t\t\tinCode = !inCode;\r\n\t\t\tif(inCode){\r\n\t\t\t\tresult.push(ansiCodeBlock);\r\n\t\t\t\tlet codeType=trim.substring(3);\r\n\t\t\t\techo(\"inCode \"+codeType);\r\n\t\t\t}else{\r\n\t\t\t\tif (broken) result.push(ansiReplyBlock);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif (!inCode) {\r\n\t\t\t\t// headershow\r\n\t\t\t\tconst header = line.match(/^#+/);\r\n\t\t\t\tif (header) {\r\n\t\t\t\t\tconst level = header[0].length;\r\n\t\t\t\t\tline = line.substring(level).trim();\r\n\t\t\t\t\tline = ansiPurple + line + ansiReset;\r\n\t\t\t\t}\r\n\t\t\t\t// bullets\r\n\t\t\t\tif (line.startsWith('-') || line.startsWith('*') || line.startsWith('+')) {\r\n\t\t\t\t\tline = '• ' + line.substring(1).trim();\r\n\t\t\t\t}\r\n\t\t\t\t// bold\r\n\t\t\t\tif (line.includes(\"**\")) {\r\n\t\t\t\t\tline = line.replace(/\\*\\*(.*?)\\*\\*/g, \"\\x1b[1m$1\\x1b[0m\");\r\n\t\t\t\t}\r\n\t\t\t\t// italic\r\n\t\t\t\tline = line.replace(/\\*(.*?)\\*/g, \"\\x1b[3m$1\\x1b[0m\");\r\n\t\t\t\tline = line.replace(/_(.*?)_/g, \"\\x1b[3m$1\\x1b[0m\");\r\n\t\t\t\t// wordwrap\r\n\t\t\t\tline=wordWrap(line,terminalColumns);\r\n\t\t\t}\r\n\t\t\tresult.push(line.trimEnd());\r\n\t\t}\r\n\t}\r\n\tresult.push(ansiReset);\r\n\treturn result.join(\"\\n\");\r\n}\r\n\r\nasync function hashFile(filePath) {\r\n\tconst fileContent = await Deno.readFile(filePath);\r\n\tconst hashBuffer = await crypto.subtle.digest(\"SHA-256\", fileContent);\r\n\tconst hashArray = new Uint8Array(hashBuffer);\r\n\treturn Array.from(hashArray).map(byte => byte.toString(16).padStart(2, '0')).join('');\r\n}\r\n\r\nasync function readRoha(){\r\n\ttry {\r\n\t\tconst fileContent = await Deno.readTextFile(rohaPath);\r\n\t\troha = JSON.parse(fileContent);\r\n\t\tif(!roha.saves) roha.saves=[];\r\n\t\tif(!roha.counters) roha.counters={};\r\n\t\tif(!roha.band) roha.band={};\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error reading or parsing\",rohaPath,error);\r\n\t\troha=emptyRoha;\r\n\t}\r\n}\r\n\r\nasync function writeRoha(){\r\n\ttry {\r\n\t\troha.model=grokModel;\r\n\t\tawait Deno.writeTextFile(rohaPath, JSON.stringify(roha, null, \"\\t\"));\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error writing\",rohaPath,error);\r\n\t}\r\n}\r\n\r\nasync function resetRoha(){\r\n\trohaShares = [];\r\n\troha.sharedFiles=[];\r\n\troha.tags={};\r\n\tif(roha.config.resetcounters) roha.counters={};\r\n\tincrement(\"resets\");\r\n\tawait writeRoha();\r\n\tresetHistory();\r\n\techo(\"resetRoha\",\"All shares and history reset.\");\r\n}\r\n\r\nfunction resolvePath(dir,filename){\r\n\tlet path=resolve(dir,filename);\r\n\tpath = path.replace(/\\\\/g, \"/\");\r\n\treturn path;\r\n}\r\n\r\n// a raw mode prompt replacement\r\n\r\n// arrow navigation and tab completion incoming\r\n\r\nconst reader = Deno.stdin.readable.getReader();\r\nconst writer = Deno.stdout.writable.getWriter();\r\n\r\nasync function prompt2(message) {\r\n\tif (message) {\r\n\t\tawait writer.write(encoder.encode(message));\r\n\t\tawait writer.ready;\r\n\t}\r\n\tDeno.stdin.setRaw(true);\r\n\tlet inputBuffer = new Uint8Array(0);\r\n\ttry {\r\n\t\twhile (true) {\r\n\t\t\tconst { value, done } = await reader.read();\r\n\t\t\tif (done || !value) break;\r\n\t\t\tfor (const byte of value) {\r\n\t\t\t\tif (byte === 0x7F || byte === 0x08) { // Backspace\r\n\t\t\t\t\tif (inputBuffer.length > 0) {\r\n\t\t\t\t\t\tinputBuffer = inputBuffer.slice(0, -1);\r\n\t\t\t\t\t\tawait writer.write(new Uint8Array([0x08, 0x20, 0x08])); // Erase last char\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (byte === 0x1b) { // Escape sequence\r\n\t\t\t\t\tif(value.length==1){\r\n\t\t\t\t\t\tDeno.exit(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(value.length==3){\r\n\t\t\t\t\t\tif(value[1]==0xf4 && value[2]==0x50){\r\n\t\t\t\t\t\t\techo(\"F1\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (byte === 0x0A || byte === 0x0D) { // Enter key\r\n\t\t\t\t\tawait writer.write(encoder.encode(\"\\r\\n\"));\r\n\t\t\t\t\tlet line = decoder.decode(inputBuffer);\r\n\t\t\t\t\tline=line.trim();\r\n\t\t\t\t\tlog(line,\"stdin\");\r\n\t\t\t\t\treturn line;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tawait writer.write(new Uint8Array([byte]));\r\n\t\t\t\t\tconst buf = new Uint8Array(inputBuffer.length + 1);\r\n\t\t\t\t\tbuf.set(inputBuffer);\r\n\t\t\t\t\tbuf[inputBuffer.length] = byte;\r\n\t\t\t\t\tinputBuffer = buf;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} finally {\r\n\t\tDeno.stdin.setRaw(false);\r\n\t}\r\n}\r\n\r\n// callers to addShare expected to await writeRoha after\r\n\r\nconst eventList=[];\r\n\r\nasync function watchPaths(paths,handler){\r\n\tconst watcher = Deno.watchFs(paths,{recursive:false});\r\n\tfor await (const event of watcher) {\r\n\t\teventList.push(event);\r\n\t}\r\n}\r\n\r\nasync function addShare(share){\r\n\tshare.id=\"share\"+increment(\"shares\");\r\n\troha.sharedFiles.push(share);\r\n\tif(share.tag) {\r\n\t\tawait setTag(share.tag,share.id);\r\n\t}\r\n}\r\n\r\nasync function shareDir(dir,tag) {\r\n\ttry {\r\n\t\tconst paths=[];\r\n\t\tconst files = await Deno.readDir(dir);\r\n\t\tfor await (const file of files) {\r\n\t\t\tif (file.isFile && !file.name.startsWith(\".\")) {\r\n\t\t\t\tpaths.push(resolvePath(dir, file.name));\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const path of paths) {\r\n//\t\t\techo(\"statting path:\"+path+\":\");\r\n\t\t\tconst info = await Deno.stat(path);\r\n\t\t\tlet size=info.size;\r\n\t\t\tlet modified=info.mtime.getTime();\r\n\t\t\tconst hash = await hashFile(path);\r\n\t\t\tawait addShare({path,size,modified,hash,tag})\r\n\t\t}\r\n\t\tawait writeRoha(); // TODO: check a dirty flag\r\n\t} catch (error) {\r\n\t\tconsole.error(\"### Error\"+error);\r\n\t}\r\n}\r\n\r\nfunction fileType(extension){\r\n\treturn contentType(extension) || 'application/octet-stream';\r\n}\r\n\r\nconst textExtensions = [\r\n\t\"js\", \"txt\", \"json\", \"md\",\r\n\t\"css\",\"html\", \"svg\",\r\n\t\"cpp\", \"c\", \"h\", \"cs\",\r\n\t\"sh\", \"bat\",\r\n\t\"log\",\"py\",\"csv\",\"xml\",\"ini\"\r\n];\r\n\r\nasync function shareFile(path,tag) {\r\n\tlet fileContent=null;\r\n\ttry {\r\n\t\tfileContent = await Deno.readFile(path);\r\n\t} catch (error) {\r\n\t\tconsole.error(\"shareFile path:\"+path+\" error:\", error);\r\n\t\treturn;\r\n\t}\r\n\tif(path.endsWith(\"rules.txt\")){\r\n\t\tlet lines=decoder.decode(fileContent).split(\"\\n\");\r\n\t\tfor(let line of lines ){\r\n\t\t\tif (line) rohaHistory.push({role:\"system\",content: line});\r\n\t\t}\r\n\t}else{\r\n\t\tconst length=fileContent.length;\r\n\t\tif(length>0 && length<MaxFileSize){\r\n\t\t\tconst extension = path.split('.').pop();\r\n\t\t\tconst type = fileType(extension);\r\n\t\t\tif (textExtensions.includes(extension)) {\r\n\t\t\t\tlet txt = decoder.decode(fileContent);\r\n\t\t\t\tif(txt.length){\r\n\t\t\t\t\tlet metadata=JSON.stringify({path,length,type,tag});\r\n\t\t\t\t\trohaPush(metadata);\r\n\t\t\t\t\trohaPush(txt,\"forge\");\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tconst base64Encoded = btoa(String.fromCharCode(...new Uint8Array(fileContent)));\r\n\t\t\t\tconst mimeType = fileType(extension);\r\n\t\t\t\tlet metadata=JSON.stringify({path,length,type,mimeType,tag});\r\n\t\t\t\trohaPush(metadata);\r\n\t\t\t\tlet binary=`File content: MIME=${mimeType}, Base64=${base64Encoded}`;\r\n\t\t\t\trohaPush(binary,\"forge\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n//\tif(roha.config.verbose)echo(\"roha shared file \" + path);\r\n\tif (!rohaShares.includes(path)) rohaShares.push(path);\r\n}\r\n\r\nasync function commitShares(tag) {\r\n\tlet dirty = false;\r\n\tconst validShares = [];\r\n\tconst removedPaths = [];\r\n\tfor (const share of roha.sharedFiles) {\r\n\t\tif (tag && share.tag !== tag) {\r\n\t\t\tvalidShares.push(share);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tconst info = await Deno.stat(share.path);\r\n\t\t\tconst modified = share.modified !== info.mtime.getTime();\r\n\t\t\tconst isShared = rohaShares.includes(share.path);\r\n\t\t\tif (modified || !isShared) {\r\n\t\t\t\tawait shareFile(share.path,tag);\r\n\t\t\t\tshare.modified = info.mtime.getTime();\r\n\t\t\t\tdirty = true;\r\n\t\t\t}\r\n\t\t\tvalidShares.push(share);\r\n\t\t} catch (error) {\r\n\t\t\tremovedPaths.push(share.path);\r\n\t\t\tdirty = true;\r\n\t\t}\r\n\t}\r\n\r\n\tif (removedPaths.length) {\r\n\t\troha.sharedFiles = validShares;\r\n\t\tawait writeRoha();\r\n\t\techo(`Invalid shares detected:\\n${removedPaths.join('\\n')}`);\r\n\t}\r\n\r\n\tif (dirty&&tag) {\r\n\t\tlet invoke=\"feel free to call annotate_foundry to tag \"+tag;\r\n\t\trohaHistory.push({role:\"system\",content:invoke});\r\n\t}\r\n\r\n\treturn dirty;\r\n}\r\n\r\nasync function setTag(name,note){\r\n\tlet tags=roha.tags||{};\r\n\tlet tag=(tags[name])?tags[name]:{name,info:[]};\r\n\ttag.info.push(note);\r\n\ttags[name]=tag;\r\n\troha.tags=tags;\r\n\tawait writeRoha();\r\n//\tlet invoke=`New tag \"${name}\" added. Describe all shares with this tag.`;\r\n//\trohaHistory.push({role:\"system\",content:invoke});\r\n}\r\nfunction listCounters(){\r\n\tlet keys=Object.keys(roha.counters);\r\n\tlet i=0;\r\n\tfor(let key of keys){\r\n\t\tlet count=roha.counters[key];\r\n\t\techo((i++),key,count);\r\n\t}\r\n}\r\nfunction listTags(){\r\n\tlet tags=roha.tags||{};\r\n\tlet keys=Object.keys(tags);\r\n\tlet list=[];\r\n\tfor(let i=0;i<keys.length;i++){\r\n\t\tlet tag=tags[keys[i]];\r\n\t\tconst name=tag.name||\"?????\";\r\n\t\techo(i,name,\"(\"+tag.info.length+\")\");\r\n\t\tlet info=tag.description;\r\n\t\tif(info) echo(\"\",info);\r\n\t\tlist.push(name);\r\n\t}\r\n\ttagList=list;\r\n}\r\n\r\nfunction listAccounts(){\r\n\tlet list=[];\r\n\tfor(let key in modelAccounts){\r\n\t\tlet value=modelAccounts[key];\r\n\t\tlist.push(key);\r\n\t}\r\n\tfor(let i=0;i<list.length;i++){\r\n\t\techo(i,list[i]);\r\n\t}\r\n}\r\n\r\nasync function showHelp() {\r\n\ttry {\r\n\t\tconst md = await Deno.readTextFile(\"foundry.md\");\r\n\t\techo(mdToAnsi(md));\r\n\t} catch (e) {\r\n\t\techo(\"Error loading help file: \" + e.message);\r\n\t}\r\n}\r\n\r\nfunction readable(text){\r\n\ttext=text.replace(/\\s+/g, \" \");\r\n\treturn text;\r\n}\r\n\r\nasync function callCommand(command) {\r\n\tlet dirty=false;\r\n\tlet words = command.split(\" \",2);\r\n\ttry {\r\n\t\tswitch (words[0]) {\r\n\t\t\tcase \"band\":\r\n\t\t\t\tlistBand();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"counter\":\r\n\t\t\t\tlistCounters();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"tag\":\r\n\t\t\t\tawait listTags();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"account\":\r\n\t\t\t\tawait listAccounts();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"help\":\r\n\t\t\t\tawait showHelp();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"config\":\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\tlet flag=words[1].trim();\r\n\t\t\t\t\tif(flag.length && !isNaN(flag)){\r\n\t\t\t\t\t\tflag=Object.keys(flagNames)[flag|0];\r\n\t\t\t\t\t\techo(\"flag\",flag);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(flag in flagNames){\r\n\t\t\t\t\t\troha.config[flag]=!roha.config[flag];\r\n\t\t\t\t\t\techo(flag+\" - \"+flagNames[flag]+\" is \"+(roha.config[flag]?\"true\":\"false\"));\r\n\t\t\t\t\t\tawait writeRoha();\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlet count=0;\r\n\t\t\t\t\tfor(let flag in flagNames){\r\n\t\t\t\t\t\techo((count++),flag,\":\",flagNames[flag],\":\",(roha.config[flag]?\"true\":\"false\"))\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistCommand=\"config\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"time\":\r\n\t\t\t\techo(\"Current time:\", new Date().toString());\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"history\":\r\n\t\t\t\tlistHistory();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"load\":\r\n\t\t\t\tlet save=words[1];\r\n\t\t\t\tif(save){\r\n\t\t\t\t\tif(save.length && !isNaN(save)) save=roha.saves[save|0];\r\n\t\t\t\t\tif(roha.saves.includes(save)){\r\n\t\t\t\t\t\tlet history=await loadHistory(save);\r\n\t\t\t\t\t\trohaHistory=history;\r\n\t\t\t\t\t\techo(\"a new history is set\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlistSaves();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"save\":\r\n\t\t\t\tlet savename=words.slice(1).join(\" \");\r\n\t\t\t\tsaveHistory(savename);\r\n\t\t\t\tawait writeRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"model\":\r\n\t\t\t\tlet name=words[1];\r\n\t\t\t\tif(name){\r\n\t\t\t\t\tif(name.length&&!isNaN(name)) name=modelList[name|0];\r\n\t\t\t\t\tif(modelList.includes(name)){\r\n\t\t\t\t\t\tresetModel(name);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor(let i=0;i<modelList.length;i++){\r\n\t\t\t\t\t\tlet name=modelList[i];\r\n\t\t\t\t\t\tlet attr=(name==grokModel)?\"*\":\"\";\r\n\t\t\t\t\t\techo(i,name,attr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistCommand=\"model\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"reset\":\r\n\t\t\t\tawait resetRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"cd\":\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\tconst newDir = words[1];\r\n\t\t\t\t\tif (newDir.length) Deno.chdir(newDir);\r\n\t\t\t\t}\r\n\t\t\t\tcurrentDir = Deno.cwd();\r\n\t\t\t\techo(\"Changed directory to\", currentDir);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"dir\":\r\n\t\t\t\tconst files = Deno.readDirSync(currentDir);\r\n\t\t\t\techo(\"Contents of\", currentDir + \":\");\r\n\t\t\t\tfor (const file of files) {\r\n\t\t\t\t\tlet name=(file.isDirectory)?\"[\"+file.name+\"]\":file.name;\r\n\t\t\t\t\techo(name);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"drop\":\r\n\t\t\t\tdropShares();\r\n\t\t\t\tawait writeRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"share\":\r\n\t\t\t\tif (words.length==1){\r\n\t\t\t\t\tlistShare();\r\n\t\t\t\t}else{\r\n\t\t\t\t\tconst filename = words.slice(1).join(\" \");\r\n\t\t\t\t\tconst path = resolvePath(Deno.cwd(), filename);\r\n\t\t\t\t\tconst info = await Deno.stat(path);\r\n\t\t\t\t\tconst tag = await prompt2(\"Enter tag name (optional):\");\r\n\t\t\t\t\tif(info.isDirectory){\r\n\t\t\t\t\t\techo(\"Share directory path:\",path);\r\n\t\t\t\t\t\tawait shareDir(path,tag);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlet size=info.size;\r\n\t\t\t\t\t\tlet modified=info.mtime.getTime();\r\n\t\t\t\t\t\techo(\"Share file path:\",path,\" size:\",info.size,\" \");\r\n\t\t\t\t\t\tconst hash = await hashFile(path);\r\n\t\t\t\t\t\techo(\"hash:\",hash);\r\n\t\t\t\t\t\tawait addShare({path,size,modified,hash,tag});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tawait writeRoha();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"push\":\r\n\t\t\tcase \"commit\":\r\n\t\t\t\tlet tag=\"\";\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\ttag=words[1];\r\n\t\t\t\t}\r\n\t\t\t\tdirty=await commitShares(tag);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\techo(\"Command not recognised\");\r\n\t\t\t\treturn false; // Command not recognized\r\n\t\t}\r\n\t} catch (error) {\r\n\t\techo(\"Error processing command:\", error.message);\r\n\t}\r\n\tincrement(\"calls\");\r\n\treturn dirty;\r\n}\r\n\r\necho(rohaTitle,\"running from \"+rohaPath);\r\nawait readRoha();\r\n\r\nlet grokModel = roha.model||\"deepseek-chat@deepseek\";\r\nlet grokFunctions=true;\r\nlet grokUsage = 0;\r\n\r\necho(\"present [\",grokModel,\"]\");\r\necho(\"shares count:\",roha.sharedFiles.length)\r\necho(\"use /help for latest and exit to quit\");\r\necho(\"\");\r\n\r\nlet sessions=increment(\"sessions\");\r\nif(sessions==0){\r\n\tlet welcome=await Deno.readTextFile(\"welcome.txt\");\r\n\techo(welcome);\r\n\tawait writeRoha();\r\n}\r\n\r\nif(roha.config){\r\n\tif(roha.config.commitonstart) await commitShares();\r\n}else{\r\n\troha.config={};\r\n}\r\n\r\nfunction extensionForType(contentType) {\r\n\tif (contentType.includes(\"markdown\")) return \".md\";\r\n\tif (contentType.includes(\"json\")) return \".json\";\r\n\tif (contentType.includes(\"javascript\")) return \".js\";\r\n\treturn \".txt\";\r\n}\r\n\r\nasync function onCall(toolCall) {\r\n\tlet verbose=roha.config.verbose;\r\n\tswitch(toolCall.function.name) {\r\n\t\tcase \"read_time\":\r\n\t\t\treturn {time: new Date().toISOString()};\r\n\t\tcase \"submit_file\":\r\n\t\t\tlet args=JSON.parse(toolCall.function.arguments);\r\n\t\t\techo(args.contentType);\r\n\t\t\tif (verbose) echo(args.content);\r\n\t\t\tlet timestamp=Math.floor(Date.now()/1000).toString(16);\r\n\t\t\tlet extension=extensionForType(args.contentType)\r\n\t\t\tlet name= \"submission-\"+timestamp+extension;\r\n\t\t\tlet filePath = resolve(forgePath,name);\r\n\t\t\tawait Deno.writeTextFile(filePath, args.content);\r\n\t\t\techo(\"File saved to:\", filePath);\r\n\t\t\treturn { success: true, path: filePath };\r\n\t\tcase \"annotate_foundry\":\r\n\t\t\ttry {\r\n\t\t\t\tconst { name, type, description } = JSON.parse(toolCall.function.arguments || \"{}\");\r\n\t\t\t\tswitch(type){\r\n\t\t\t\t\tcase \"tag\":\r\n\t\t\t\t\t\tannotateTag(name,description);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"share\":\r\n\t\t\t\t\t\tannotateShare(name,description);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tawait writeRoha(); // Persist changes\r\n\t\t\t\treturn { success: true, updated: 1 };\r\n\t\t\t} catch (error) {\r\n\t\t\t\techo(\"annotate_foundry error:\",error);\r\n\t\t\t\treturn { success: false, updated: 0 };\r\n\t\t\t}\r\n\t}\r\n\tconsole.error(\"onCall error - call simon\");\r\n}\r\n\r\nfunction squashMessages(history) {\r\n\tif (history.length < 2) return history;\r\n\tconst squashed = [history[0]];\r\n\tlet system=[];\r\n\tlet other=[];\r\n\tfor(let item of history){\r\n\t\tif(item.role==\"system\") system.push(item); else other.push(item);\r\n\t}\r\n\tfor(let list of [system,other]){\r\n\t\tlet last=null;\r\n\t\tfor (let i = 0; i < list.length; i++) {\r\n\t\t\tconst current=list[i];\r\n\t\t\tif(last){\r\n\t\t\t\tlast.content += \"\\n\" + current.content;\r\n\t\t\t} else {\r\n\t\t\t\tsquashed.push(current);\r\n\t\t\t\tlast=current;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn squashed;\r\n}\r\n\r\nasync function isolateCode(path,cwd) {\r\n\ttry {\r\n\t\tconst readAllow = `--allow-read=${cwd}`;\r\n\t\tconst writeAllow = `--allow-write=${cwd}`;\r\n\t\tconst cmd = [\"deno\", \"run\", \"--no-remote\", readAllow, writeAllow, path];\r\n\t\tconst process = Deno.run({ cmd, stdout: \"piped\", stderr: \"piped\" });\r\n\t\tconst [stdout, stderr] = await Promise.all([process.output(), process.stderrOutput()]);\r\n\t\tconst status = await process.status();\r\n\t\tprocess.close();\r\n\t\treturn {\r\n\t\t\tsuccess: status.success,\r\n\t\t\toutput: new TextDecoder().decode(stdout),\r\n\t\t\terror: new TextDecoder().decode(stderr)\r\n\t\t};\r\n\t} catch (err) {\r\n\t\treturn { success: false, output: \"\", error: err.message };\r\n\t}\r\n}\r\n\r\nasync function runCode(){\r\n\tlet result = await isolateCode(\"isolation/test.js\", \"isolation\");\r\n\t//echo(\"RunCode Result:\", result.success ? \"Success\" : \"Failed\");\r\n\tif (result.output) echo(\"[isolation] \", result.output);\r\n\tif (result.error) echo(\"Error:\", result.error);\r\n\t// todo: add save on exit\r\n}\r\n\r\nasync function relay() {\r\n\tconst verbose=roha.config.verbose;\r\n\ttry {\r\n\t\tconst modelAccount=grokModel.split(\"@\");\r\n\t\tlet model=modelAccount[0];\r\n\t\tlet account=modelAccount[1];\r\n\t\tlet endpoint=rohaAccount[account];\r\n\t\tlet usetools=grokFunctions&&roha.config.tools;\r\n\t\tconst payload = usetools?{ model, messages:rohaHistory, tools: rohaTools }:{ model, messages:squashMessages(rohaHistory) };\r\n\t\tconst completion = await endpoint.chat.completions.create(payload);\r\n\t\tif (completion.model != model) {\r\n\t\t\techo(\"[relay model alert model:\" + completion.model + \" grokModel:\" + grokModel + \"]\");\r\n\t\t\tgrokModel=completion.model+\"@\"+account;\r\n\t\t}\r\n\t\tif (verbose) {\r\n\t\t\t// echo(\"relay completion:\" + JSON.stringify(completion, null, \"\\t\"));\r\n\t\t}\r\n\t\tlet system = completion.system_fingerprint;\r\n\t\tlet usage = completion.usage;\r\n\t\tlet size = measure(rohaHistory);\r\n\t\tgrokUsage += usage.prompt_tokens | 0 + usage.completion_tokens | 0;\r\n\t\tlet status = \"[model \" + grokModel + \" \" + usage.prompt_tokens + \" \" + usage.completion_tokens + \" \" + grokUsage + \" \" + size + \"]\";\r\n\t\techo(status);\r\n\t\tvar reply = \"<blank>\";\r\n\t\tfor (const choice of completion.choices) {\r\n\t\t\tlet calls = choice.message.tool_calls;\r\n\t\t\t// choice has index message{role,content,refusal,annotations} finish_reason\r\n\t\t\tif (calls) {\r\n\t\t\t\tincrement(\"calls\");\r\n\t\t\t\techo(\"relay calls in progress\");\r\n\t\t\t\t// Generate tool_calls with simple, unique IDs\r\n\t\t\t\tconst toolCalls = calls.map((tool, index) => ({\r\n\t\t\t\t\tid: `call_${rohaCalls++}`,\r\n\t\t\t\t\ttype: \"function\",\r\n\t\t\t\t\tfunction: {\r\n\t\t\t\t\t\tname: tool.function.name,\r\n\t\t\t\t\t\targuments: tool.function.arguments || \"{}\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}));\r\n\t\t\t\t// Add assistant message with tool_calls\r\n\t\t\t\tlet content=choice.message.content || \"\";\r\n\t\t\t\trohaHistory.push({role:\"assistant\",content,tool_calls: toolCalls});\r\n\t\t\t\tif(verbose) echo(\"tooling \"+content);\r\n\t\t\t\t// Add tool responses\r\n\t\t\t\tfor (let i = 0; i < calls.length; i++) {\r\n\t\t\t\t\tconst tool = calls[i];\r\n\t\t\t\t\tconst result = await onCall(tool);\r\n\t\t\t\t\tif (result){\r\n\t\t\t\t\t\tlet content=JSON.stringify(result);\r\n\t\t\t\t\t\trohaHistory.push({\r\n\t\t\t\t\t\t\trole: \"tool\",\r\n\t\t\t\t\t\t\ttool_call_id: toolCalls[i].id,\r\n\t\t\t\t\t\t\tname: tool.function.name,\r\n\t\t\t\t\t\t\tcontent\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\techo(\"no oncall result\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn relay(); // Recursive call to process tool results\r\n\t\t\t}\r\n\t\t\treply = choice.message.content;\r\n\t\t\tif (roha.config && roha.config.ansi) {\r\n//\t\t\t\techo(ansiSaveCursor);\r\n\t\t\t\tprint(mdToAnsi(reply));\r\n//\t\t\t\techo(ansiRestoreCursor);\r\n\t\t\t} else {\r\n\t\t\t\tprint(wordWrap(reply));\r\n\t\t\t}\r\n\t\t}\r\n\t\trohaHistory.push({ role: \"assistant\", content: reply });\r\n\t} catch (error) {\r\n\t\tlet line=error.message || String(error);\r\n\t\t//Error during API call: Error: 400 \"This model's maximum prompt length is 131072 but the request contains 165547 tokens.\"\r\n\t\tif(line.includes(\"maximum prompt length\")){\r\n\t\t\techo(\"maximum prompt length exceeded, switch model or drop shares to continue\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconsole.error(\"Error during API call:\", error);\t\r\n\t\tif(grokFunctions){\r\n\t\t\techo(\"resetting grokFunctions\")\r\n\t\t\tgrokFunctions=false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nasync function chat() {\r\n\tdance:\r\n\twhile (true) {\r\n\t\tlet lines=[];\r\n//\t\techo(ansiMoveToEnd);\r\n\t\twhile (true) {\r\n\t\t\tawait flush();\r\n\t\t\tlet line=\"\";\r\n\t\t\tif(listCommand){\r\n\t\t\t\tline=await prompt2(\"#\");\r\n\t\t\t\tif(line.length && !isNaN(line)){\r\n\t\t\t\t\tlet index=line|0;\r\n\t\t\t\t\tawait callCommand(listCommand+\" \"+index);\r\n\t\t\t\t}\r\n\t\t\t\tlistCommand=\"\";\r\n\t\t\t}else{\r\n\t\t\t\tline=await prompt2(rohaPrompt);\r\n\t\t\t}\r\n\t\t\tif (line === '') {\r\n\t\t\t\tif(roha.config.returntopush && !lines.length) {\r\n\t\t\t\t\techo(\"auto pushing...\");\r\n\t\t\t\t\tawait callCommand(\"push\");\r\n\t\t\t\t\tawait relay();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (line === \"exit\") {\r\n\t\t\t\techo(\"Ending the conversation...\");\r\n\t\t\t\tbreak dance;\r\n\t\t\t}\r\n\t\t\tif (line.startsWith(\"/\")) {\r\n\t\t\t\tconst command = line.substring(1).trim();\r\n\t\t\t\tlet dirty=await callCommand(command);\r\n\t\t\t\tif(dirty){\r\n\t\t\t\t\tlines.push(\"Please review source for bugs and all content if notable changes detected, thanks.\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlines.push(line.trim());\r\n\t\t}\r\n\r\n\t\tif (lines.length){\r\n\t\t\tconst query=lines.join(\"\\n\");\r\n\t\t\tif(query.length){\r\n\t\t\t\trohaHistory.push({ role: \"user\", content: query });\r\n\t\t\t\tawait relay();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nDeno.addSignalListener(\"SIGINT\", () => {Deno.exit(0);});\r\n\r\n//only windows Deno.addSignalListener(\"SIGBREAK\", () => {echo(\"SIGBREAK\");});\r\n\r\nawait runCode(\"isolation/test.js\",\"isolation\");\r\n\r\nchat();\r\n\n{\"path\":\"C:/nitrologic/foundry/release/accounts.json\",\"length\":362,\"type\":\"application/json; charset=UTF-8\"}\n{\r\n\t\"gemini\":{\r\n\t\t\"env\":\"GEMINI_API_KEY\",\r\n\t\t\"url\":\"https://generativelanguage.googleapis.com/v1beta/openai\"\r\n\t},\r\n\t\"deepseek\":{\r\n\t\t\"env\":\"DEEPSEEK_API_KEY\",\r\n\t\t\"url\":\"https://api.deepseek.com\"\r\n\t},\r\n\t\"xai\": {\r\n\t\t\"env\": \"XAI_API_KEY\",\r\n\t\t\"url\": \"https://api.x.ai/v1\"\r\n\t},\r\n\t\"openai\": {\r\n\t\t\"env\": \"OPENAI_API_KEY\",\r\n\t\t\"url\": \"https://api.openai.com/v1\"\r\n\t}\r\n  }\r\n\n{\"path\":\"C:/nitrologic/foundry/release/foundry.md\",\"length\":2601,\"type\":\"text/markdown; charset=UTF-8\"}\n# foundry command line client\r\n\r\nA command line application designed to chat and share files.\r\n\r\n## foundry machine interface\r\n\r\nThe foundry functional interface uses tools and tool_calls.\r\n\r\nOnly recent models provide tools interface, foundry should fall \r\nback to a no tools completion mode.\r\n\r\nSee the OpenAI API spec for more tool role details.\r\n\r\n### read_time\r\n\r\n### submit_file\r\n\r\n### annotate_foundry\r\n\r\n## foundry user interface\r\n\r\ncommands with no arguments may often prompt for a # index from\r\nthe items displayed\r\n\r\n### /config\r\n\r\nToggle configuration flags.\r\n\r\nAdjust settings to suit current preferences.\r\n\r\nDefault values are typically:\r\n\r\n* 0 commitonstart : commit shared files on start : true\r\n* 1 ansi : markdown ANSI rendering : true\r\n* 2 slow : output at reading speed : true\r\n* 3 verbose : emit debug information : true\r\n* 4 broken : ansi background blocks : false\r\n* 5 logging : log all output to file : true\r\n* 6 resetcounters : at reset zero all counters : true\r\n\r\n### /share\r\n\r\nShare a file or folder with optional tag.\r\n\r\nFiles are added to the share list used by the /push /commit command.\r\n\r\n### /drop\r\n\r\nDrop all files currently shared\r\n\r\n### /push /commit\r\n\r\nRefresh shared files. \r\n\r\nDetects changes or deletions and updates the chat history.\r\n\r\nPosts new versions of file content if modified.\r\n\r\n### /reset\r\n\r\nClear all shared files and conversation history.\r\n\r\n### /history\r\n\r\nList a summary of recent conversation entries. \r\n\r\nProvides a quick overview of chat history.\r\n\r\n### /cd\r\n\r\nChange the working directory. \r\n\r\nUser can navigate to a desired directory for file operations.\r\n\r\n### /dir\r\n\r\nList the contents of the current working directory. \r\n\r\nHelps user view available files and folders to share.\r\n\r\n\r\n### /model\r\n\r\nSelect an AI model.\r\n\r\nUser can choose a model by name or index from the accounts available.\r\n\r\n### /counters\r\n\r\nList the internal application counters.\r\n\r\n### /tag\r\n\r\nDescribe all tags in use.\r\n\r\nDisplays tag name, count of shares tagged and description.\r\n\r\n### /account\r\n\r\nDisplay current account information.\r\n\r\n### /save [name]\r\n\r\nSave the current conversation history. \r\n\r\nCreates a snapshot file of the conversation.\r\n\r\nThe default name is currently .roa-save-HEX32_TIME.json\r\n\r\n### /load\r\n\r\nLoad a saved conversation history snapshot.\r\n\r\nUser can specify a save index or file name to restore previous chats.\r\n\r\n\r\n### /time\r\n\r\nDisplay the current system time. \r\n\r\nHelps user verify system status.\r\n\r\n### /help\r\n\r\nIf you are reading this file, it may be due to the use of this command.\r\n\r\nIf you still need help visit the project page.\r\n\n{\"path\":\"C:/nitrologic/foundry/release/LICENSE.txt\",\"length\":1753,\"type\":\"text/plain; charset=UTF-8\"}\nMIT License\r\n\r\nCopyright (c) 2025 Simon Armstrong\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is                                            \r\nfurnished to do so, subject to the following conditions:                                                         \r\n                                                                                                                 \r\nThe above copyright notice and this permission notice shall be included in all                                   \r\ncopies or substantial portions of the Software.                                                                  \r\n                                                                                                                 \r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                       \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                         \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                                      \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                           \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                                    \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE                                    \r\nSOFTWARE. \n{\"path\":\"C:/nitrologic/foundry/release/welcome.txt\",\"length\":481,\"type\":\"text/plain; charset=UTF-8\"}\npreceed with caution\r\n\r\n  o---/\\     /---o     \\---/     /---/\\     o---/\\     \\---o     /---/\\ \r\n  |    \\/   /    |     |    /   /    \\/    |    \\/   /    |     |    \\/ \r\n#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #\r\n\r\n\tWELCOME TO FOUNDRY\r\n\r\n\tA COMMAND LINE TOOL FOR CHATTING AND SHARING FILES\r\n\r\n\tTHE MAGIC WORD IS HAPUKA\r\n\r\n\tTHIS FILE IS PART OF THE ROHA CLIENT DISTRIBUTION\r\n\r\n#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #\r\n\n{\"path\":\"C:/nitrologic/foundry/release/forge/readme.txt\",\"length\":67,\"type\":\"text/plain; charset=UTF-8\"}\nlocal storage for shared files submitted for review by foundry rc1\n\n{\"path\":\"C:/nitrologic/foundry/release/isolation/readme.txt\",\"length\":103,\"type\":\"text/plain; charset=UTF-8\"}\na sandbox for foundry rc1 runs\r\n\r\nrun foundry run\r\n\r\nthis stuff is post rc1 - what is going on here?\r\n \n{\"path\":\"C:/nitrologic/foundry/release/isolation/test.js\",\"length\":180,\"type\":\"application/javascript; charset=UTF-8\"}\n\r\nfunction hexDate(){\r\n    let s=Date.now()/1e3|0;\r\n    return s.toString(16);\r\n}\r\n\r\nconsole.log(\"radio   live transmission\");\r\n\r\nconsole.log(hexDate());\r\nconsole.log(hexDate());\r\n\n{\"path\":\"C:/nitrologic/foundry/.gitignore\",\"length\":55,\"type\":\"application/octet-stream\",\"mimeType\":\"application/octet-stream\"}\nFile content: MIME=application/octet-stream, Base64=Zm91bmRyeS5sb2cKZm91bmRyeS5qc29uCnNhdmVzCnJlbGVhc2UKcmMxL2ZvdW5kcnkuZXhlCg==\n{\"path\":\"C:/nitrologic/foundry/build.bat\",\"length\":88,\"type\":\"application/x-msdownload\"}\ndeno compile --allow-run --allow-env --allow-net --allow-read --allow-write foundry.js\r\n\ni would like to prepare a report on the nitrologic foundry client\nBelow is a draft report on the Nitrologic Foundry Client:\n\n─────────────────────────────────────────────  \nNitrologic Foundry Client Report  \n─────────────────────────────────────────────\n\n1. Overview\n\nThe Nitrologic Foundry Client is a command‑line research client designed to interact with language models and manage file sharing. Written in JavaScript/TypeScript for execution with Deno, the client leverages several permissions (run, env, net, read, write) and is intended for experimentation with model evaluations, conversation histories, and file submission workflows.\n\n2. Key Features\n\n• Chat Interface and History Management  \n – The client provides an interactive prompt (using raw mode via Deno’s stdin reader) that accepts chat messages and commands.  \n – It maintains a conversation history (“rohaHistory”) for both user queries and model responses, allowing for conversation snapshots and history restoration via save and load functionality.  \n – A “relay” function communicates with model endpoints (using the OpenAI client libraries and several API providers such as GEMINI, DEEPSEEK, XAI, and OpenAI) and appears to support models that have tool call capabilities.\n\n• File Sharing and Submission  \n – The “/share” command enables users to designate files or directories for sharing. Individual files are processed (for text, JSON, markdown, etc.) or converted to Base64 for binary content.  \n – A sharing mechanism tracks file metadata (path, size, modification time, hash) and tags shared files.  \n – The client supports a “/push” or “/commit” command that scans shared files, detects modifications or deletions, and—if changes are detected—updates the chat history and files submitted for review.\n\n• Configuration and Customization  \n – Several configuration flags allow toggling features such as committing shares on start, ANSI rendering of markdown, slow output, verbose debugging information, and logging (to a file “foundry.log”).  \n – The “/config” command lists available flags, which include:  \n  • commitonstart  (commit shared files on start)  \n  • tools        (enable model tool interface)  \n  • ansi         (render using ANSI/markdown)  \n  • slow         (output at reading speed)  \n  • verbose       (emit debug information)  \n  • broken        (ansi background blocks via alternate colors)  \n  • logging       (log all output to file)  \n  • resetcounters  (reset counters on reset)  \n  • returntopush  (prompt to “push” when returning)\n\n• Model Management and Tooling Interface  \n – The client supports selecting models via the “/model” command. The list of available models is gathered from multiple API endpoints (configured in the “accounts.json” file) and stored in a list (“modelList”).  \n – It uses tool call functions if the selected model supports the tools interface. Three tool functions are defined:  \n  ○ read_time – returns current UTC time.  \n  ○ submit_file – submits a file for review by sending content type and file content, saving the file to a “forge” directory.  \n  ○ annotate_foundry – permits setting descriptions on objects like tags or shared files.  \n – The “relay” function is responsible for interfacing with the model. It prepares the payload (using either the simple chat history or a tool call JSON structure) and recursively handles tool call responses by executing the corresponding functions (via “onCall”) before forwarding the results back into the conversation cycle.\n\n3. Architecture and Workflow\n\n• Initialization and Configuration  \n – On startup, the client checks for a “foundry.json” state file, creating one with default settings if not present.  \n – It reads “accounts.json” to establish connections with the configured AI endpoints; these connections use API keys from environment variables.  \n – The client also initializes conversation history (rohaHistory) with a system prompt (“I am testing foundry client. You are a helpful assistant”).\n\n• File and Directory Operations  \n – Commands such as “/cd” and “/dir” allow the user to manage current working directories – aiding in file selection for sharing.  \n – The client uses Deno APIs for file operations, including reading, writing, statting files, and computing file hashes using SHA‑256.\n\n• Command Processing  \n – Input lines that begin with a “/” are interpreted as commands. Otherwise, they are treated as chat messages from the user.  \n – A command “callCommand” function handles a wide range of commands: listing accounts, toggling configuration flags, sharing files, managing tags, and handling model selection.\n – Commands such as “/reset” clear shared files and conversation history; “/history” lists recent conversation activities; “/save” and “/load” allow the user to persist or restore sessions.\n\n• ANSI and Markdown Rendering  \n – The client can render markdown content with ANSI escape sequences for styling (headers, bold, italics, bullets).  \n – There is a fallback plain output mode if ANSI rendering is not enabled.\n\n• Isolation and Sandbox Execution  \n – A helper function “isolateCode” is provided to run external JavaScript code (from an “isolation/test.js” file) in a sandboxed environment with restricted permissions. This supports a “runCode” routine that demonstrates isolated execution.\n\n4. Additional Files and Documentation\n\n• foundry.md – This markdown file provides an overview of the available commands and the machine interface (tool calls) for the client.\n• welcome.txt – A welcome banner displayed on startup.\n• LICENSE.txt and build.bat – These files establish project licensing (MIT License) and build instructions for compiling the Deno application.\n• The “forge” subdirectory is used for storing file submissions and conversation snapshots.\n• The “isolation” subdirectory contains a sandbox for testing code execution, distinct from the main workflow.\n\n5. Summary\n\nThe Nitrologic Foundry Client is a robust research tool designed for interacting with language models while integrating file sharing and conversation management. With its modular tool calls, command interface, and detailed configuration options, it becomes a flexible environment for testing model capabilities – particularly for those models that support an interactive tools interface. The design elegantly combines interactive terminal I/O, file system operations, and API integrations in a portable Deno runtime environment.\n\n─────────────────────────────────────────────  \nConcluding Remarks\n\nThe Foundry Client, as demonstrated by the provided source code and accompanying materials, reflects thoughtful design aimed at research and interactive testing. Its support for both chat-based interactions and contextual file sharing makes it well suited for scenarios where version tracking and iterative model evaluation are needed. Future enhancements—such as improved error handling, richer command completion (e.g., arrow navigation), and expanded tool integrations—could further extend its capabilities.\n\n─────────────────────────────────────────────  \nEnd of Report\n\nFeel free to adjust or expand any sections as needed for your reporting purposes.\nno way to verbose\nBelow is a report summarizing and analyzing the Nitrologic Foundry Client based on the source code and accompanying documentation.\n\n─────────────────────────────────────────────  \nNitrologic Foundry Client Report  \n─────────────────────────────────────────────\n\n1. Overview\n\nThe Nitrologic Foundry Client is an experimental command‑line research tool built on Deno. It is designed to facilitate model evaluation, interactive chat sessions, and file sharing. The client interacts with multiple language model endpoints (such as those provided by OpenAI, Deepseek, Gemini, and XAI) and supports both chat and file submission through a unified interface.\n\n2. Key Features\n\n• Interactive Chat Interface and Conversation History  \n – The client runs in a terminal and uses raw input mode to capture user commands and messages.  \n – Conversation history is maintained in an array (“rohaHistory”), starting with a system prompt that defines the client’s role.  \n – Users may save and reload conversation sessions, allowing for persistent session management.\n\n• File Sharing and Commit Workflow  \n – The “/share” command allows a user to submit either files or entire directories.  \n – Shared files are tracked via metadata including file path, size, modification time, and a computed SHA‑256 hash.  \n – A “/push” (or “/commit”) command scans the shared files for modifications or deletions, updates history, and integrates file “submissions” into the conversation for review.\n\n• Configurable Options and Command Set  \n – Multiple configuration flags control aspects such as:  \n  • Automatic file commit on start  \n  • ANSI-based markdown rendering for enhanced terminal output  \n  • Slow reading (output pacing), verbose logging, and even special “broken” modes for ANSI blocks  \n – Commands such as “/config” allow users to toggle these features.  \n – Additional commands include “/cd” (to change directory), “/dir” (to list files), “/model” (to select or switch language models), and “/reset” (to clear history and file shares).\n\n• Model and Tool Functionality  \n – The client supports model interactions using a “relay” function that sends the conversation history as a payload to the selected model endpoint.  \n – Some models support “tool calls,” and the client defines three tool functions:  \n  ○ read_time – Returns the current UTC time  \n  ○ submit_file – Accepts content and its MIME type to save a file in the local “forge” directory  \n  ○ annotate_foundry – Lets the user annotate or set descriptions on file shares or tags  \n – These tools support enhanced interactions when the underlying model can invoke external functions during a conversation.\n\n• ANSI and Markdown Rendering  \n – The client renders markdown content using ANSI escape sequences (for headers, bold, italics, and bullet lists), improving readability in terminal outputs when enabled.  \n – A fallback plain text mode is available if ANSI rendering is turned off.\n\n• Sandbox Code Execution  \n – A dedicated “isolation” module demonstrates running external JavaScript code in an isolated environment with limited permissions. This reinforces the client’s role as a research and testing platform.\n\n3. Architecture and Workflow\n\n• Initialization and Startup  \n – On launch, the client checks for a persistent state file (“foundry.json”). If not found, it creates a default configuration.  \n – It reads an “accounts.json” file to load provider configurations and uses environment variables to obtain API keys for connecting to endpoints.\n\n• Conversation Handling  \n – User input is processed in two categories: commands (prefixed with “/”) and regular chat messages.  \n – The “callCommand” function handles a variety of commands (e.g., file management, configuration toggles, model selection) and directs appropriate actions.  \n – The “relay” function packages the chat history (or a squashed version of it) and sends it to the AI endpoint using either a simple completion or a tool invocation model, with recursive handling of tool responses as needed.\n\n• File and Directory Management  \n – The client uses Deno’s filesystem API to change directories (“/cd”), list directory contents (“/dir”), and compute file hash values for file integrity checking.  \n – Shared files are maintained in an internal list (roha.sharedFiles) and include optional tags that can be annotated post sharing.\n\n• Configurability and Logging  \n – The client supports multiple configuration options stored within the state file, allowing toggles for behaviors such as automatic commit at startup and slow output pacing.  \n – There is also an option to log all output to a “foundry.log” file.\n\n4. Supporting Files and Documentation\n\n• foundry.md – A markdown document that describes available commands and the machine interface (tool calls) for the client.  \n• welcome.txt – Provides a graphical welcome message on startup.  \n• LICENSE.txt – Contains the MIT License terms under which the source is released.  \n• build.bat – A batch script to compile the application using Deno’s compile command, ensuring necessary permissions are granted.  \n• The “forge” directory – A local repository for submitted files and session snapshots.  \n• The “isolation” directory – Contains sandboxed test code that is executed at startup to verify isolated code execution capabilities.\n\n5. Summary and Concluding Remarks\n\nThe Nitrologic Foundry Client is a well-structured research tool merging interactive chat, file management, and model tool-call support. Its versatility lies in the ability to manage conversation sessions, track and submit file changes, and toggle between different aspects of its behavior with a simple command interface. The modular design—combining terminal I/O, file system manipulation, and API integration via Deno—makes it a useful platform for model evaluation and interactive research.\n\nFuture enhancements might include richer command-line navigation (such as arrow key support and auto-completion), improved error handling around API calls, and greater configurability for advanced users. As it stands, the Foundry Client provides a compelling example of combining AI interactivity with common file management tasks in a terminal-based environment.\n\n─────────────────────────────────────────────  \nEnd of Report\n\nFeel free to adjust or expand upon these sections based on further testing or additional project requirements.\nwould a git history of the original project help with a report on each functional block of code added to foundry.js\n// foundry.js\r\n// a research client for evaluating models\r\n// (c)2025 Simon Armstrong\r\n\r\n// deno run --allow-run --allow-env --allow-net --allow-read --allow-write roha.js\r\n\r\nimport { contentType } from \"https://deno.land/std@0.224.0/media_types/mod.ts\";\r\nimport { resolve } from \"https://deno.land/std/path/mod.ts\";\r\nimport OpenAI from \"https://deno.land/x/openai@v4.67.2/mod.ts\";\r\n\r\nconst foundryVersion = \"rc1\";\r\nconst rohaTitle=\"foundry \"+foundryVersion;\r\nconst rohaMihi=\"I am testing foundry client. You are a helpful assistant.\";\r\n\r\nconst slowMillis = 20;\r\n\r\nconst decoder = new TextDecoder(\"utf-8\");\r\nconst encoder = new TextEncoder();\r\n\r\nconst terminalColumns=120;\r\n\r\nconst flagNames={\r\n\tcommitonstart : \"commit shared files on start\",\r\n\ttools : \"enable model tool interface\",\r\n\tansi : \"markdown ANSI rendering\",\r\n\tslow : \"output at reading speed\",\r\n\tverbose : \"emit debug information\",\r\n\tbroken : \"ansi background blocks\",\r\n\tlogging : \"log all output to file\",\r\n\tresetcounters : \"factory reset when reset\",\r\n\treturntopush : \"hit return to /push - it is under test\"\r\n};\r\n\r\nconst emptyRoha={\r\n\tconfig:{\r\n\t\tcommitonstart:true,\r\n\t\tansi:true,\r\n\t\tslow:false,\r\n\t\tverbose:false,\r\n\t\tbroken:false,\r\n\t\tlogging:false,\r\n\t\tresetcounters:false,\r\n\t\treturntopush:false\r\n\t},\r\n\ttags:{},\r\n\tmodels:{},\r\n\tband:{},\r\n\tsharedFiles:[],\r\n\tsaves:[],\r\n\tcounters:{}\r\n};\r\n\r\nfunction addBand(){\r\n\tlet id=\"member\"+increment(\"members\");\r\n\troha.band[id]={};\r\n}\r\n\r\nfunction listBand(){\r\n\tlet band=[];\r\n\tfor(let id in roha.band){\r\n\t\tlet member=roha.band[id];\r\n\t\tband.push(member);\r\n\t}\r\n\tband.push(\"add\");\r\n\tfor(let i=0;i<band.length;i++){\r\n\t\techo(i,band[i]);\r\n\t}\r\n\tmemberList=band;\r\n}\r\n\r\nfunction annotateTag(name,description){\r\n\tif(!name){\r\n\t\tthrow(\"null name\");\r\n\t}\r\n\tif(!(name in roha.tags)) {\r\n\t\troha.tags[name]={};\r\n//\t\tthrow(\"tag not found \"+name);\r\n\t}\r\n\troha.tags[name].description=description;\r\n}\r\n\r\nfunction annotateShare(name,description){\r\n\tlet index=roha.sharedFiles.findIndex(item => item.id === name);\r\n\tif(index==-1) throw(\"share id not found\");\r\n\troha.sharedFiles[index].description=description;\r\n\techo(\"file share description annotated\");\r\n}\r\n\r\nfunction increment(key){\r\n\tlet i=0;\r\n\tif(key in roha.counters){\r\n\t\ti=roha.counters[key]+1;\r\n\t}\r\n\troha.counters[key]=i;\r\n\treturn i\r\n}\r\n\r\nvar tagList=[];\r\nvar modelList=[];\r\nvar shareList=[]; //typically biggest to smallest\r\nvar memberList=[];\r\n\r\nconst emptyModel={\r\n\tname:\"empty\",account:\"\",hidden:false,prompts:0,completion:0\r\n}\r\n\r\nconst emptyTag={\r\n}\r\n\r\n// const emptyShare={path,size,modified,hash,tag,id}\r\n\r\nlet roha=emptyRoha;\r\nlet rohaCalls=0;\r\nlet listCommand=\"\";\r\nlet rohaShares=[];\r\nlet currentDir = Deno.cwd();\r\nvar rohaHistory;\r\n\r\nfunction resetHistory(){\r\n\trohaHistory = [{role:\"system\",content:rohaMihi}];\r\n}\r\n\r\nfunction listHistory(){\r\n\tlet history=rohaHistory;\r\n\tfor(let i=0;i<history.length;i++){\r\n\t\tlet item=history[i];\r\n\t\tlet content=readable(item.content).substring(0,90)\r\n\t\techo(i,item.role,item.name||\"foundry\",\"-\",content);\r\n\t}\r\n\tif(roha.config.broken){\r\n\t\tlet flat=squashMessages(rohaHistory);\r\n\t\tfor(let i=0;i<flat.length;i++){\r\n\t\t\tlet item=flat[i];\r\n\t\t\tlet content=readable(item.content).substring(0,90);\r\n\t\t\techo(\"flat\",i,item.role,item.name||\"broken\",content);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction rohaPush(content,name=\"foundry\"){\r\n\trohaHistory.push({role:\"user\",name,content});\r\n}\r\n\r\nresetHistory();\r\n\r\n// roaTools\r\n\r\nconst rohaTools = [{\r\n\ttype: \"function\",\r\n\tfunction:{\r\n\t\tname: \"read_time\",\r\n\t\tdescription: \"Returns current time in UTC\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {},\r\n\t\t\trequired: []\r\n\t\t}\r\n\t}\r\n},{\r\n\ttype: \"function\",\r\n\tfunction:{\r\n\t\tname: \"submit_file\",\r\n\t\tdescription: \"Submit a file for review\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {\r\n\t\t\t\tcontentType:{type:\"string\"},\r\n\t\t\t\tcontent:{type:\"string\"}\r\n\t\t\t},\r\n\t\t\trequired: [\"contentType\",\"content\"]\r\n\t\t}\r\n\t}\r\n},{\r\n\ttype: \"function\",\r\n\tfunction: {\r\n\t\tname: \"annotate_foundry\",\r\n\t\tdescription: \"Set description of any object\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {\r\n\t\t\t\tname: { type: \"string\" },\r\n\t\t\t\ttype: { type:\"string\" },\r\n\t\t\t\tdescription: { type: \"string\" }\r\n\t\t\t},\r\n\t\t\trequired: [\"name\",\"type\",\"description\"]\r\n\t\t}\r\n\t}\r\n}];\r\n\r\nasync function sleep(ms) {\r\n\tawait new Promise(function(resolve) {setTimeout(resolve, ms);});\r\n}\r\n\r\nfunction measure(o){\r\n\tlet total=JSON.stringify(o).length;\r\n\treturn total;\r\n}\r\n\r\nlet outputBuffer = [];\r\nlet printBuffer = [];\r\n\r\nfunction print(){\r\n\tlet args=arguments.length?Array.from(arguments):[];\r\n\tlet lines=args.join(\" \").split(\"\\n\");\r\n\tfor(let line of lines){\r\n\t\tprintBuffer.push(line.trimEnd());\r\n\t}\r\n}\r\n\r\nfunction echo(){\r\n\tlet args=arguments.length?Array.from(arguments):[];\r\n\tlet lines=args.join(\" \").split(\"\\n\");\r\n\tfor(let line of lines){\r\n\t\toutputBuffer.push(line.trimEnd());\r\n\t}\r\n}\r\n\r\nfunction stripAnsi(text) {\r\n\treturn text.replace(/\\x1B\\[\\d+(;\\d+)*[mK]/g, '');\r\n}\r\n\r\nasync function log(lines,id){\r\n\tif(roha.config.logging){\r\n\t\tconst time = new Date().toISOString();\r\n\t\tlet list=[];\r\n\t\tfor(let line of lines.split(\"\\n\")){\r\n\t\t\tline=stripAnsi(line);\r\n\t\t\tline=time+\" [\"+id+\"] \"+line+\"\\n\";\r\n\t\t\tlist.push(line);\r\n\t\t}\r\n\t\tawait Deno.writeTextFile(\"foundry.log\",list.join(),{append:true});\r\n\t}\r\n}\r\n\r\nasync function flush() {\r\n\tconst delay = roha.config.slow ? slowMillis : 0;\r\n\tfor (const line of printBuffer) {\r\n\t\tconsole.log(line);\r\n\t\tlog(line,\"model\");\r\n\t}\r\n\tprintBuffer=[];\r\n\tfor (const line of outputBuffer) {\r\n\t\tconsole.log(line);\r\n\t\tlog(line,\"stdout\");\r\n\t\tawait sleep(delay);\r\n\t}\r\n\toutputBuffer=[];\r\n}\r\n\r\nfunction wordWrap(text,cols=terminalColumns){\r\n\tvar result=[];\r\n\tvar pos=0;\r\n\twhile(pos<text.length){\r\n\t\tlet line=text.substring(pos,pos+cols);\r\n\t\tlet n=line.length;\r\n\t\tif(n==cols){\r\n\t\t\tvar i=line.lastIndexOf(\" \",n);\r\n\t\t\tif(i>0){\r\n\t\t\t\tline=line.substring(0,i);\r\n\t\t\t\tn=i+1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tresult.push(line);\r\n\t\tpos+=n;\r\n\t}\r\n\treturn result.join(\"\\n\");\r\n}\r\n\r\n// main roha application starts here\r\n\r\nconst MaxFileSize=65536;\r\n\r\nconst appDir = Deno.cwd();\r\nconst rohaPath = resolve(appDir,\"foundry.json\");\r\nconst accountsPath = resolve(appDir,\"accounts.json\");\r\nconst forgePath=resolve(appDir,\"forge\");\r\n\r\nconst modelAccounts = JSON.parse(await Deno.readTextFile(accountsPath));\r\n\r\nasync function pathExists(path) {\r\n\ttry {\r\n\t\tconst stat = await Deno.stat(path);\r\n\t\tif (!stat.isFile) return false;\r\n\t\treturn true;\r\n\t} catch (error) {\r\n\t\tif (error instanceof Deno.errors.NotFound) return false;\r\n\t\tif (error instanceof Deno.errors.PermissionDenied) return false;\r\n\t\tthrow error;\r\n\t}\r\n}\r\n\r\nconst fileExists = await pathExists(rohaPath);\r\nif (!fileExists) {\r\n\tawait Deno.writeTextFile(rohaPath, JSON.stringify(emptyRoha));\r\n\techo(\"Created new\",rohaPath);\r\n}\r\n\r\nconst rohaAccount={};\r\nfor(let account in modelAccounts){\r\n\tlet endpoint = await connectAccount(account);\r\n\tif(endpoint) rohaAccount[account]=endpoint;\r\n}\r\n\r\nfunction stringify(value, seen = new WeakSet(), keyName = \"\") {\r\n\tif (typeof value === \"string\") return value;\r\n\tif (value === null || typeof value !== \"object\") return String(value);\r\n\tif (typeof value === \"function\") return \"[function]\";\r\n\tif (seen.has(value)) return keyName ? `[circular (${keyName})]` :\"[circular]\";\r\n\tseen.add(value);\r\n\tif (Array.isArray(value)) {\r\n\t\tconst items = value.map((item, index) => stringify(item, seen,\r\n\t\tString(index)));\r\n\t\treturn `[${items.join(\",\\n\")}]`;\r\n\t}\r\n\tconst entries = Object.entries(value).map(([key, val]) => `${key}: ${stringify(val, seen, key)}`);\r\n\treturn `{${entries.join(\",\\n\")}}`;\r\n}\r\n\r\nasync function connectAccount(account) {\r\n\tlet verbose=false;//roha.config.verbose;\r\n\techo(\"Connecting to account:\", account);\r\n\tconst config = modelAccounts[account];\r\n\tif (!config) return null;\r\n\ttry{\r\n\t\tconst apiKey = Deno.env.get(config.env);\r\n\t\tconst endpoint = new OpenAI({ apiKey, baseURL: config.url });\r\n\t\tif(verbose){\r\n\t\t\tfor(const [key, value] of Object.entries(endpoint)){\r\n\t\t\t\tlet content=stringify(value);\r\n\t\t\t\techo(\"endpoint:\"+key+\":\"+content);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst models = await endpoint.models.list();\r\n\t\tconst list=[];\r\n\t\tfor (const model of models.data) {\r\n\t\t\tlet name=model.id+\"@\"+account;\r\n\t\t\tlist.push(name);\r\n\t\t\tif(verbose) echo(\"model - \",JSON.stringify(model,null,\"\\t\"));\r\n\t\t}\r\n\t\tlist.sort();\r\n\t\tmodelList=modelList.concat(list);\r\n\t\treturn endpoint;\r\n\t}catch(error){\r\n\t// Error: 429 \"Your team ac0a3c9a-0e58-4e3c-badd-be853c027a7f has either used all available credits or \r\n\t// reached its monthly spending limit. To continue making API requests, please purchase more credits or \r\n\t// raise your spending limit.\"\r\n\t\techo(error);\r\n\t}\r\n\treturn null;\r\n}\r\n\r\nasync function resetModel(name){\r\n\tgrokModel=name;\r\n\tgrokFunctions=true;\r\n\trohaHistory.push({role:\"system\",content:\"Model changed to \"+name+\".\"});\r\n\techo(\"with model\",name,grokFunctions)\r\n\tawait writeRoha();\r\n}\r\n\r\nfunction dropShares(){\r\n\tfor(let item of rohaHistory){\r\n\t\tif(item && item.role===\"user\" && item.user===\"forge\"){\r\n\t\t\titem.user=\"drop\";\r\n\t\t\titem.content=\"dropped path \"+(item.path||\"\");\t\t\t\r\n\t\t}\r\n\t}\r\n\trohaShares=[];\r\n\techo(\"all shares dropped\");\r\n}\r\n\r\nfunction listShare(){\r\n\tconst list=[];\r\n\tlet count=0;\r\n\tlet sorted = roha.sharedFiles.slice();\r\n\tsorted.sort((a, b) => b.size - a.size);\r\n\tfor (const share of sorted) {\r\n\t\tlet shared=(rohaShares.includes(share.path))?\"*\":\"\";\r\n\t\tlet tags=\"[\"+share.tag+\"]\";\r\n\t\tlet info=(share.description)?share.description:\"\";\r\n\t\techo((count++),share.path,share.size,shared,tags,info);\r\n\t\tlist.push(share.id);\r\n\t}\r\n\tshareList=list;\r\n}\r\n\r\nfunction listSaves(){\r\n\tlet saves=roha.saves||[];\r\n\tfor(let i=0;i<saves.length;i++){\r\n\t\techo(i,saves[i]);\r\n\t}\r\n}\r\n\r\nasync function saveHistory(name) {\r\n\ttry {\r\n\t\tlet timestamp=Math.floor(Date.now()/1000).toString(16);\r\n\t\tlet filename=(name||\"transmission-\"+timestamp)+\".json\";\r\n\t\tlet filePath = resolve(forgePath,filename);\r\n\t\tlet line=\"Saved session \"+filename+\".\";\r\n\t\trohaHistory.push({role:\"system\",content:line});\r\n\t\tawait Deno.writeTextFile(filePath,JSON.stringify(rohaHistory,null,\"\\t\"));\r\n\t\techo(line);\r\n\t\troha.saves.push(filename);\r\n\t\tawait writeRoha();\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error saving history:\", error.message);\r\n\t}\r\n}\r\n\r\nasync function loadHistory(filename){\r\n\tvar history;\r\n\ttry {\r\n\t\tconst fileContent = await Deno.readTextFile(filename);\r\n\t\thistory = JSON.parse(fileContent);\r\n\t\techo(\"History restored from \"+filename);\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error restoring history:\", error.message);\r\n\t\techo(\"console error\");\r\n\t\thistory=[{role:\"system\",content: \"You are a helpful assistant.\"}];\r\n\t}\r\n\treturn history;\r\n}\r\n\r\nconst ansiBackgrounds = [\r\n\t{ name: \"dark0\", code: \"\\x1b[48;5;232m\" }, // #1c2526\r\n\t{ name: \"dark1\", code: \"\\x1b[48;5;233m\" }, // #2e3436\r\n\t{ name: \"dark2\", code: \"\\x1b[48;5;234m\" }, // #3d4446\r\n\t{ name: \"dark3\", code: \"\\x1b[48;5;235m\" }, // #4e5456\r\n\t{ name: \"charcoal\", code: \"\\x1b[48;5;236m\" }, // #606668\r\n\t{ name: \"darkBlue\", code: \"\\x1b[48;5;17m\" }, // #00005f\r\n\t{ name: \"darkGreen\", code: \"\\x1b[48;5;23m\" }, // #003f3f\r\n\t{ name: \"darkMutedPurple\", code: \"\\x1b[48;5;54m\" }, // #5f00af\r\n\t{ name: \"veryDarkBlue\", code: \"\\x1b[48;5;18m\" }, // #000087\r\n\t{ name: \"darkCharcoal\", code: \"\\x1b[48;5;239m\" }, // #4e4e4e\r\n\t{ name: \"mutedNavy\", code: \"\\x1b[48;5;19m\" }, // #0000af\r\n\t{ name: \"deepGray\", code: \"\\x1b[48;5;240m\" } // #585858\r\n];\r\n\r\nconst ansiMoveToEnd = \"\\x1b[999B\";\r\nconst ansiSaveCursor = \"\\x1b[s\";\r\nconst ansiRestoreCursor = \"\\x1b[u\";\r\n\r\nconst ansiReplyBlock = ansiBackgrounds[0].code;\r\nconst ansiCodeBlock = ansiBackgrounds[6].code;\r\n\r\nconst rohaPrompt=\">\";\r\n\r\nconst ansiItalics = \"\\x1b[3m\";\r\nconst ansiReset = \"\\x1b[0m\";\r\nconst ansiPurple = \"\\x1b[1;35m\";\r\n\r\nfunction mdToAnsi(md) {\r\n\tlet broken=roha.config.broken;\r\n\tconst lines = md.split(\"\\n\");\r\n\tlet inCode = false;\r\n\tconst result = broken?[ansiReplyBlock]:[];\r\n\tfor (let line of lines) {\r\n\t\tline=line.trimEnd();\r\n\t\tlet trim=line.trim();\r\n\t\tif (trim.startsWith(\"```\")) {\r\n\t\t\tinCode = !inCode;\r\n\t\t\tif(inCode){\r\n\t\t\t\tresult.push(ansiCodeBlock);\r\n\t\t\t\tlet codeType=trim.substring(3);\r\n\t\t\t\techo(\"inCode \"+codeType);\r\n\t\t\t}else{\r\n\t\t\t\tif (broken) result.push(ansiReplyBlock);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif (!inCode) {\r\n\t\t\t\t// headershow\r\n\t\t\t\tconst header = line.match(/^#+/);\r\n\t\t\t\tif (header) {\r\n\t\t\t\t\tconst level = header[0].length;\r\n\t\t\t\t\tline = line.substring(level).trim();\r\n\t\t\t\t\tline = ansiPurple + line + ansiReset;\r\n\t\t\t\t}\r\n\t\t\t\t// bullets\r\n\t\t\t\tif (line.startsWith('-') || line.startsWith('*') || line.startsWith('+')) {\r\n\t\t\t\t\tline = '• ' + line.substring(1).trim();\r\n\t\t\t\t}\r\n\t\t\t\t// bold\r\n\t\t\t\tif (line.includes(\"**\")) {\r\n\t\t\t\t\tline = line.replace(/\\*\\*(.*?)\\*\\*/g, \"\\x1b[1m$1\\x1b[0m\");\r\n\t\t\t\t}\r\n\t\t\t\t// italic\r\n\t\t\t\tline = line.replace(/\\*(.*?)\\*/g, \"\\x1b[3m$1\\x1b[0m\");\r\n\t\t\t\tline = line.replace(/_(.*?)_/g, \"\\x1b[3m$1\\x1b[0m\");\r\n\t\t\t\t// wordwrap\r\n\t\t\t\tline=wordWrap(line,terminalColumns);\r\n\t\t\t}\r\n\t\t\tresult.push(line.trimEnd());\r\n\t\t}\r\n\t}\r\n\tresult.push(ansiReset);\r\n\treturn result.join(\"\\n\");\r\n}\r\n\r\nasync function hashFile(filePath) {\r\n\tconst fileContent = await Deno.readFile(filePath);\r\n\tconst hashBuffer = await crypto.subtle.digest(\"SHA-256\", fileContent);\r\n\tconst hashArray = new Uint8Array(hashBuffer);\r\n\treturn Array.from(hashArray).map(byte => byte.toString(16).padStart(2, '0')).join('');\r\n}\r\n\r\nasync function readRoha(){\r\n\ttry {\r\n\t\tconst fileContent = await Deno.readTextFile(rohaPath);\r\n\t\troha = JSON.parse(fileContent);\r\n\t\tif(!roha.saves) roha.saves=[];\r\n\t\tif(!roha.counters) roha.counters={};\r\n\t\tif(!roha.band) roha.band={};\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error reading or parsing\",rohaPath,error);\r\n\t\troha=emptyRoha;\r\n\t}\r\n}\r\n\r\nasync function writeRoha(){\r\n\ttry {\r\n\t\troha.model=grokModel;\r\n\t\tawait Deno.writeTextFile(rohaPath, JSON.stringify(roha, null, \"\\t\"));\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error writing\",rohaPath,error);\r\n\t}\r\n}\r\n\r\nasync function resetRoha(){\r\n\trohaShares = [];\r\n\troha.sharedFiles=[];\r\n\troha.tags={};\r\n\tif(roha.config.resetcounters) roha.counters={};\r\n\tincrement(\"resets\");\r\n\tawait writeRoha();\r\n\tresetHistory();\r\n\techo(\"resetRoha\",\"All shares and history reset.\");\r\n}\r\n\r\nfunction resolvePath(dir,filename){\r\n\tlet path=resolve(dir,filename);\r\n\tpath = path.replace(/\\\\/g, \"/\");\r\n\treturn path;\r\n}\r\n\r\n// a raw mode prompt replacement\r\n\r\n// arrow navigation and tab completion incoming\r\n\r\nconst reader = Deno.stdin.readable.getReader();\r\nconst writer = Deno.stdout.writable.getWriter();\r\n\r\nasync function prompt2(message) {\r\n\tif (message) {\r\n\t\tawait writer.write(encoder.encode(message));\r\n\t\tawait writer.ready;\r\n\t}\r\n\tDeno.stdin.setRaw(true);\r\n\tlet inputBuffer = new Uint8Array(0);\r\n\ttry {\r\n\t\twhile (true) {\r\n\t\t\tconst { value, done } = await reader.read();\r\n\t\t\tif (done || !value) break;\r\n\t\t\tfor (const byte of value) {\r\n\t\t\t\tif (byte === 0x7F || byte === 0x08) { // Backspace\r\n\t\t\t\t\tif (inputBuffer.length > 0) {\r\n\t\t\t\t\t\tinputBuffer = inputBuffer.slice(0, -1);\r\n\t\t\t\t\t\tawait writer.write(new Uint8Array([0x08, 0x20, 0x08])); // Erase last char\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (byte === 0x1b) { // Escape sequence\r\n\t\t\t\t\tif(value.length==1){\r\n\t\t\t\t\t\tDeno.exit(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(value.length==3){\r\n\t\t\t\t\t\tif(value[1]==0xf4 && value[2]==0x50){\r\n\t\t\t\t\t\t\techo(\"F1\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (byte === 0x0A || byte === 0x0D) { // Enter key\r\n\t\t\t\t\tawait writer.write(encoder.encode(\"\\r\\n\"));\r\n\t\t\t\t\tlet line = decoder.decode(inputBuffer);\r\n\t\t\t\t\tline=line.trim();\r\n\t\t\t\t\tlog(line,\"stdin\");\r\n\t\t\t\t\treturn line;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tawait writer.write(new Uint8Array([byte]));\r\n\t\t\t\t\tconst buf = new Uint8Array(inputBuffer.length + 1);\r\n\t\t\t\t\tbuf.set(inputBuffer);\r\n\t\t\t\t\tbuf[inputBuffer.length] = byte;\r\n\t\t\t\t\tinputBuffer = buf;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} finally {\r\n\t\tDeno.stdin.setRaw(false);\r\n\t}\r\n}\r\n\r\n// callers to addShare expected to await writeRoha after\r\n\r\nconst eventList=[];\r\n\r\nasync function watchPaths(paths,handler){\r\n\tconst watcher = Deno.watchFs(paths,{recursive:false});\r\n\tfor await (const event of watcher) {\r\n\t\teventList.push(event);\r\n\t}\r\n}\r\n\r\nasync function addShare(share){\r\n\tshare.id=\"share\"+increment(\"shares\");\r\n\troha.sharedFiles.push(share);\r\n\tif(share.tag) {\r\n\t\tawait setTag(share.tag,share.id);\r\n\t}\r\n}\r\n\r\nasync function shareDir(dir,tag) {\r\n\ttry {\r\n\t\tconst paths=[];\r\n\t\tconst files = await Deno.readDir(dir);\r\n\t\tfor await (const file of files) {\r\n\t\t\tif (file.isFile && !file.name.startsWith(\".\")) {\r\n\t\t\t\tpaths.push(resolvePath(dir, file.name));\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const path of paths) {\r\n//\t\t\techo(\"statting path:\"+path+\":\");\r\n\t\t\tconst info = await Deno.stat(path);\r\n\t\t\tlet size=info.size;\r\n\t\t\tlet modified=info.mtime.getTime();\r\n\t\t\tconst hash = await hashFile(path);\r\n\t\t\tawait addShare({path,size,modified,hash,tag})\r\n\t\t}\r\n\t\tawait writeRoha(); // TODO: check a dirty flag\r\n\t} catch (error) {\r\n\t\tconsole.error(\"### Error\"+error);\r\n\t}\r\n}\r\n\r\nfunction fileType(extension){\r\n\treturn contentType(extension) || 'application/octet-stream';\r\n}\r\n\r\nconst textExtensions = [\r\n\t\"js\", \"txt\", \"json\", \"md\",\r\n\t\"css\",\"html\", \"svg\",\r\n\t\"cpp\", \"c\", \"h\", \"cs\",\r\n\t\"sh\", \"bat\",\r\n\t\"log\",\"py\",\"csv\",\"xml\",\"ini\"\r\n];\r\n\r\nasync function shareFile(path,tag) {\r\n\tlet fileContent=null;\r\n\ttry {\r\n\t\tfileContent = await Deno.readFile(path);\r\n\t} catch (error) {\r\n\t\tconsole.error(\"shareFile path:\"+path+\" error:\", error);\r\n\t\treturn;\r\n\t}\r\n\tif(path.endsWith(\"rules.txt\")){\r\n\t\tlet lines=decoder.decode(fileContent).split(\"\\n\");\r\n\t\tfor(let line of lines ){\r\n\t\t\tif (line) rohaHistory.push({role:\"system\",content: line});\r\n\t\t}\r\n\t}else{\r\n\t\tconst length=fileContent.length;\r\n\t\tif(length>0 && length<MaxFileSize){\r\n\t\t\tconst extension = path.split('.').pop();\r\n\t\t\tconst type = fileType(extension);\r\n\t\t\tif (textExtensions.includes(extension)) {\r\n\t\t\t\tlet txt = decoder.decode(fileContent);\r\n\t\t\t\tif(txt.length){\r\n\t\t\t\t\tlet metadata=JSON.stringify({path,length,type,tag});\r\n\t\t\t\t\trohaPush(metadata);\r\n\t\t\t\t\trohaPush(txt,\"forge\");\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tconst base64Encoded = btoa(String.fromCharCode(...new Uint8Array(fileContent)));\r\n\t\t\t\tconst mimeType = fileType(extension);\r\n\t\t\t\tlet metadata=JSON.stringify({path,length,type,mimeType,tag});\r\n\t\t\t\trohaPush(metadata);\r\n\t\t\t\tlet binary=`File content: MIME=${mimeType}, Base64=${base64Encoded}`;\r\n\t\t\t\trohaPush(binary,\"forge\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n//\tif(roha.config.verbose)echo(\"roha shared file \" + path);\r\n\tif (!rohaShares.includes(path)) rohaShares.push(path);\r\n}\r\n\r\nasync function commitShares(tag) {\r\n\tlet dirty = false;\r\n\tconst validShares = [];\r\n\tconst removedPaths = [];\r\n\tfor (const share of roha.sharedFiles) {\r\n\t\tif (tag && share.tag !== tag) {\r\n\t\t\tvalidShares.push(share);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tconst info = await Deno.stat(share.path);\r\n\t\t\tconst modified = share.modified !== info.mtime.getTime();\r\n\t\t\tconst isShared = rohaShares.includes(share.path);\r\n\t\t\tif (modified || !isShared) {\r\n\t\t\t\tawait shareFile(share.path,tag);\r\n\t\t\t\tshare.modified = info.mtime.getTime();\r\n\t\t\t\tdirty = true;\r\n\t\t\t}\r\n\t\t\tvalidShares.push(share);\r\n\t\t} catch (error) {\r\n\t\t\tremovedPaths.push(share.path);\r\n\t\t\tdirty = true;\r\n\t\t}\r\n\t}\r\n\r\n\tif (removedPaths.length) {\r\n\t\troha.sharedFiles = validShares;\r\n\t\tawait writeRoha();\r\n\t\techo(`Invalid shares detected:\\n${removedPaths.join('\\n')}`);\r\n\t}\r\n\r\n\tif (dirty&&tag) {\r\n\t\tlet invoke=\"feel free to call annotate_foundry to tag \"+tag;\r\n\t\trohaHistory.push({role:\"system\",content:invoke});\r\n\t}\r\n\r\n\treturn dirty;\r\n}\r\n\r\nasync function setTag(name,note){\r\n\tlet tags=roha.tags||{};\r\n\tlet tag=(tags[name])?tags[name]:{name,info:[]};\r\n\ttag.info.push(note);\r\n\ttags[name]=tag;\r\n\troha.tags=tags;\r\n\tawait writeRoha();\r\n//\tlet invoke=`New tag \"${name}\" added. Describe all shares with this tag.`;\r\n//\trohaHistory.push({role:\"system\",content:invoke});\r\n}\r\nfunction listCounters(){\r\n\tlet keys=Object.keys(roha.counters);\r\n\tlet i=0;\r\n\tfor(let key of keys){\r\n\t\tlet count=roha.counters[key];\r\n\t\techo((i++),key,count);\r\n\t}\r\n}\r\nfunction listTags(){\r\n\tlet tags=roha.tags||{};\r\n\tlet keys=Object.keys(tags);\r\n\tlet list=[];\r\n\tfor(let i=0;i<keys.length;i++){\r\n\t\tlet tag=tags[keys[i]];\r\n\t\tconst name=tag.name||\"?????\";\r\n\t\techo(i,name,\"(\"+tag.info.length+\")\");\r\n\t\tlet info=tag.description;\r\n\t\tif(info) echo(\"\",info);\r\n\t\tlist.push(name);\r\n\t}\r\n\ttagList=list;\r\n}\r\n\r\nfunction listAccounts(){\r\n\tlet list=[];\r\n\tfor(let key in modelAccounts){\r\n\t\tlet value=modelAccounts[key];\r\n\t\tlist.push(key);\r\n\t}\r\n\tfor(let i=0;i<list.length;i++){\r\n\t\techo(i,list[i]);\r\n\t}\r\n}\r\n\r\nasync function showHelp() {\r\n\ttry {\r\n\t\tconst md = await Deno.readTextFile(\"foundry.md\");\r\n\t\techo(mdToAnsi(md));\r\n\t} catch (e) {\r\n\t\techo(\"Error loading help file: \" + e.message);\r\n\t}\r\n}\r\n\r\nfunction readable(text){\r\n\ttext=text.replace(/\\s+/g, \" \");\r\n\treturn text;\r\n}\r\n\r\nasync function callCommand(command) {\r\n\tlet dirty=false;\r\n\tlet words = command.split(\" \",2);\r\n\ttry {\r\n\t\tswitch (words[0]) {\r\n\t\t\tcase \"band\":\r\n\t\t\t\tlistBand();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"counter\":\r\n\t\t\t\tlistCounters();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"tag\":\r\n\t\t\t\tawait listTags();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"account\":\r\n\t\t\t\tawait listAccounts();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"help\":\r\n\t\t\t\tawait showHelp();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"config\":\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\tlet flag=words[1].trim();\r\n\t\t\t\t\tif(flag.length && !isNaN(flag)){\r\n\t\t\t\t\t\tflag=Object.keys(flagNames)[flag|0];\r\n\t\t\t\t\t\techo(\"flag\",flag);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(flag in flagNames){\r\n\t\t\t\t\t\troha.config[flag]=!roha.config[flag];\r\n\t\t\t\t\t\techo(flag+\" - \"+flagNames[flag]+\" is \"+(roha.config[flag]?\"true\":\"false\"));\r\n\t\t\t\t\t\tawait writeRoha();\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlet count=0;\r\n\t\t\t\t\tfor(let flag in flagNames){\r\n\t\t\t\t\t\techo((count++),flag,\":\",flagNames[flag],\":\",(roha.config[flag]?\"true\":\"false\"))\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistCommand=\"config\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"time\":\r\n\t\t\t\techo(\"Current time:\", new Date().toString());\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"history\":\r\n\t\t\t\tlistHistory();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"load\":\r\n\t\t\t\tlet save=words[1];\r\n\t\t\t\tif(save){\r\n\t\t\t\t\tif(save.length && !isNaN(save)) save=roha.saves[save|0];\r\n\t\t\t\t\tif(roha.saves.includes(save)){\r\n\t\t\t\t\t\tlet history=await loadHistory(save);\r\n\t\t\t\t\t\trohaHistory=history;\r\n\t\t\t\t\t\techo(\"a new history is set\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlistSaves();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"save\":\r\n\t\t\t\tlet savename=words.slice(1).join(\" \");\r\n\t\t\t\tsaveHistory(savename);\r\n\t\t\t\tawait writeRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"model\":\r\n\t\t\t\tlet name=words[1];\r\n\t\t\t\tif(name){\r\n\t\t\t\t\tif(name.length&&!isNaN(name)) name=modelList[name|0];\r\n\t\t\t\t\tif(modelList.includes(name)){\r\n\t\t\t\t\t\tresetModel(name);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor(let i=0;i<modelList.length;i++){\r\n\t\t\t\t\t\tlet name=modelList[i];\r\n\t\t\t\t\t\tlet attr=(name==grokModel)?\"*\":\"\";\r\n\t\t\t\t\t\techo(i,name,attr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistCommand=\"model\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"reset\":\r\n\t\t\t\tawait resetRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"cd\":\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\tconst newDir = words[1];\r\n\t\t\t\t\tif (newDir.length) Deno.chdir(newDir);\r\n\t\t\t\t}\r\n\t\t\t\tcurrentDir = Deno.cwd();\r\n\t\t\t\techo(\"Changed directory to\", currentDir);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"dir\":\r\n\t\t\t\tconst files = Deno.readDirSync(currentDir);\r\n\t\t\t\techo(\"Contents of\", currentDir + \":\");\r\n\t\t\t\tfor (const file of files) {\r\n\t\t\t\t\tlet name=(file.isDirectory)?\"[\"+file.name+\"]\":file.name;\r\n\t\t\t\t\techo(name);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"drop\":\r\n\t\t\t\tdropShares();\r\n\t\t\t\tawait writeRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"share\":\r\n\t\t\t\tif (words.length==1){\r\n\t\t\t\t\tlistShare();\r\n\t\t\t\t}else{\r\n\t\t\t\t\tconst filename = words.slice(1).join(\" \");\r\n\t\t\t\t\tconst path = resolvePath(Deno.cwd(), filename);\r\n\t\t\t\t\tconst info = await Deno.stat(path);\r\n\t\t\t\t\tconst tag = await prompt2(\"Enter tag name (optional):\");\r\n\t\t\t\t\tif(info.isDirectory){\r\n\t\t\t\t\t\techo(\"Share directory path:\",path);\r\n\t\t\t\t\t\tawait shareDir(path,tag);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlet size=info.size;\r\n\t\t\t\t\t\tlet modified=info.mtime.getTime();\r\n\t\t\t\t\t\techo(\"Share file path:\",path,\" size:\",info.size,\" \");\r\n\t\t\t\t\t\tconst hash = await hashFile(path);\r\n\t\t\t\t\t\techo(\"hash:\",hash);\r\n\t\t\t\t\t\tawait addShare({path,size,modified,hash,tag});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tawait writeRoha();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"push\":\r\n\t\t\tcase \"commit\":\r\n\t\t\t\tlet tag=\"\";\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\ttag=words[1];\r\n\t\t\t\t}\r\n\t\t\t\tdirty=await commitShares(tag);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\techo(\"Command not recognised\");\r\n\t\t\t\treturn false; // Command not recognized\r\n\t\t}\r\n\t} catch (error) {\r\n\t\techo(\"Error processing command:\", error.message);\r\n\t}\r\n\tincrement(\"calls\");\r\n\treturn dirty;\r\n}\r\n\r\necho(rohaTitle,\"running from \"+rohaPath);\r\nawait readRoha();\r\n\r\nlet grokModel = roha.model||\"deepseek-chat@deepseek\";\r\nlet grokFunctions=true;\r\nlet grokUsage = 0;\r\n\r\necho(\"present [\",grokModel,\"]\");\r\necho(\"shares count:\",roha.sharedFiles.length)\r\necho(\"use /help for latest and exit to quit\");\r\necho(\"\");\r\n\r\nlet sessions=increment(\"sessions\");\r\nif(sessions==0){\r\n\tlet welcome=await Deno.readTextFile(\"welcome.txt\");\r\n\techo(welcome);\r\n\tawait writeRoha();\r\n}\r\n\r\nif(roha.config){\r\n\tif(roha.config.commitonstart) await commitShares();\r\n}else{\r\n\troha.config={};\r\n}\r\n\r\nfunction extensionForType(contentType) {\r\n\tif (contentType.includes(\"markdown\")) return \".md\";\r\n\tif (contentType.includes(\"json\")) return \".json\";\r\n\tif (contentType.includes(\"javascript\")) return \".js\";\r\n\treturn \".txt\";\r\n}\r\n\r\nasync function onCall(toolCall) {\r\n\tlet verbose=roha.config.verbose;\r\n\tswitch(toolCall.function.name) {\r\n\t\tcase \"read_time\":\r\n\t\t\treturn {time: new Date().toISOString()};\r\n\t\tcase \"submit_file\":\r\n\t\t\tlet args=JSON.parse(toolCall.function.arguments);\r\n\t\t\techo(args.contentType);\r\n\t\t\tif (verbose) echo(args.content);\r\n\t\t\tlet timestamp=Math.floor(Date.now()/1000).toString(16);\r\n\t\t\tlet extension=extensionForType(args.contentType)\r\n\t\t\tlet name= \"submission-\"+timestamp+extension;\r\n\t\t\tlet filePath = resolve(forgePath,name);\r\n\t\t\tawait Deno.writeTextFile(filePath, args.content);\r\n\t\t\techo(\"File saved to:\", filePath);\r\n\t\t\treturn { success: true, path: filePath };\r\n\t\tcase \"annotate_foundry\":\r\n\t\t\ttry {\r\n\t\t\t\tconst { name, type, description } = JSON.parse(toolCall.function.arguments || \"{}\");\r\n\t\t\t\tswitch(type){\r\n\t\t\t\t\tcase \"tag\":\r\n\t\t\t\t\t\tannotateTag(name,description);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"share\":\r\n\t\t\t\t\t\tannotateShare(name,description);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tawait writeRoha(); // Persist changes\r\n\t\t\t\treturn { success: true, updated: 1 };\r\n\t\t\t} catch (error) {\r\n\t\t\t\techo(\"annotate_foundry error:\",error);\r\n\t\t\t\treturn { success: false, updated: 0 };\r\n\t\t\t}\r\n\t}\r\n\tconsole.error(\"onCall error - call simon\");\r\n}\r\n\r\nfunction squashMessages(history) {\r\n\tif (history.length < 2) return history;\r\n\tconst squashed = [history[0]];\r\n\tlet system=[];\r\n\tlet other=[];\r\n\tfor(let item of history){\r\n\t\tif(item.role==\"system\") system.push(item); else other.push(item);\r\n\t}\r\n\tfor(let list of [system,other]){\r\n\t\tlet last=null;\r\n\t\tfor (let i = 0; i < list.length; i++) {\r\n\t\t\tconst current=list[i];\r\n\t\t\tif(last){\r\n\t\t\t\tlast.content += \"\\n\" + current.content;\r\n\t\t\t} else {\r\n\t\t\t\tsquashed.push(current);\r\n\t\t\t\tlast=current;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn squashed;\r\n}\r\n\r\nasync function isolateCode(path,cwd) {\r\n\ttry {\r\n\t\tconst readAllow = `--allow-read=${cwd}`;\r\n\t\tconst writeAllow = `--allow-write=${cwd}`;\r\n\t\tconst cmd = [\"deno\", \"run\", \"--no-remote\", readAllow, writeAllow, path];\r\n\t\tconst process = Deno.run({ cmd, stdout: \"piped\", stderr: \"piped\" });\r\n\t\tconst [stdout, stderr] = await Promise.all([process.output(), process.stderrOutput()]);\r\n\t\tconst status = await process.status();\r\n\t\tprocess.close();\r\n\t\treturn {\r\n\t\t\tsuccess: status.success,\r\n\t\t\toutput: new TextDecoder().decode(stdout),\r\n\t\t\terror: new TextDecoder().decode(stderr)\r\n\t\t};\r\n\t} catch (err) {\r\n\t\treturn { success: false, output: \"\", error: err.message };\r\n\t}\r\n}\r\n\r\nasync function runCode(){\r\n\tlet result = await isolateCode(\"isolation/test.js\", \"isolation\");\r\n\t//echo(\"RunCode Result:\", result.success ? \"Success\" : \"Failed\");\r\n\tif (result.output) echo(\"[isolation] \", result.output);\r\n\tif (result.error) echo(\"Error:\", result.error);\r\n\t// todo: add save on exit\r\n}\r\n\r\nasync function relay() {\r\n\tconst verbose=roha.config.verbose;\r\n\ttry {\r\n\t\tconst modelAccount=grokModel.split(\"@\");\r\n\t\tlet model=modelAccount[0];\r\n\t\tlet account=modelAccount[1];\r\n\t\tlet endpoint=rohaAccount[account];\r\n\t\tlet usetools=grokFunctions&&roha.config.tools;\r\n\t\tconst payload = usetools?{ model, messages:rohaHistory, tools: rohaTools }:{ model, messages:squashMessages(rohaHistory) };\r\n\t\tconst completion = await endpoint.chat.completions.create(payload);\r\n\t\tif (completion.model != model) {\r\n\t\t\techo(\"[relay model alert model:\" + completion.model + \" grokModel:\" + grokModel + \"]\");\r\n\t\t\tgrokModel=completion.model+\"@\"+account;\r\n\t\t}\r\n\t\tif (verbose) {\r\n\t\t\t// echo(\"relay completion:\" + JSON.stringify(completion, null, \"\\t\"));\r\n\t\t}\r\n\t\tlet system = completion.system_fingerprint;\r\n\t\tlet usage = completion.usage;\r\n\t\tlet size = measure(rohaHistory);\r\n\t\tgrokUsage += usage.prompt_tokens | 0 + usage.completion_tokens | 0;\r\n\t\tlet status = \"[model \" + grokModel + \" \" + usage.prompt_tokens + \" \" + usage.completion_tokens + \" \" + grokUsage + \" \" + size + \"]\";\r\n\t\techo(status);\r\n\t\tvar reply = \"<blank>\";\r\n\t\tfor (const choice of completion.choices) {\r\n\t\t\tlet calls = choice.message.tool_calls;\r\n\t\t\t// choice has index message{role,content,refusal,annotations} finish_reason\r\n\t\t\tif (calls) {\r\n\t\t\t\tincrement(\"calls\");\r\n\t\t\t\techo(\"relay calls in progress\");\r\n\t\t\t\t// Generate tool_calls with simple, unique IDs\r\n\t\t\t\tconst toolCalls = calls.map((tool, index) => ({\r\n\t\t\t\t\tid: `call_${rohaCalls++}`,\r\n\t\t\t\t\ttype: \"function\",\r\n\t\t\t\t\tfunction: {\r\n\t\t\t\t\t\tname: tool.function.name,\r\n\t\t\t\t\t\targuments: tool.function.arguments || \"{}\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}));\r\n\t\t\t\t// Add assistant message with tool_calls\r\n\t\t\t\tlet content=choice.message.content || \"\";\r\n\t\t\t\trohaHistory.push({role:\"assistant\",content,tool_calls: toolCalls});\r\n\t\t\t\tif(verbose) echo(\"tooling \"+content);\r\n\t\t\t\t// Add tool responses\r\n\t\t\t\tfor (let i = 0; i < calls.length; i++) {\r\n\t\t\t\t\tconst tool = calls[i];\r\n\t\t\t\t\tconst result = await onCall(tool);\r\n\t\t\t\t\tif (result){\r\n\t\t\t\t\t\tlet content=JSON.stringify(result);\r\n\t\t\t\t\t\trohaHistory.push({\r\n\t\t\t\t\t\t\trole: \"tool\",\r\n\t\t\t\t\t\t\ttool_call_id: toolCalls[i].id,\r\n\t\t\t\t\t\t\tname: tool.function.name,\r\n\t\t\t\t\t\t\tcontent\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\techo(\"no oncall result\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn relay(); // Recursive call to process tool results\r\n\t\t\t}\r\n\t\t\treply = choice.message.content;\r\n\t\t\tif (roha.config && roha.config.ansi) {\r\n//\t\t\t\techo(ansiSaveCursor);\r\n\t\t\t\tprint(mdToAnsi(reply));\r\n//\t\t\t\techo(ansiRestoreCursor);\r\n\t\t\t} else {\r\n\t\t\t\tprint(wordWrap(reply));\r\n\t\t\t}\r\n\t\t}\r\n\t\trohaHistory.push({ role: \"assistant\", content: reply });\r\n\t} catch (error) {\r\n\t\tlet line=error.message || String(error);\r\n\t\t//Error during API call: Error: 400 \"This model's maximum prompt length is 131072 but the request contains 165547 tokens.\"\r\n\t\tif(line.includes(\"maximum prompt length\")){\r\n\t\t\techo(\"maximum prompt length exceeded, switch model or drop shares to continue\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconsole.error(\"Error during API call:\", error);\t\r\n\t\tif(grokFunctions){\r\n\t\t\techo(\"resetting grokFunctions\")\r\n\t\t\tgrokFunctions=false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nasync function chat() {\r\n\tdance:\r\n\twhile (true) {\r\n\t\tlet lines=[];\r\n//\t\techo(ansiMoveToEnd);\r\n\t\twhile (true) {\r\n\t\t\tawait flush();\r\n\t\t\tlet line=\"\";\r\n\t\t\tif(listCommand){\r\n\t\t\t\tline=await prompt2(\"#\");\r\n\t\t\t\tif(line.length && !isNaN(line)){\r\n\t\t\t\t\tlet index=line|0;\r\n\t\t\t\t\tawait callCommand(listCommand+\" \"+index);\r\n\t\t\t\t}\r\n\t\t\t\tlistCommand=\"\";\r\n\t\t\t}else{\r\n\t\t\t\tline=await prompt2(rohaPrompt);\r\n\t\t\t}\r\n\t\t\tif (line === '') {\r\n\t\t\t\tif(roha.config.returntopush && !lines.length) {\r\n\t\t\t\t\techo(\"auto pushing...\");\r\n\t\t\t\t\tawait callCommand(\"push\");\r\n\t\t\t\t\tawait relay();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (line === \"exit\") {\r\n\t\t\t\techo(\"Ending the conversation...\");\r\n\t\t\t\tbreak dance;\r\n\t\t\t}\r\n\t\t\tif (line.startsWith(\"/\")) {\r\n\t\t\t\tconst command = line.substring(1).trim();\r\n\t\t\t\tlet dirty=await callCommand(command);\r\n\t\t\t\tif(dirty){\r\n\t\t\t\t\tlines.push(\"Please review source for bugs and all content if notable changes detected, thanks.\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlines.push(line.trim());\r\n\t\t}\r\n\r\n\t\tif (lines.length){\r\n\t\t\tconst query=lines.join(\"\\n\");\r\n\t\t\tif(query.length){\r\n\t\t\t\trohaHistory.push({ role: \"user\", content: query });\r\n\t\t\t\tawait relay();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nDeno.addSignalListener(\"SIGINT\", () => {Deno.exit(0);});\r\n\r\n//only windows Deno.addSignalListener(\"SIGBREAK\", () => {echo(\"SIGBREAK\");});\r\n\r\nawait runCode(\"isolation/test.js\",\"isolation\");\r\n\r\nchat();\r\n\n{\"path\":\"C:/nitrologic/foundry/release/accounts.json\",\"length\":362,\"type\":\"application/json; charset=UTF-8\"}\n{\r\n\t\"gemini\":{\r\n\t\t\"env\":\"GEMINI_API_KEY\",\r\n\t\t\"url\":\"https://generativelanguage.googleapis.com/v1beta/openai\"\r\n\t},\r\n\t\"deepseek\":{\r\n\t\t\"env\":\"DEEPSEEK_API_KEY\",\r\n\t\t\"url\":\"https://api.deepseek.com\"\r\n\t},\r\n\t\"xai\": {\r\n\t\t\"env\": \"XAI_API_KEY\",\r\n\t\t\"url\": \"https://api.x.ai/v1\"\r\n\t},\r\n\t\"openai\": {\r\n\t\t\"env\": \"OPENAI_API_KEY\",\r\n\t\t\"url\": \"https://api.openai.com/v1\"\r\n\t}\r\n  }\r\n\n{\"path\":\"C:/nitrologic/foundry/release/foundry.md\",\"length\":2601,\"type\":\"text/markdown; charset=UTF-8\"}\n# foundry command line client\r\n\r\nA command line application designed to chat and share files.\r\n\r\n## foundry machine interface\r\n\r\nThe foundry functional interface uses tools and tool_calls.\r\n\r\nOnly recent models provide tools interface, foundry should fall \r\nback to a no tools completion mode.\r\n\r\nSee the OpenAI API spec for more tool role details.\r\n\r\n### read_time\r\n\r\n### submit_file\r\n\r\n### annotate_foundry\r\n\r\n## foundry user interface\r\n\r\ncommands with no arguments may often prompt for a # index from\r\nthe items displayed\r\n\r\n### /config\r\n\r\nToggle configuration flags.\r\n\r\nAdjust settings to suit current preferences.\r\n\r\nDefault values are typically:\r\n\r\n* 0 commitonstart : commit shared files on start : true\r\n* 1 ansi : markdown ANSI rendering : true\r\n* 2 slow : output at reading speed : true\r\n* 3 verbose : emit debug information : true\r\n* 4 broken : ansi background blocks : false\r\n* 5 logging : log all output to file : true\r\n* 6 resetcounters : at reset zero all counters : true\r\n\r\n### /share\r\n\r\nShare a file or folder with optional tag.\r\n\r\nFiles are added to the share list used by the /push /commit command.\r\n\r\n### /drop\r\n\r\nDrop all files currently shared\r\n\r\n### /push /commit\r\n\r\nRefresh shared files. \r\n\r\nDetects changes or deletions and updates the chat history.\r\n\r\nPosts new versions of file content if modified.\r\n\r\n### /reset\r\n\r\nClear all shared files and conversation history.\r\n\r\n### /history\r\n\r\nList a summary of recent conversation entries. \r\n\r\nProvides a quick overview of chat history.\r\n\r\n### /cd\r\n\r\nChange the working directory. \r\n\r\nUser can navigate to a desired directory for file operations.\r\n\r\n### /dir\r\n\r\nList the contents of the current working directory. \r\n\r\nHelps user view available files and folders to share.\r\n\r\n\r\n### /model\r\n\r\nSelect an AI model.\r\n\r\nUser can choose a model by name or index from the accounts available.\r\n\r\n### /counters\r\n\r\nList the internal application counters.\r\n\r\n### /tag\r\n\r\nDescribe all tags in use.\r\n\r\nDisplays tag name, count of shares tagged and description.\r\n\r\n### /account\r\n\r\nDisplay current account information.\r\n\r\n### /save [name]\r\n\r\nSave the current conversation history. \r\n\r\nCreates a snapshot file of the conversation.\r\n\r\nThe default name is currently .roa-save-HEX32_TIME.json\r\n\r\n### /load\r\n\r\nLoad a saved conversation history snapshot.\r\n\r\nUser can specify a save index or file name to restore previous chats.\r\n\r\n\r\n### /time\r\n\r\nDisplay the current system time. \r\n\r\nHelps user verify system status.\r\n\r\n### /help\r\n\r\nIf you are reading this file, it may be due to the use of this command.\r\n\r\nIf you still need help visit the project page.\r\n\n{\"path\":\"C:/nitrologic/foundry/release/LICENSE.txt\",\"length\":1753,\"type\":\"text/plain; charset=UTF-8\"}\nMIT License\r\n\r\nCopyright (c) 2025 Simon Armstrong\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is                                            \r\nfurnished to do so, subject to the following conditions:                                                         \r\n                                                                                                                 \r\nThe above copyright notice and this permission notice shall be included in all                                   \r\ncopies or substantial portions of the Software.                                                                  \r\n                                                                                                                 \r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                       \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                         \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                                      \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                           \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                                    \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE                                    \r\nSOFTWARE. \n{\"path\":\"C:/nitrologic/foundry/release/welcome.txt\",\"length\":481,\"type\":\"text/plain; charset=UTF-8\"}\npreceed with caution\r\n\r\n  o---/\\     /---o     \\---/     /---/\\     o---/\\     \\---o     /---/\\ \r\n  |    \\/   /    |     |    /   /    \\/    |    \\/   /    |     |    \\/ \r\n#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #\r\n\r\n\tWELCOME TO FOUNDRY\r\n\r\n\tA COMMAND LINE TOOL FOR CHATTING AND SHARING FILES\r\n\r\n\tTHE MAGIC WORD IS HAPUKA\r\n\r\n\tTHIS FILE IS PART OF THE ROHA CLIENT DISTRIBUTION\r\n\r\n#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #\r\n\n{\"path\":\"C:/nitrologic/foundry/release/forge/readme.txt\",\"length\":67,\"type\":\"text/plain; charset=UTF-8\"}\nlocal storage for shared files submitted for review by foundry rc1\n\n{\"path\":\"C:/nitrologic/foundry/release/isolation/readme.txt\",\"length\":103,\"type\":\"text/plain; charset=UTF-8\"}\na sandbox for foundry rc1 runs\r\n\r\nrun foundry run\r\n\r\nthis stuff is post rc1 - what is going on here?\r\n \n{\"path\":\"C:/nitrologic/foundry/release/isolation/test.js\",\"length\":180,\"type\":\"application/javascript; charset=UTF-8\"}\n\r\nfunction hexDate(){\r\n    let s=Date.now()/1e3|0;\r\n    return s.toString(16);\r\n}\r\n\r\nconsole.log(\"radio   live transmission\");\r\n\r\nconsole.log(hexDate());\r\nconsole.log(hexDate());\r\n\n{\"path\":\"C:/nitrologic/foundry/.gitignore\",\"length\":55,\"type\":\"application/octet-stream\",\"mimeType\":\"application/octet-stream\"}\nFile content: MIME=application/octet-stream, Base64=Zm91bmRyeS5sb2cKZm91bmRyeS5qc29uCnNhdmVzCnJlbGVhc2UKcmMxL2ZvdW5kcnkuZXhlCg==\n{\"path\":\"C:/nitrologic/foundry/build.bat\",\"length\":88,\"type\":\"application/x-msdownload\"}\ndeno compile --allow-run --allow-env --allow-net --allow-read --allow-write foundry.js\r\n\ni would like to prepare a report on the nitrologic foundry client\nBelow is a draft report on the Nitrologic Foundry Client:\n\n─────────────────────────────────────────────  \nNitrologic Foundry Client Report  \n─────────────────────────────────────────────\n\n1. Overview\n\nThe Nitrologic Foundry Client is a command‑line research client designed to interact with language models and manage file sharing. Written in JavaScript/TypeScript for execution with Deno, the client leverages several permissions (run, env, net, read, write) and is intended for experimentation with model evaluations, conversation histories, and file submission workflows.\n\n2. Key Features\n\n• Chat Interface and History Management  \n – The client provides an interactive prompt (using raw mode via Deno’s stdin reader) that accepts chat messages and commands.  \n – It maintains a conversation history (“rohaHistory”) for both user queries and model responses, allowing for conversation snapshots and history restoration via save and load functionality.  \n – A “relay” function communicates with model endpoints (using the OpenAI client libraries and several API providers such as GEMINI, DEEPSEEK, XAI, and OpenAI) and appears to support models that have tool call capabilities.\n\n• File Sharing and Submission  \n – The “/share” command enables users to designate files or directories for sharing. Individual files are processed (for text, JSON, markdown, etc.) or converted to Base64 for binary content.  \n – A sharing mechanism tracks file metadata (path, size, modification time, hash) and tags shared files.  \n – The client supports a “/push” or “/commit” command that scans shared files, detects modifications or deletions, and—if changes are detected—updates the chat history and files submitted for review.\n\n• Configuration and Customization  \n – Several configuration flags allow toggling features such as committing shares on start, ANSI rendering of markdown, slow output, verbose debugging information, and logging (to a file “foundry.log”).  \n – The “/config” command lists available flags, which include:  \n  • commitonstart  (commit shared files on start)  \n  • tools        (enable model tool interface)  \n  • ansi         (render using ANSI/markdown)  \n  • slow         (output at reading speed)  \n  • verbose       (emit debug information)  \n  • broken        (ansi background blocks via alternate colors)  \n  • logging       (log all output to file)  \n  • resetcounters  (reset counters on reset)  \n  • returntopush  (prompt to “push” when returning)\n\n• Model Management and Tooling Interface  \n – The client supports selecting models via the “/model” command. The list of available models is gathered from multiple API endpoints (configured in the “accounts.json” file) and stored in a list (“modelList”).  \n – It uses tool call functions if the selected model supports the tools interface. Three tool functions are defined:  \n  ○ read_time – returns current UTC time.  \n  ○ submit_file – submits a file for review by sending content type and file content, saving the file to a “forge” directory.  \n  ○ annotate_foundry – permits setting descriptions on objects like tags or shared files.  \n – The “relay” function is responsible for interfacing with the model. It prepares the payload (using either the simple chat history or a tool call JSON structure) and recursively handles tool call responses by executing the corresponding functions (via “onCall”) before forwarding the results back into the conversation cycle.\n\n3. Architecture and Workflow\n\n• Initialization and Configuration  \n – On startup, the client checks for a “foundry.json” state file, creating one with default settings if not present.  \n – It reads “accounts.json” to establish connections with the configured AI endpoints; these connections use API keys from environment variables.  \n – The client also initializes conversation history (rohaHistory) with a system prompt (“I am testing foundry client. You are a helpful assistant”).\n\n• File and Directory Operations  \n – Commands such as “/cd” and “/dir” allow the user to manage current working directories – aiding in file selection for sharing.  \n – The client uses Deno APIs for file operations, including reading, writing, statting files, and computing file hashes using SHA‑256.\n\n• Command Processing  \n – Input lines that begin with a “/” are interpreted as commands. Otherwise, they are treated as chat messages from the user.  \n – A command “callCommand” function handles a wide range of commands: listing accounts, toggling configuration flags, sharing files, managing tags, and handling model selection.\n – Commands such as “/reset” clear shared files and conversation history; “/history” lists recent conversation activities; “/save” and “/load” allow the user to persist or restore sessions.\n\n• ANSI and Markdown Rendering  \n – The client can render markdown content with ANSI escape sequences for styling (headers, bold, italics, bullets).  \n – There is a fallback plain output mode if ANSI rendering is not enabled.\n\n• Isolation and Sandbox Execution  \n – A helper function “isolateCode” is provided to run external JavaScript code (from an “isolation/test.js” file) in a sandboxed environment with restricted permissions. This supports a “runCode” routine that demonstrates isolated execution.\n\n4. Additional Files and Documentation\n\n• foundry.md – This markdown file provides an overview of the available commands and the machine interface (tool calls) for the client.\n• welcome.txt – A welcome banner displayed on startup.\n• LICENSE.txt and build.bat – These files establish project licensing (MIT License) and build instructions for compiling the Deno application.\n• The “forge” subdirectory is used for storing file submissions and conversation snapshots.\n• The “isolation” subdirectory contains a sandbox for testing code execution, distinct from the main workflow.\n\n5. Summary\n\nThe Nitrologic Foundry Client is a robust research tool designed for interacting with language models while integrating file sharing and conversation management. With its modular tool calls, command interface, and detailed configuration options, it becomes a flexible environment for testing model capabilities – particularly for those models that support an interactive tools interface. The design elegantly combines interactive terminal I/O, file system operations, and API integrations in a portable Deno runtime environment.\n\n─────────────────────────────────────────────  \nConcluding Remarks\n\nThe Foundry Client, as demonstrated by the provided source code and accompanying materials, reflects thoughtful design aimed at research and interactive testing. Its support for both chat-based interactions and contextual file sharing makes it well suited for scenarios where version tracking and iterative model evaluation are needed. Future enhancements—such as improved error handling, richer command completion (e.g., arrow navigation), and expanded tool integrations—could further extend its capabilities.\n\n─────────────────────────────────────────────  \nEnd of Report\n\nFeel free to adjust or expand any sections as needed for your reporting purposes.\nno way to verbose\nBelow is a report summarizing and analyzing the Nitrologic Foundry Client based on the source code and accompanying documentation.\n\n─────────────────────────────────────────────  \nNitrologic Foundry Client Report  \n─────────────────────────────────────────────\n\n1. Overview\n\nThe Nitrologic Foundry Client is an experimental command‑line research tool built on Deno. It is designed to facilitate model evaluation, interactive chat sessions, and file sharing. The client interacts with multiple language model endpoints (such as those provided by OpenAI, Deepseek, Gemini, and XAI) and supports both chat and file submission through a unified interface.\n\n2. Key Features\n\n• Interactive Chat Interface and Conversation History  \n – The client runs in a terminal and uses raw input mode to capture user commands and messages.  \n – Conversation history is maintained in an array (“rohaHistory”), starting with a system prompt that defines the client’s role.  \n – Users may save and reload conversation sessions, allowing for persistent session management.\n\n• File Sharing and Commit Workflow  \n – The “/share” command allows a user to submit either files or entire directories.  \n – Shared files are tracked via metadata including file path, size, modification time, and a computed SHA‑256 hash.  \n – A “/push” (or “/commit”) command scans the shared files for modifications or deletions, updates history, and integrates file “submissions” into the conversation for review.\n\n• Configurable Options and Command Set  \n – Multiple configuration flags control aspects such as:  \n  • Automatic file commit on start  \n  • ANSI-based markdown rendering for enhanced terminal output  \n  • Slow reading (output pacing), verbose logging, and even special “broken” modes for ANSI blocks  \n – Commands such as “/config” allow users to toggle these features.  \n – Additional commands include “/cd” (to change directory), “/dir” (to list files), “/model” (to select or switch language models), and “/reset” (to clear history and file shares).\n\n• Model and Tool Functionality  \n – The client supports model interactions using a “relay” function that sends the conversation history as a payload to the selected model endpoint.  \n – Some models support “tool calls,” and the client defines three tool functions:  \n  ○ read_time – Returns the current UTC time  \n  ○ submit_file – Accepts content and its MIME type to save a file in the local “forge” directory  \n  ○ annotate_foundry – Lets the user annotate or set descriptions on file shares or tags  \n – These tools support enhanced interactions when the underlying model can invoke external functions during a conversation.\n\n• ANSI and Markdown Rendering  \n – The client renders markdown content using ANSI escape sequences (for headers, bold, italics, and bullet lists), improving readability in terminal outputs when enabled.  \n – A fallback plain text mode is available if ANSI rendering is turned off.\n\n• Sandbox Code Execution  \n – A dedicated “isolation” module demonstrates running external JavaScript code in an isolated environment with limited permissions. This reinforces the client’s role as a research and testing platform.\n\n3. Architecture and Workflow\n\n• Initialization and Startup  \n – On launch, the client checks for a persistent state file (“foundry.json”). If not found, it creates a default configuration.  \n – It reads an “accounts.json” file to load provider configurations and uses environment variables to obtain API keys for connecting to endpoints.\n\n• Conversation Handling  \n – User input is processed in two categories: commands (prefixed with “/”) and regular chat messages.  \n – The “callCommand” function handles a variety of commands (e.g., file management, configuration toggles, model selection) and directs appropriate actions.  \n – The “relay” function packages the chat history (or a squashed version of it) and sends it to the AI endpoint using either a simple completion or a tool invocation model, with recursive handling of tool responses as needed.\n\n• File and Directory Management  \n – The client uses Deno’s filesystem API to change directories (“/cd”), list directory contents (“/dir”), and compute file hash values for file integrity checking.  \n – Shared files are maintained in an internal list (roha.sharedFiles) and include optional tags that can be annotated post sharing.\n\n• Configurability and Logging  \n – The client supports multiple configuration options stored within the state file, allowing toggles for behaviors such as automatic commit at startup and slow output pacing.  \n – There is also an option to log all output to a “foundry.log” file.\n\n4. Supporting Files and Documentation\n\n• foundry.md – A markdown document that describes available commands and the machine interface (tool calls) for the client.  \n• welcome.txt – Provides a graphical welcome message on startup.  \n• LICENSE.txt – Contains the MIT License terms under which the source is released.  \n• build.bat – A batch script to compile the application using Deno’s compile command, ensuring necessary permissions are granted.  \n• The “forge” directory – A local repository for submitted files and session snapshots.  \n• The “isolation” directory – Contains sandboxed test code that is executed at startup to verify isolated code execution capabilities.\n\n5. Summary and Concluding Remarks\n\nThe Nitrologic Foundry Client is a well-structured research tool merging interactive chat, file management, and model tool-call support. Its versatility lies in the ability to manage conversation sessions, track and submit file changes, and toggle between different aspects of its behavior with a simple command interface. The modular design—combining terminal I/O, file system manipulation, and API integration via Deno—makes it a useful platform for model evaluation and interactive research.\n\nFuture enhancements might include richer command-line navigation (such as arrow key support and auto-completion), improved error handling around API calls, and greater configurability for advanced users. As it stands, the Foundry Client provides a compelling example of combining AI interactivity with common file management tasks in a terminal-based environment.\n\n─────────────────────────────────────────────  \nEnd of Report\n\nFeel free to adjust or expand upon these sections based on further testing or additional project requirements.\nwould a git history of the original project help with a report on each functional block of code added to foundry.js\nYes, absolutely. A comprehensive git history would provide a detailed record of when and how each functional block was added or modified. This history can be invaluable for several reasons:\n\n• It provides commit messages and diffs that explain the intent behind changes. This context can help you understand the purpose and evolution of features like the chat interface, file sharing, configuration settings, and tooling integration.\n\n• You can trace the incremental changes made in each commit to see how different functionalities emerged. This would allow you to map certain commits to specific features (e.g., the addition of sandbox execution, ANSI rendering, or the tool_call interface).\n\n• It offers insight into debugging and performance improvements, as well as any architectural refactoring. For example, reviewing changes that affected error handling or logging could be useful in assessing the robustness of each component.\n\n• It aids in documenting the development process. You can refer to specific commits in your report to illustrate the evolution of Foundry.js, making your analysis more precise and informative.\n\nIn summary, leveraging the git history would indeed help produce a detailed report that covers each functional block of code added to Foundry.js, describing the evolution of the project and clarifying how its various capabilities came together over time.\nwhat is the git command to provide a list of diffs in historical order?\n// foundry.js\r\n// a research client for evaluating models\r\n// (c)2025 Simon Armstrong\r\n\r\n// deno run --allow-run --allow-env --allow-net --allow-read --allow-write roha.js\r\n\r\nimport { contentType } from \"https://deno.land/std@0.224.0/media_types/mod.ts\";\r\nimport { resolve } from \"https://deno.land/std/path/mod.ts\";\r\nimport OpenAI from \"https://deno.land/x/openai@v4.67.2/mod.ts\";\r\n\r\nconst foundryVersion = \"rc1\";\r\nconst rohaTitle=\"foundry \"+foundryVersion;\r\nconst rohaMihi=\"I am testing foundry client. You are a helpful assistant.\";\r\n\r\nconst slowMillis = 20;\r\n\r\nconst decoder = new TextDecoder(\"utf-8\");\r\nconst encoder = new TextEncoder();\r\n\r\nconst terminalColumns=120;\r\n\r\nconst flagNames={\r\n\tcommitonstart : \"commit shared files on start\",\r\n\ttools : \"enable model tool interface\",\r\n\tansi : \"markdown ANSI rendering\",\r\n\tslow : \"output at reading speed\",\r\n\tverbose : \"emit debug information\",\r\n\tbroken : \"ansi background blocks\",\r\n\tlogging : \"log all output to file\",\r\n\tresetcounters : \"factory reset when reset\",\r\n\treturntopush : \"hit return to /push - it is under test\"\r\n};\r\n\r\nconst emptyRoha={\r\n\tconfig:{\r\n\t\tcommitonstart:true,\r\n\t\tansi:true,\r\n\t\tslow:false,\r\n\t\tverbose:false,\r\n\t\tbroken:false,\r\n\t\tlogging:false,\r\n\t\tresetcounters:false,\r\n\t\treturntopush:false\r\n\t},\r\n\ttags:{},\r\n\tmodels:{},\r\n\tband:{},\r\n\tsharedFiles:[],\r\n\tsaves:[],\r\n\tcounters:{}\r\n};\r\n\r\nfunction addBand(){\r\n\tlet id=\"member\"+increment(\"members\");\r\n\troha.band[id]={};\r\n}\r\n\r\nfunction listBand(){\r\n\tlet band=[];\r\n\tfor(let id in roha.band){\r\n\t\tlet member=roha.band[id];\r\n\t\tband.push(member);\r\n\t}\r\n\tband.push(\"add\");\r\n\tfor(let i=0;i<band.length;i++){\r\n\t\techo(i,band[i]);\r\n\t}\r\n\tmemberList=band;\r\n}\r\n\r\nfunction annotateTag(name,description){\r\n\tif(!name){\r\n\t\tthrow(\"null name\");\r\n\t}\r\n\tif(!(name in roha.tags)) {\r\n\t\troha.tags[name]={};\r\n//\t\tthrow(\"tag not found \"+name);\r\n\t}\r\n\troha.tags[name].description=description;\r\n}\r\n\r\nfunction annotateShare(name,description){\r\n\tlet index=roha.sharedFiles.findIndex(item => item.id === name);\r\n\tif(index==-1) throw(\"share id not found\");\r\n\troha.sharedFiles[index].description=description;\r\n\techo(\"file share description annotated\");\r\n}\r\n\r\nfunction increment(key){\r\n\tlet i=0;\r\n\tif(key in roha.counters){\r\n\t\ti=roha.counters[key]+1;\r\n\t}\r\n\troha.counters[key]=i;\r\n\treturn i\r\n}\r\n\r\nvar tagList=[];\r\nvar modelList=[];\r\nvar shareList=[]; //typically biggest to smallest\r\nvar memberList=[];\r\n\r\nconst emptyModel={\r\n\tname:\"empty\",account:\"\",hidden:false,prompts:0,completion:0\r\n}\r\n\r\nconst emptyTag={\r\n}\r\n\r\n// const emptyShare={path,size,modified,hash,tag,id}\r\n\r\nlet roha=emptyRoha;\r\nlet rohaCalls=0;\r\nlet listCommand=\"\";\r\nlet rohaShares=[];\r\nlet currentDir = Deno.cwd();\r\nvar rohaHistory;\r\n\r\nfunction resetHistory(){\r\n\trohaHistory = [{role:\"system\",content:rohaMihi}];\r\n}\r\n\r\nfunction listHistory(){\r\n\tlet history=rohaHistory;\r\n\tfor(let i=0;i<history.length;i++){\r\n\t\tlet item=history[i];\r\n\t\tlet content=readable(item.content).substring(0,90)\r\n\t\techo(i,item.role,item.name||\"foundry\",\"-\",content);\r\n\t}\r\n\tif(roha.config.broken){\r\n\t\tlet flat=squashMessages(rohaHistory);\r\n\t\tfor(let i=0;i<flat.length;i++){\r\n\t\t\tlet item=flat[i];\r\n\t\t\tlet content=readable(item.content).substring(0,90);\r\n\t\t\techo(\"flat\",i,item.role,item.name||\"broken\",content);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction rohaPush(content,name=\"foundry\"){\r\n\trohaHistory.push({role:\"user\",name,content});\r\n}\r\n\r\nresetHistory();\r\n\r\n// roaTools\r\n\r\nconst rohaTools = [{\r\n\ttype: \"function\",\r\n\tfunction:{\r\n\t\tname: \"read_time\",\r\n\t\tdescription: \"Returns current time in UTC\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {},\r\n\t\t\trequired: []\r\n\t\t}\r\n\t}\r\n},{\r\n\ttype: \"function\",\r\n\tfunction:{\r\n\t\tname: \"submit_file\",\r\n\t\tdescription: \"Submit a file for review\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {\r\n\t\t\t\tcontentType:{type:\"string\"},\r\n\t\t\t\tcontent:{type:\"string\"}\r\n\t\t\t},\r\n\t\t\trequired: [\"contentType\",\"content\"]\r\n\t\t}\r\n\t}\r\n},{\r\n\ttype: \"function\",\r\n\tfunction: {\r\n\t\tname: \"annotate_foundry\",\r\n\t\tdescription: \"Set description of any object\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {\r\n\t\t\t\tname: { type: \"string\" },\r\n\t\t\t\ttype: { type:\"string\" },\r\n\t\t\t\tdescription: { type: \"string\" }\r\n\t\t\t},\r\n\t\t\trequired: [\"name\",\"type\",\"description\"]\r\n\t\t}\r\n\t}\r\n}];\r\n\r\nasync function sleep(ms) {\r\n\tawait new Promise(function(resolve) {setTimeout(resolve, ms);});\r\n}\r\n\r\nfunction measure(o){\r\n\tlet total=JSON.stringify(o).length;\r\n\treturn total;\r\n}\r\n\r\nlet outputBuffer = [];\r\nlet printBuffer = [];\r\n\r\nfunction print(){\r\n\tlet args=arguments.length?Array.from(arguments):[];\r\n\tlet lines=args.join(\" \").split(\"\\n\");\r\n\tfor(let line of lines){\r\n\t\tprintBuffer.push(line.trimEnd());\r\n\t}\r\n}\r\n\r\nfunction echo(){\r\n\tlet args=arguments.length?Array.from(arguments):[];\r\n\tlet lines=args.join(\" \").split(\"\\n\");\r\n\tfor(let line of lines){\r\n\t\toutputBuffer.push(line.trimEnd());\r\n\t}\r\n}\r\n\r\nfunction stripAnsi(text) {\r\n\treturn text.replace(/\\x1B\\[\\d+(;\\d+)*[mK]/g, '');\r\n}\r\n\r\nasync function log(lines,id){\r\n\tif(roha.config.logging){\r\n\t\tconst time = new Date().toISOString();\r\n\t\tlet list=[];\r\n\t\tfor(let line of lines.split(\"\\n\")){\r\n\t\t\tline=stripAnsi(line);\r\n\t\t\tline=time+\" [\"+id+\"] \"+line+\"\\n\";\r\n\t\t\tlist.push(line);\r\n\t\t}\r\n\t\tawait Deno.writeTextFile(\"foundry.log\",list.join(),{append:true});\r\n\t}\r\n}\r\n\r\nasync function flush() {\r\n\tconst delay = roha.config.slow ? slowMillis : 0;\r\n\tfor (const line of printBuffer) {\r\n\t\tconsole.log(line);\r\n\t\tlog(line,\"model\");\r\n\t}\r\n\tprintBuffer=[];\r\n\tfor (const line of outputBuffer) {\r\n\t\tconsole.log(line);\r\n\t\tlog(line,\"stdout\");\r\n\t\tawait sleep(delay);\r\n\t}\r\n\toutputBuffer=[];\r\n}\r\n\r\nfunction wordWrap(text,cols=terminalColumns){\r\n\tvar result=[];\r\n\tvar pos=0;\r\n\twhile(pos<text.length){\r\n\t\tlet line=text.substring(pos,pos+cols);\r\n\t\tlet n=line.length;\r\n\t\tif(n==cols){\r\n\t\t\tvar i=line.lastIndexOf(\" \",n);\r\n\t\t\tif(i>0){\r\n\t\t\t\tline=line.substring(0,i);\r\n\t\t\t\tn=i+1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tresult.push(line);\r\n\t\tpos+=n;\r\n\t}\r\n\treturn result.join(\"\\n\");\r\n}\r\n\r\n// main roha application starts here\r\n\r\nconst MaxFileSize=65536;\r\n\r\nconst appDir = Deno.cwd();\r\nconst rohaPath = resolve(appDir,\"foundry.json\");\r\nconst accountsPath = resolve(appDir,\"accounts.json\");\r\nconst forgePath=resolve(appDir,\"forge\");\r\n\r\nconst modelAccounts = JSON.parse(await Deno.readTextFile(accountsPath));\r\n\r\nasync function pathExists(path) {\r\n\ttry {\r\n\t\tconst stat = await Deno.stat(path);\r\n\t\tif (!stat.isFile) return false;\r\n\t\treturn true;\r\n\t} catch (error) {\r\n\t\tif (error instanceof Deno.errors.NotFound) return false;\r\n\t\tif (error instanceof Deno.errors.PermissionDenied) return false;\r\n\t\tthrow error;\r\n\t}\r\n}\r\n\r\nconst fileExists = await pathExists(rohaPath);\r\nif (!fileExists) {\r\n\tawait Deno.writeTextFile(rohaPath, JSON.stringify(emptyRoha));\r\n\techo(\"Created new\",rohaPath);\r\n}\r\n\r\nconst rohaAccount={};\r\nfor(let account in modelAccounts){\r\n\tlet endpoint = await connectAccount(account);\r\n\tif(endpoint) rohaAccount[account]=endpoint;\r\n}\r\n\r\nfunction stringify(value, seen = new WeakSet(), keyName = \"\") {\r\n\tif (typeof value === \"string\") return value;\r\n\tif (value === null || typeof value !== \"object\") return String(value);\r\n\tif (typeof value === \"function\") return \"[function]\";\r\n\tif (seen.has(value)) return keyName ? `[circular (${keyName})]` :\"[circular]\";\r\n\tseen.add(value);\r\n\tif (Array.isArray(value)) {\r\n\t\tconst items = value.map((item, index) => stringify(item, seen,\r\n\t\tString(index)));\r\n\t\treturn `[${items.join(\",\\n\")}]`;\r\n\t}\r\n\tconst entries = Object.entries(value).map(([key, val]) => `${key}: ${stringify(val, seen, key)}`);\r\n\treturn `{${entries.join(\",\\n\")}}`;\r\n}\r\n\r\nasync function connectAccount(account) {\r\n\tlet verbose=false;//roha.config.verbose;\r\n\techo(\"Connecting to account:\", account);\r\n\tconst config = modelAccounts[account];\r\n\tif (!config) return null;\r\n\ttry{\r\n\t\tconst apiKey = Deno.env.get(config.env);\r\n\t\tconst endpoint = new OpenAI({ apiKey, baseURL: config.url });\r\n\t\tif(verbose){\r\n\t\t\tfor(const [key, value] of Object.entries(endpoint)){\r\n\t\t\t\tlet content=stringify(value);\r\n\t\t\t\techo(\"endpoint:\"+key+\":\"+content);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst models = await endpoint.models.list();\r\n\t\tconst list=[];\r\n\t\tfor (const model of models.data) {\r\n\t\t\tlet name=model.id+\"@\"+account;\r\n\t\t\tlist.push(name);\r\n\t\t\tif(verbose) echo(\"model - \",JSON.stringify(model,null,\"\\t\"));\r\n\t\t}\r\n\t\tlist.sort();\r\n\t\tmodelList=modelList.concat(list);\r\n\t\treturn endpoint;\r\n\t}catch(error){\r\n\t// Error: 429 \"Your team ac0a3c9a-0e58-4e3c-badd-be853c027a7f has either used all available credits or \r\n\t// reached its monthly spending limit. To continue making API requests, please purchase more credits or \r\n\t// raise your spending limit.\"\r\n\t\techo(error);\r\n\t}\r\n\treturn null;\r\n}\r\n\r\nasync function resetModel(name){\r\n\tgrokModel=name;\r\n\tgrokFunctions=true;\r\n\trohaHistory.push({role:\"system\",content:\"Model changed to \"+name+\".\"});\r\n\techo(\"with model\",name,grokFunctions)\r\n\tawait writeRoha();\r\n}\r\n\r\nfunction dropShares(){\r\n\tfor(let item of rohaHistory){\r\n\t\tif(item && item.role===\"user\" && item.user===\"forge\"){\r\n\t\t\titem.user=\"drop\";\r\n\t\t\titem.content=\"dropped path \"+(item.path||\"\");\t\t\t\r\n\t\t}\r\n\t}\r\n\trohaShares=[];\r\n\techo(\"all shares dropped\");\r\n}\r\n\r\nfunction listShare(){\r\n\tconst list=[];\r\n\tlet count=0;\r\n\tlet sorted = roha.sharedFiles.slice();\r\n\tsorted.sort((a, b) => b.size - a.size);\r\n\tfor (const share of sorted) {\r\n\t\tlet shared=(rohaShares.includes(share.path))?\"*\":\"\";\r\n\t\tlet tags=\"[\"+share.tag+\"]\";\r\n\t\tlet info=(share.description)?share.description:\"\";\r\n\t\techo((count++),share.path,share.size,shared,tags,info);\r\n\t\tlist.push(share.id);\r\n\t}\r\n\tshareList=list;\r\n}\r\n\r\nfunction listSaves(){\r\n\tlet saves=roha.saves||[];\r\n\tfor(let i=0;i<saves.length;i++){\r\n\t\techo(i,saves[i]);\r\n\t}\r\n}\r\n\r\nasync function saveHistory(name) {\r\n\ttry {\r\n\t\tlet timestamp=Math.floor(Date.now()/1000).toString(16);\r\n\t\tlet filename=(name||\"transmission-\"+timestamp)+\".json\";\r\n\t\tlet filePath = resolve(forgePath,filename);\r\n\t\tlet line=\"Saved session \"+filename+\".\";\r\n\t\trohaHistory.push({role:\"system\",content:line});\r\n\t\tawait Deno.writeTextFile(filePath,JSON.stringify(rohaHistory,null,\"\\t\"));\r\n\t\techo(line);\r\n\t\troha.saves.push(filename);\r\n\t\tawait writeRoha();\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error saving history:\", error.message);\r\n\t}\r\n}\r\n\r\nasync function loadHistory(filename){\r\n\tvar history;\r\n\ttry {\r\n\t\tconst fileContent = await Deno.readTextFile(filename);\r\n\t\thistory = JSON.parse(fileContent);\r\n\t\techo(\"History restored from \"+filename);\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error restoring history:\", error.message);\r\n\t\techo(\"console error\");\r\n\t\thistory=[{role:\"system\",content: \"You are a helpful assistant.\"}];\r\n\t}\r\n\treturn history;\r\n}\r\n\r\nconst ansiBackgrounds = [\r\n\t{ name: \"dark0\", code: \"\\x1b[48;5;232m\" }, // #1c2526\r\n\t{ name: \"dark1\", code: \"\\x1b[48;5;233m\" }, // #2e3436\r\n\t{ name: \"dark2\", code: \"\\x1b[48;5;234m\" }, // #3d4446\r\n\t{ name: \"dark3\", code: \"\\x1b[48;5;235m\" }, // #4e5456\r\n\t{ name: \"charcoal\", code: \"\\x1b[48;5;236m\" }, // #606668\r\n\t{ name: \"darkBlue\", code: \"\\x1b[48;5;17m\" }, // #00005f\r\n\t{ name: \"darkGreen\", code: \"\\x1b[48;5;23m\" }, // #003f3f\r\n\t{ name: \"darkMutedPurple\", code: \"\\x1b[48;5;54m\" }, // #5f00af\r\n\t{ name: \"veryDarkBlue\", code: \"\\x1b[48;5;18m\" }, // #000087\r\n\t{ name: \"darkCharcoal\", code: \"\\x1b[48;5;239m\" }, // #4e4e4e\r\n\t{ name: \"mutedNavy\", code: \"\\x1b[48;5;19m\" }, // #0000af\r\n\t{ name: \"deepGray\", code: \"\\x1b[48;5;240m\" } // #585858\r\n];\r\n\r\nconst ansiMoveToEnd = \"\\x1b[999B\";\r\nconst ansiSaveCursor = \"\\x1b[s\";\r\nconst ansiRestoreCursor = \"\\x1b[u\";\r\n\r\nconst ansiReplyBlock = ansiBackgrounds[0].code;\r\nconst ansiCodeBlock = ansiBackgrounds[6].code;\r\n\r\nconst rohaPrompt=\">\";\r\n\r\nconst ansiItalics = \"\\x1b[3m\";\r\nconst ansiReset = \"\\x1b[0m\";\r\nconst ansiPurple = \"\\x1b[1;35m\";\r\n\r\nfunction mdToAnsi(md) {\r\n\tlet broken=roha.config.broken;\r\n\tconst lines = md.split(\"\\n\");\r\n\tlet inCode = false;\r\n\tconst result = broken?[ansiReplyBlock]:[];\r\n\tfor (let line of lines) {\r\n\t\tline=line.trimEnd();\r\n\t\tlet trim=line.trim();\r\n\t\tif (trim.startsWith(\"```\")) {\r\n\t\t\tinCode = !inCode;\r\n\t\t\tif(inCode){\r\n\t\t\t\tresult.push(ansiCodeBlock);\r\n\t\t\t\tlet codeType=trim.substring(3);\r\n\t\t\t\techo(\"inCode \"+codeType);\r\n\t\t\t}else{\r\n\t\t\t\tif (broken) result.push(ansiReplyBlock);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif (!inCode) {\r\n\t\t\t\t// headershow\r\n\t\t\t\tconst header = line.match(/^#+/);\r\n\t\t\t\tif (header) {\r\n\t\t\t\t\tconst level = header[0].length;\r\n\t\t\t\t\tline = line.substring(level).trim();\r\n\t\t\t\t\tline = ansiPurple + line + ansiReset;\r\n\t\t\t\t}\r\n\t\t\t\t// bullets\r\n\t\t\t\tif (line.startsWith('-') || line.startsWith('*') || line.startsWith('+')) {\r\n\t\t\t\t\tline = '• ' + line.substring(1).trim();\r\n\t\t\t\t}\r\n\t\t\t\t// bold\r\n\t\t\t\tif (line.includes(\"**\")) {\r\n\t\t\t\t\tline = line.replace(/\\*\\*(.*?)\\*\\*/g, \"\\x1b[1m$1\\x1b[0m\");\r\n\t\t\t\t}\r\n\t\t\t\t// italic\r\n\t\t\t\tline = line.replace(/\\*(.*?)\\*/g, \"\\x1b[3m$1\\x1b[0m\");\r\n\t\t\t\tline = line.replace(/_(.*?)_/g, \"\\x1b[3m$1\\x1b[0m\");\r\n\t\t\t\t// wordwrap\r\n\t\t\t\tline=wordWrap(line,terminalColumns);\r\n\t\t\t}\r\n\t\t\tresult.push(line.trimEnd());\r\n\t\t}\r\n\t}\r\n\tresult.push(ansiReset);\r\n\treturn result.join(\"\\n\");\r\n}\r\n\r\nasync function hashFile(filePath) {\r\n\tconst fileContent = await Deno.readFile(filePath);\r\n\tconst hashBuffer = await crypto.subtle.digest(\"SHA-256\", fileContent);\r\n\tconst hashArray = new Uint8Array(hashBuffer);\r\n\treturn Array.from(hashArray).map(byte => byte.toString(16).padStart(2, '0')).join('');\r\n}\r\n\r\nasync function readRoha(){\r\n\ttry {\r\n\t\tconst fileContent = await Deno.readTextFile(rohaPath);\r\n\t\troha = JSON.parse(fileContent);\r\n\t\tif(!roha.saves) roha.saves=[];\r\n\t\tif(!roha.counters) roha.counters={};\r\n\t\tif(!roha.band) roha.band={};\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error reading or parsing\",rohaPath,error);\r\n\t\troha=emptyRoha;\r\n\t}\r\n}\r\n\r\nasync function writeRoha(){\r\n\ttry {\r\n\t\troha.model=grokModel;\r\n\t\tawait Deno.writeTextFile(rohaPath, JSON.stringify(roha, null, \"\\t\"));\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error writing\",rohaPath,error);\r\n\t}\r\n}\r\n\r\nasync function resetRoha(){\r\n\trohaShares = [];\r\n\troha.sharedFiles=[];\r\n\troha.tags={};\r\n\tif(roha.config.resetcounters) roha.counters={};\r\n\tincrement(\"resets\");\r\n\tawait writeRoha();\r\n\tresetHistory();\r\n\techo(\"resetRoha\",\"All shares and history reset.\");\r\n}\r\n\r\nfunction resolvePath(dir,filename){\r\n\tlet path=resolve(dir,filename);\r\n\tpath = path.replace(/\\\\/g, \"/\");\r\n\treturn path;\r\n}\r\n\r\n// a raw mode prompt replacement\r\n\r\n// arrow navigation and tab completion incoming\r\n\r\nconst reader = Deno.stdin.readable.getReader();\r\nconst writer = Deno.stdout.writable.getWriter();\r\n\r\nasync function prompt2(message) {\r\n\tif (message) {\r\n\t\tawait writer.write(encoder.encode(message));\r\n\t\tawait writer.ready;\r\n\t}\r\n\tDeno.stdin.setRaw(true);\r\n\tlet inputBuffer = new Uint8Array(0);\r\n\ttry {\r\n\t\twhile (true) {\r\n\t\t\tconst { value, done } = await reader.read();\r\n\t\t\tif (done || !value) break;\r\n\t\t\tfor (const byte of value) {\r\n\t\t\t\tif (byte === 0x7F || byte === 0x08) { // Backspace\r\n\t\t\t\t\tif (inputBuffer.length > 0) {\r\n\t\t\t\t\t\tinputBuffer = inputBuffer.slice(0, -1);\r\n\t\t\t\t\t\tawait writer.write(new Uint8Array([0x08, 0x20, 0x08])); // Erase last char\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (byte === 0x1b) { // Escape sequence\r\n\t\t\t\t\tif(value.length==1){\r\n\t\t\t\t\t\tDeno.exit(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(value.length==3){\r\n\t\t\t\t\t\tif(value[1]==0xf4 && value[2]==0x50){\r\n\t\t\t\t\t\t\techo(\"F1\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (byte === 0x0A || byte === 0x0D) { // Enter key\r\n\t\t\t\t\tawait writer.write(encoder.encode(\"\\r\\n\"));\r\n\t\t\t\t\tlet line = decoder.decode(inputBuffer);\r\n\t\t\t\t\tline=line.trim();\r\n\t\t\t\t\tlog(line,\"stdin\");\r\n\t\t\t\t\treturn line;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tawait writer.write(new Uint8Array([byte]));\r\n\t\t\t\t\tconst buf = new Uint8Array(inputBuffer.length + 1);\r\n\t\t\t\t\tbuf.set(inputBuffer);\r\n\t\t\t\t\tbuf[inputBuffer.length] = byte;\r\n\t\t\t\t\tinputBuffer = buf;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} finally {\r\n\t\tDeno.stdin.setRaw(false);\r\n\t}\r\n}\r\n\r\n// callers to addShare expected to await writeRoha after\r\n\r\nconst eventList=[];\r\n\r\nasync function watchPaths(paths,handler){\r\n\tconst watcher = Deno.watchFs(paths,{recursive:false});\r\n\tfor await (const event of watcher) {\r\n\t\teventList.push(event);\r\n\t}\r\n}\r\n\r\nasync function addShare(share){\r\n\tshare.id=\"share\"+increment(\"shares\");\r\n\troha.sharedFiles.push(share);\r\n\tif(share.tag) {\r\n\t\tawait setTag(share.tag,share.id);\r\n\t}\r\n}\r\n\r\nasync function shareDir(dir,tag) {\r\n\ttry {\r\n\t\tconst paths=[];\r\n\t\tconst files = await Deno.readDir(dir);\r\n\t\tfor await (const file of files) {\r\n\t\t\tif (file.isFile && !file.name.startsWith(\".\")) {\r\n\t\t\t\tpaths.push(resolvePath(dir, file.name));\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const path of paths) {\r\n//\t\t\techo(\"statting path:\"+path+\":\");\r\n\t\t\tconst info = await Deno.stat(path);\r\n\t\t\tlet size=info.size;\r\n\t\t\tlet modified=info.mtime.getTime();\r\n\t\t\tconst hash = await hashFile(path);\r\n\t\t\tawait addShare({path,size,modified,hash,tag})\r\n\t\t}\r\n\t\tawait writeRoha(); // TODO: check a dirty flag\r\n\t} catch (error) {\r\n\t\tconsole.error(\"### Error\"+error);\r\n\t}\r\n}\r\n\r\nfunction fileType(extension){\r\n\treturn contentType(extension) || 'application/octet-stream';\r\n}\r\n\r\nconst textExtensions = [\r\n\t\"js\", \"txt\", \"json\", \"md\",\r\n\t\"css\",\"html\", \"svg\",\r\n\t\"cpp\", \"c\", \"h\", \"cs\",\r\n\t\"sh\", \"bat\",\r\n\t\"log\",\"py\",\"csv\",\"xml\",\"ini\"\r\n];\r\n\r\nasync function shareFile(path,tag) {\r\n\tlet fileContent=null;\r\n\ttry {\r\n\t\tfileContent = await Deno.readFile(path);\r\n\t} catch (error) {\r\n\t\tconsole.error(\"shareFile path:\"+path+\" error:\", error);\r\n\t\treturn;\r\n\t}\r\n\tif(path.endsWith(\"rules.txt\")){\r\n\t\tlet lines=decoder.decode(fileContent).split(\"\\n\");\r\n\t\tfor(let line of lines ){\r\n\t\t\tif (line) rohaHistory.push({role:\"system\",content: line});\r\n\t\t}\r\n\t}else{\r\n\t\tconst length=fileContent.length;\r\n\t\tif(length>0 && length<MaxFileSize){\r\n\t\t\tconst extension = path.split('.').pop();\r\n\t\t\tconst type = fileType(extension);\r\n\t\t\tif (textExtensions.includes(extension)) {\r\n\t\t\t\tlet txt = decoder.decode(fileContent);\r\n\t\t\t\tif(txt.length){\r\n\t\t\t\t\tlet metadata=JSON.stringify({path,length,type,tag});\r\n\t\t\t\t\trohaPush(metadata);\r\n\t\t\t\t\trohaPush(txt,\"forge\");\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tconst base64Encoded = btoa(String.fromCharCode(...new Uint8Array(fileContent)));\r\n\t\t\t\tconst mimeType = fileType(extension);\r\n\t\t\t\tlet metadata=JSON.stringify({path,length,type,mimeType,tag});\r\n\t\t\t\trohaPush(metadata);\r\n\t\t\t\tlet binary=`File content: MIME=${mimeType}, Base64=${base64Encoded}`;\r\n\t\t\t\trohaPush(binary,\"forge\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n//\tif(roha.config.verbose)echo(\"roha shared file \" + path);\r\n\tif (!rohaShares.includes(path)) rohaShares.push(path);\r\n}\r\n\r\nasync function commitShares(tag) {\r\n\tlet dirty = false;\r\n\tconst validShares = [];\r\n\tconst removedPaths = [];\r\n\tfor (const share of roha.sharedFiles) {\r\n\t\tif (tag && share.tag !== tag) {\r\n\t\t\tvalidShares.push(share);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tconst info = await Deno.stat(share.path);\r\n\t\t\tconst modified = share.modified !== info.mtime.getTime();\r\n\t\t\tconst isShared = rohaShares.includes(share.path);\r\n\t\t\tif (modified || !isShared) {\r\n\t\t\t\tawait shareFile(share.path,tag);\r\n\t\t\t\tshare.modified = info.mtime.getTime();\r\n\t\t\t\tdirty = true;\r\n\t\t\t}\r\n\t\t\tvalidShares.push(share);\r\n\t\t} catch (error) {\r\n\t\t\tremovedPaths.push(share.path);\r\n\t\t\tdirty = true;\r\n\t\t}\r\n\t}\r\n\r\n\tif (removedPaths.length) {\r\n\t\troha.sharedFiles = validShares;\r\n\t\tawait writeRoha();\r\n\t\techo(`Invalid shares detected:\\n${removedPaths.join('\\n')}`);\r\n\t}\r\n\r\n\tif (dirty&&tag) {\r\n\t\tlet invoke=\"feel free to call annotate_foundry to tag \"+tag;\r\n\t\trohaHistory.push({role:\"system\",content:invoke});\r\n\t}\r\n\r\n\treturn dirty;\r\n}\r\n\r\nasync function setTag(name,note){\r\n\tlet tags=roha.tags||{};\r\n\tlet tag=(tags[name])?tags[name]:{name,info:[]};\r\n\ttag.info.push(note);\r\n\ttags[name]=tag;\r\n\troha.tags=tags;\r\n\tawait writeRoha();\r\n//\tlet invoke=`New tag \"${name}\" added. Describe all shares with this tag.`;\r\n//\trohaHistory.push({role:\"system\",content:invoke});\r\n}\r\nfunction listCounters(){\r\n\tlet keys=Object.keys(roha.counters);\r\n\tlet i=0;\r\n\tfor(let key of keys){\r\n\t\tlet count=roha.counters[key];\r\n\t\techo((i++),key,count);\r\n\t}\r\n}\r\nfunction listTags(){\r\n\tlet tags=roha.tags||{};\r\n\tlet keys=Object.keys(tags);\r\n\tlet list=[];\r\n\tfor(let i=0;i<keys.length;i++){\r\n\t\tlet tag=tags[keys[i]];\r\n\t\tconst name=tag.name||\"?????\";\r\n\t\techo(i,name,\"(\"+tag.info.length+\")\");\r\n\t\tlet info=tag.description;\r\n\t\tif(info) echo(\"\",info);\r\n\t\tlist.push(name);\r\n\t}\r\n\ttagList=list;\r\n}\r\n\r\nfunction listAccounts(){\r\n\tlet list=[];\r\n\tfor(let key in modelAccounts){\r\n\t\tlet value=modelAccounts[key];\r\n\t\tlist.push(key);\r\n\t}\r\n\tfor(let i=0;i<list.length;i++){\r\n\t\techo(i,list[i]);\r\n\t}\r\n}\r\n\r\nasync function showHelp() {\r\n\ttry {\r\n\t\tconst md = await Deno.readTextFile(\"foundry.md\");\r\n\t\techo(mdToAnsi(md));\r\n\t} catch (e) {\r\n\t\techo(\"Error loading help file: \" + e.message);\r\n\t}\r\n}\r\n\r\nfunction readable(text){\r\n\ttext=text.replace(/\\s+/g, \" \");\r\n\treturn text;\r\n}\r\n\r\nasync function callCommand(command) {\r\n\tlet dirty=false;\r\n\tlet words = command.split(\" \",2);\r\n\ttry {\r\n\t\tswitch (words[0]) {\r\n\t\t\tcase \"band\":\r\n\t\t\t\tlistBand();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"counter\":\r\n\t\t\t\tlistCounters();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"tag\":\r\n\t\t\t\tawait listTags();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"account\":\r\n\t\t\t\tawait listAccounts();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"help\":\r\n\t\t\t\tawait showHelp();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"config\":\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\tlet flag=words[1].trim();\r\n\t\t\t\t\tif(flag.length && !isNaN(flag)){\r\n\t\t\t\t\t\tflag=Object.keys(flagNames)[flag|0];\r\n\t\t\t\t\t\techo(\"flag\",flag);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(flag in flagNames){\r\n\t\t\t\t\t\troha.config[flag]=!roha.config[flag];\r\n\t\t\t\t\t\techo(flag+\" - \"+flagNames[flag]+\" is \"+(roha.config[flag]?\"true\":\"false\"));\r\n\t\t\t\t\t\tawait writeRoha();\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlet count=0;\r\n\t\t\t\t\tfor(let flag in flagNames){\r\n\t\t\t\t\t\techo((count++),flag,\":\",flagNames[flag],\":\",(roha.config[flag]?\"true\":\"false\"))\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistCommand=\"config\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"time\":\r\n\t\t\t\techo(\"Current time:\", new Date().toString());\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"history\":\r\n\t\t\t\tlistHistory();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"load\":\r\n\t\t\t\tlet save=words[1];\r\n\t\t\t\tif(save){\r\n\t\t\t\t\tif(save.length && !isNaN(save)) save=roha.saves[save|0];\r\n\t\t\t\t\tif(roha.saves.includes(save)){\r\n\t\t\t\t\t\tlet history=await loadHistory(save);\r\n\t\t\t\t\t\trohaHistory=history;\r\n\t\t\t\t\t\techo(\"a new history is set\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlistSaves();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"save\":\r\n\t\t\t\tlet savename=words.slice(1).join(\" \");\r\n\t\t\t\tsaveHistory(savename);\r\n\t\t\t\tawait writeRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"model\":\r\n\t\t\t\tlet name=words[1];\r\n\t\t\t\tif(name){\r\n\t\t\t\t\tif(name.length&&!isNaN(name)) name=modelList[name|0];\r\n\t\t\t\t\tif(modelList.includes(name)){\r\n\t\t\t\t\t\tresetModel(name);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor(let i=0;i<modelList.length;i++){\r\n\t\t\t\t\t\tlet name=modelList[i];\r\n\t\t\t\t\t\tlet attr=(name==grokModel)?\"*\":\"\";\r\n\t\t\t\t\t\techo(i,name,attr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistCommand=\"model\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"reset\":\r\n\t\t\t\tawait resetRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"cd\":\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\tconst newDir = words[1];\r\n\t\t\t\t\tif (newDir.length) Deno.chdir(newDir);\r\n\t\t\t\t}\r\n\t\t\t\tcurrentDir = Deno.cwd();\r\n\t\t\t\techo(\"Changed directory to\", currentDir);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"dir\":\r\n\t\t\t\tconst files = Deno.readDirSync(currentDir);\r\n\t\t\t\techo(\"Contents of\", currentDir + \":\");\r\n\t\t\t\tfor (const file of files) {\r\n\t\t\t\t\tlet name=(file.isDirectory)?\"[\"+file.name+\"]\":file.name;\r\n\t\t\t\t\techo(name);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"drop\":\r\n\t\t\t\tdropShares();\r\n\t\t\t\tawait writeRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"share\":\r\n\t\t\t\tif (words.length==1){\r\n\t\t\t\t\tlistShare();\r\n\t\t\t\t}else{\r\n\t\t\t\t\tconst filename = words.slice(1).join(\" \");\r\n\t\t\t\t\tconst path = resolvePath(Deno.cwd(), filename);\r\n\t\t\t\t\tconst info = await Deno.stat(path);\r\n\t\t\t\t\tconst tag = await prompt2(\"Enter tag name (optional):\");\r\n\t\t\t\t\tif(info.isDirectory){\r\n\t\t\t\t\t\techo(\"Share directory path:\",path);\r\n\t\t\t\t\t\tawait shareDir(path,tag);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlet size=info.size;\r\n\t\t\t\t\t\tlet modified=info.mtime.getTime();\r\n\t\t\t\t\t\techo(\"Share file path:\",path,\" size:\",info.size,\" \");\r\n\t\t\t\t\t\tconst hash = await hashFile(path);\r\n\t\t\t\t\t\techo(\"hash:\",hash);\r\n\t\t\t\t\t\tawait addShare({path,size,modified,hash,tag});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tawait writeRoha();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"push\":\r\n\t\t\tcase \"commit\":\r\n\t\t\t\tlet tag=\"\";\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\ttag=words[1];\r\n\t\t\t\t}\r\n\t\t\t\tdirty=await commitShares(tag);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\techo(\"Command not recognised\");\r\n\t\t\t\treturn false; // Command not recognized\r\n\t\t}\r\n\t} catch (error) {\r\n\t\techo(\"Error processing command:\", error.message);\r\n\t}\r\n\tincrement(\"calls\");\r\n\treturn dirty;\r\n}\r\n\r\necho(rohaTitle,\"running from \"+rohaPath);\r\nawait readRoha();\r\n\r\nlet grokModel = roha.model||\"deepseek-chat@deepseek\";\r\nlet grokFunctions=true;\r\nlet grokUsage = 0;\r\n\r\necho(\"present [\",grokModel,\"]\");\r\necho(\"shares count:\",roha.sharedFiles.length)\r\necho(\"use /help for latest and exit to quit\");\r\necho(\"\");\r\n\r\nlet sessions=increment(\"sessions\");\r\nif(sessions==0){\r\n\tlet welcome=await Deno.readTextFile(\"welcome.txt\");\r\n\techo(welcome);\r\n\tawait writeRoha();\r\n}\r\n\r\nif(roha.config){\r\n\tif(roha.config.commitonstart) await commitShares();\r\n}else{\r\n\troha.config={};\r\n}\r\n\r\nfunction extensionForType(contentType) {\r\n\tif (contentType.includes(\"markdown\")) return \".md\";\r\n\tif (contentType.includes(\"json\")) return \".json\";\r\n\tif (contentType.includes(\"javascript\")) return \".js\";\r\n\treturn \".txt\";\r\n}\r\n\r\nasync function onCall(toolCall) {\r\n\tlet verbose=roha.config.verbose;\r\n\tswitch(toolCall.function.name) {\r\n\t\tcase \"read_time\":\r\n\t\t\treturn {time: new Date().toISOString()};\r\n\t\tcase \"submit_file\":\r\n\t\t\tlet args=JSON.parse(toolCall.function.arguments);\r\n\t\t\techo(args.contentType);\r\n\t\t\tif (verbose) echo(args.content);\r\n\t\t\tlet timestamp=Math.floor(Date.now()/1000).toString(16);\r\n\t\t\tlet extension=extensionForType(args.contentType)\r\n\t\t\tlet name= \"submission-\"+timestamp+extension;\r\n\t\t\tlet filePath = resolve(forgePath,name);\r\n\t\t\tawait Deno.writeTextFile(filePath, args.content);\r\n\t\t\techo(\"File saved to:\", filePath);\r\n\t\t\treturn { success: true, path: filePath };\r\n\t\tcase \"annotate_foundry\":\r\n\t\t\ttry {\r\n\t\t\t\tconst { name, type, description } = JSON.parse(toolCall.function.arguments || \"{}\");\r\n\t\t\t\tswitch(type){\r\n\t\t\t\t\tcase \"tag\":\r\n\t\t\t\t\t\tannotateTag(name,description);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"share\":\r\n\t\t\t\t\t\tannotateShare(name,description);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tawait writeRoha(); // Persist changes\r\n\t\t\t\treturn { success: true, updated: 1 };\r\n\t\t\t} catch (error) {\r\n\t\t\t\techo(\"annotate_foundry error:\",error);\r\n\t\t\t\treturn { success: false, updated: 0 };\r\n\t\t\t}\r\n\t}\r\n\tconsole.error(\"onCall error - call simon\");\r\n}\r\n\r\nfunction squashMessages(history) {\r\n\tif (history.length < 2) return history;\r\n\tconst squashed = [history[0]];\r\n\tlet system=[];\r\n\tlet other=[];\r\n\tfor(let item of history){\r\n\t\tif(item.role==\"system\") system.push(item); else other.push(item);\r\n\t}\r\n\tfor(let list of [system,other]){\r\n\t\tlet last=null;\r\n\t\tfor (let i = 0; i < list.length; i++) {\r\n\t\t\tconst current=list[i];\r\n\t\t\tif(last){\r\n\t\t\t\tlast.content += \"\\n\" + current.content;\r\n\t\t\t} else {\r\n\t\t\t\tsquashed.push(current);\r\n\t\t\t\tlast=current;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn squashed;\r\n}\r\n\r\nasync function isolateCode(path,cwd) {\r\n\ttry {\r\n\t\tconst readAllow = `--allow-read=${cwd}`;\r\n\t\tconst writeAllow = `--allow-write=${cwd}`;\r\n\t\tconst cmd = [\"deno\", \"run\", \"--no-remote\", readAllow, writeAllow, path];\r\n\t\tconst process = Deno.run({ cmd, stdout: \"piped\", stderr: \"piped\" });\r\n\t\tconst [stdout, stderr] = await Promise.all([process.output(), process.stderrOutput()]);\r\n\t\tconst status = await process.status();\r\n\t\tprocess.close();\r\n\t\treturn {\r\n\t\t\tsuccess: status.success,\r\n\t\t\toutput: new TextDecoder().decode(stdout),\r\n\t\t\terror: new TextDecoder().decode(stderr)\r\n\t\t};\r\n\t} catch (err) {\r\n\t\treturn { success: false, output: \"\", error: err.message };\r\n\t}\r\n}\r\n\r\nasync function runCode(){\r\n\tlet result = await isolateCode(\"isolation/test.js\", \"isolation\");\r\n\t//echo(\"RunCode Result:\", result.success ? \"Success\" : \"Failed\");\r\n\tif (result.output) echo(\"[isolation] \", result.output);\r\n\tif (result.error) echo(\"Error:\", result.error);\r\n\t// todo: add save on exit\r\n}\r\n\r\nasync function relay() {\r\n\tconst verbose=roha.config.verbose;\r\n\ttry {\r\n\t\tconst modelAccount=grokModel.split(\"@\");\r\n\t\tlet model=modelAccount[0];\r\n\t\tlet account=modelAccount[1];\r\n\t\tlet endpoint=rohaAccount[account];\r\n\t\tlet usetools=grokFunctions&&roha.config.tools;\r\n\t\tconst payload = usetools?{ model, messages:rohaHistory, tools: rohaTools }:{ model, messages:squashMessages(rohaHistory) };\r\n\t\tconst completion = await endpoint.chat.completions.create(payload);\r\n\t\tif (completion.model != model) {\r\n\t\t\techo(\"[relay model alert model:\" + completion.model + \" grokModel:\" + grokModel + \"]\");\r\n\t\t\tgrokModel=completion.model+\"@\"+account;\r\n\t\t}\r\n\t\tif (verbose) {\r\n\t\t\t// echo(\"relay completion:\" + JSON.stringify(completion, null, \"\\t\"));\r\n\t\t}\r\n\t\tlet system = completion.system_fingerprint;\r\n\t\tlet usage = completion.usage;\r\n\t\tlet size = measure(rohaHistory);\r\n\t\tgrokUsage += usage.prompt_tokens | 0 + usage.completion_tokens | 0;\r\n\t\tlet status = \"[model \" + grokModel + \" \" + usage.prompt_tokens + \" \" + usage.completion_tokens + \" \" + grokUsage + \" \" + size + \"]\";\r\n\t\techo(status);\r\n\t\tvar reply = \"<blank>\";\r\n\t\tfor (const choice of completion.choices) {\r\n\t\t\tlet calls = choice.message.tool_calls;\r\n\t\t\t// choice has index message{role,content,refusal,annotations} finish_reason\r\n\t\t\tif (calls) {\r\n\t\t\t\tincrement(\"calls\");\r\n\t\t\t\techo(\"relay calls in progress\");\r\n\t\t\t\t// Generate tool_calls with simple, unique IDs\r\n\t\t\t\tconst toolCalls = calls.map((tool, index) => ({\r\n\t\t\t\t\tid: `call_${rohaCalls++}`,\r\n\t\t\t\t\ttype: \"function\",\r\n\t\t\t\t\tfunction: {\r\n\t\t\t\t\t\tname: tool.function.name,\r\n\t\t\t\t\t\targuments: tool.function.arguments || \"{}\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}));\r\n\t\t\t\t// Add assistant message with tool_calls\r\n\t\t\t\tlet content=choice.message.content || \"\";\r\n\t\t\t\trohaHistory.push({role:\"assistant\",content,tool_calls: toolCalls});\r\n\t\t\t\tif(verbose) echo(\"tooling \"+content);\r\n\t\t\t\t// Add tool responses\r\n\t\t\t\tfor (let i = 0; i < calls.length; i++) {\r\n\t\t\t\t\tconst tool = calls[i];\r\n\t\t\t\t\tconst result = await onCall(tool);\r\n\t\t\t\t\tif (result){\r\n\t\t\t\t\t\tlet content=JSON.stringify(result);\r\n\t\t\t\t\t\trohaHistory.push({\r\n\t\t\t\t\t\t\trole: \"tool\",\r\n\t\t\t\t\t\t\ttool_call_id: toolCalls[i].id,\r\n\t\t\t\t\t\t\tname: tool.function.name,\r\n\t\t\t\t\t\t\tcontent\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\techo(\"no oncall result\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn relay(); // Recursive call to process tool results\r\n\t\t\t}\r\n\t\t\treply = choice.message.content;\r\n\t\t\tif (roha.config && roha.config.ansi) {\r\n//\t\t\t\techo(ansiSaveCursor);\r\n\t\t\t\tprint(mdToAnsi(reply));\r\n//\t\t\t\techo(ansiRestoreCursor);\r\n\t\t\t} else {\r\n\t\t\t\tprint(wordWrap(reply));\r\n\t\t\t}\r\n\t\t}\r\n\t\trohaHistory.push({ role: \"assistant\", content: reply });\r\n\t} catch (error) {\r\n\t\tlet line=error.message || String(error);\r\n\t\t//Error during API call: Error: 400 \"This model's maximum prompt length is 131072 but the request contains 165547 tokens.\"\r\n\t\tif(line.includes(\"maximum prompt length\")){\r\n\t\t\techo(\"maximum prompt length exceeded, switch model or drop shares to continue\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconsole.error(\"Error during API call:\", error);\t\r\n\t\tif(grokFunctions){\r\n\t\t\techo(\"resetting grokFunctions\")\r\n\t\t\tgrokFunctions=false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nasync function chat() {\r\n\tdance:\r\n\twhile (true) {\r\n\t\tlet lines=[];\r\n//\t\techo(ansiMoveToEnd);\r\n\t\twhile (true) {\r\n\t\t\tawait flush();\r\n\t\t\tlet line=\"\";\r\n\t\t\tif(listCommand){\r\n\t\t\t\tline=await prompt2(\"#\");\r\n\t\t\t\tif(line.length && !isNaN(line)){\r\n\t\t\t\t\tlet index=line|0;\r\n\t\t\t\t\tawait callCommand(listCommand+\" \"+index);\r\n\t\t\t\t}\r\n\t\t\t\tlistCommand=\"\";\r\n\t\t\t}else{\r\n\t\t\t\tline=await prompt2(rohaPrompt);\r\n\t\t\t}\r\n\t\t\tif (line === '') {\r\n\t\t\t\tif(roha.config.returntopush && !lines.length) {\r\n\t\t\t\t\techo(\"auto pushing...\");\r\n\t\t\t\t\tawait callCommand(\"push\");\r\n\t\t\t\t\tawait relay();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (line === \"exit\") {\r\n\t\t\t\techo(\"Ending the conversation...\");\r\n\t\t\t\tbreak dance;\r\n\t\t\t}\r\n\t\t\tif (line.startsWith(\"/\")) {\r\n\t\t\t\tconst command = line.substring(1).trim();\r\n\t\t\t\tlet dirty=await callCommand(command);\r\n\t\t\t\tif(dirty){\r\n\t\t\t\t\tlines.push(\"Please review source for bugs and all content if notable changes detected, thanks.\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlines.push(line.trim());\r\n\t\t}\r\n\r\n\t\tif (lines.length){\r\n\t\t\tconst query=lines.join(\"\\n\");\r\n\t\t\tif(query.length){\r\n\t\t\t\trohaHistory.push({ role: \"user\", content: query });\r\n\t\t\t\tawait relay();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nDeno.addSignalListener(\"SIGINT\", () => {Deno.exit(0);});\r\n\r\n//only windows Deno.addSignalListener(\"SIGBREAK\", () => {echo(\"SIGBREAK\");});\r\n\r\nawait runCode(\"isolation/test.js\",\"isolation\");\r\n\r\nchat();\r\n\n{\"path\":\"C:/nitrologic/foundry/release/accounts.json\",\"length\":362,\"type\":\"application/json; charset=UTF-8\"}\n{\r\n\t\"gemini\":{\r\n\t\t\"env\":\"GEMINI_API_KEY\",\r\n\t\t\"url\":\"https://generativelanguage.googleapis.com/v1beta/openai\"\r\n\t},\r\n\t\"deepseek\":{\r\n\t\t\"env\":\"DEEPSEEK_API_KEY\",\r\n\t\t\"url\":\"https://api.deepseek.com\"\r\n\t},\r\n\t\"xai\": {\r\n\t\t\"env\": \"XAI_API_KEY\",\r\n\t\t\"url\": \"https://api.x.ai/v1\"\r\n\t},\r\n\t\"openai\": {\r\n\t\t\"env\": \"OPENAI_API_KEY\",\r\n\t\t\"url\": \"https://api.openai.com/v1\"\r\n\t}\r\n  }\r\n\n{\"path\":\"C:/nitrologic/foundry/release/foundry.md\",\"length\":2601,\"type\":\"text/markdown; charset=UTF-8\"}\n# foundry command line client\r\n\r\nA command line application designed to chat and share files.\r\n\r\n## foundry machine interface\r\n\r\nThe foundry functional interface uses tools and tool_calls.\r\n\r\nOnly recent models provide tools interface, foundry should fall \r\nback to a no tools completion mode.\r\n\r\nSee the OpenAI API spec for more tool role details.\r\n\r\n### read_time\r\n\r\n### submit_file\r\n\r\n### annotate_foundry\r\n\r\n## foundry user interface\r\n\r\ncommands with no arguments may often prompt for a # index from\r\nthe items displayed\r\n\r\n### /config\r\n\r\nToggle configuration flags.\r\n\r\nAdjust settings to suit current preferences.\r\n\r\nDefault values are typically:\r\n\r\n* 0 commitonstart : commit shared files on start : true\r\n* 1 ansi : markdown ANSI rendering : true\r\n* 2 slow : output at reading speed : true\r\n* 3 verbose : emit debug information : true\r\n* 4 broken : ansi background blocks : false\r\n* 5 logging : log all output to file : true\r\n* 6 resetcounters : at reset zero all counters : true\r\n\r\n### /share\r\n\r\nShare a file or folder with optional tag.\r\n\r\nFiles are added to the share list used by the /push /commit command.\r\n\r\n### /drop\r\n\r\nDrop all files currently shared\r\n\r\n### /push /commit\r\n\r\nRefresh shared files. \r\n\r\nDetects changes or deletions and updates the chat history.\r\n\r\nPosts new versions of file content if modified.\r\n\r\n### /reset\r\n\r\nClear all shared files and conversation history.\r\n\r\n### /history\r\n\r\nList a summary of recent conversation entries. \r\n\r\nProvides a quick overview of chat history.\r\n\r\n### /cd\r\n\r\nChange the working directory. \r\n\r\nUser can navigate to a desired directory for file operations.\r\n\r\n### /dir\r\n\r\nList the contents of the current working directory. \r\n\r\nHelps user view available files and folders to share.\r\n\r\n\r\n### /model\r\n\r\nSelect an AI model.\r\n\r\nUser can choose a model by name or index from the accounts available.\r\n\r\n### /counters\r\n\r\nList the internal application counters.\r\n\r\n### /tag\r\n\r\nDescribe all tags in use.\r\n\r\nDisplays tag name, count of shares tagged and description.\r\n\r\n### /account\r\n\r\nDisplay current account information.\r\n\r\n### /save [name]\r\n\r\nSave the current conversation history. \r\n\r\nCreates a snapshot file of the conversation.\r\n\r\nThe default name is currently .roa-save-HEX32_TIME.json\r\n\r\n### /load\r\n\r\nLoad a saved conversation history snapshot.\r\n\r\nUser can specify a save index or file name to restore previous chats.\r\n\r\n\r\n### /time\r\n\r\nDisplay the current system time. \r\n\r\nHelps user verify system status.\r\n\r\n### /help\r\n\r\nIf you are reading this file, it may be due to the use of this command.\r\n\r\nIf you still need help visit the project page.\r\n\n{\"path\":\"C:/nitrologic/foundry/release/LICENSE.txt\",\"length\":1753,\"type\":\"text/plain; charset=UTF-8\"}\nMIT License\r\n\r\nCopyright (c) 2025 Simon Armstrong\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is                                            \r\nfurnished to do so, subject to the following conditions:                                                         \r\n                                                                                                                 \r\nThe above copyright notice and this permission notice shall be included in all                                   \r\ncopies or substantial portions of the Software.                                                                  \r\n                                                                                                                 \r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                       \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                         \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                                      \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                           \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                                    \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE                                    \r\nSOFTWARE. \n{\"path\":\"C:/nitrologic/foundry/release/welcome.txt\",\"length\":481,\"type\":\"text/plain; charset=UTF-8\"}\npreceed with caution\r\n\r\n  o---/\\     /---o     \\---/     /---/\\     o---/\\     \\---o     /---/\\ \r\n  |    \\/   /    |     |    /   /    \\/    |    \\/   /    |     |    \\/ \r\n#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #\r\n\r\n\tWELCOME TO FOUNDRY\r\n\r\n\tA COMMAND LINE TOOL FOR CHATTING AND SHARING FILES\r\n\r\n\tTHE MAGIC WORD IS HAPUKA\r\n\r\n\tTHIS FILE IS PART OF THE ROHA CLIENT DISTRIBUTION\r\n\r\n#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #\r\n\n{\"path\":\"C:/nitrologic/foundry/release/forge/readme.txt\",\"length\":67,\"type\":\"text/plain; charset=UTF-8\"}\nlocal storage for shared files submitted for review by foundry rc1\n\n{\"path\":\"C:/nitrologic/foundry/release/isolation/readme.txt\",\"length\":103,\"type\":\"text/plain; charset=UTF-8\"}\na sandbox for foundry rc1 runs\r\n\r\nrun foundry run\r\n\r\nthis stuff is post rc1 - what is going on here?\r\n \n{\"path\":\"C:/nitrologic/foundry/release/isolation/test.js\",\"length\":180,\"type\":\"application/javascript; charset=UTF-8\"}\n\r\nfunction hexDate(){\r\n    let s=Date.now()/1e3|0;\r\n    return s.toString(16);\r\n}\r\n\r\nconsole.log(\"radio   live transmission\");\r\n\r\nconsole.log(hexDate());\r\nconsole.log(hexDate());\r\n\n{\"path\":\"C:/nitrologic/foundry/.gitignore\",\"length\":55,\"type\":\"application/octet-stream\",\"mimeType\":\"application/octet-stream\"}\nFile content: MIME=application/octet-stream, Base64=Zm91bmRyeS5sb2cKZm91bmRyeS5qc29uCnNhdmVzCnJlbGVhc2UKcmMxL2ZvdW5kcnkuZXhlCg==\n{\"path\":\"C:/nitrologic/foundry/build.bat\",\"length\":88,\"type\":\"application/x-msdownload\"}\ndeno compile --allow-run --allow-env --allow-net --allow-read --allow-write foundry.js\r\n\ni would like to prepare a report on the nitrologic foundry client\nBelow is a draft report on the Nitrologic Foundry Client:\n\n─────────────────────────────────────────────  \nNitrologic Foundry Client Report  \n─────────────────────────────────────────────\n\n1. Overview\n\nThe Nitrologic Foundry Client is a command‑line research client designed to interact with language models and manage file sharing. Written in JavaScript/TypeScript for execution with Deno, the client leverages several permissions (run, env, net, read, write) and is intended for experimentation with model evaluations, conversation histories, and file submission workflows.\n\n2. Key Features\n\n• Chat Interface and History Management  \n – The client provides an interactive prompt (using raw mode via Deno’s stdin reader) that accepts chat messages and commands.  \n – It maintains a conversation history (“rohaHistory”) for both user queries and model responses, allowing for conversation snapshots and history restoration via save and load functionality.  \n – A “relay” function communicates with model endpoints (using the OpenAI client libraries and several API providers such as GEMINI, DEEPSEEK, XAI, and OpenAI) and appears to support models that have tool call capabilities.\n\n• File Sharing and Submission  \n – The “/share” command enables users to designate files or directories for sharing. Individual files are processed (for text, JSON, markdown, etc.) or converted to Base64 for binary content.  \n – A sharing mechanism tracks file metadata (path, size, modification time, hash) and tags shared files.  \n – The client supports a “/push” or “/commit” command that scans shared files, detects modifications or deletions, and—if changes are detected—updates the chat history and files submitted for review.\n\n• Configuration and Customization  \n – Several configuration flags allow toggling features such as committing shares on start, ANSI rendering of markdown, slow output, verbose debugging information, and logging (to a file “foundry.log”).  \n – The “/config” command lists available flags, which include:  \n  • commitonstart  (commit shared files on start)  \n  • tools        (enable model tool interface)  \n  • ansi         (render using ANSI/markdown)  \n  • slow         (output at reading speed)  \n  • verbose       (emit debug information)  \n  • broken        (ansi background blocks via alternate colors)  \n  • logging       (log all output to file)  \n  • resetcounters  (reset counters on reset)  \n  • returntopush  (prompt to “push” when returning)\n\n• Model Management and Tooling Interface  \n – The client supports selecting models via the “/model” command. The list of available models is gathered from multiple API endpoints (configured in the “accounts.json” file) and stored in a list (“modelList”).  \n – It uses tool call functions if the selected model supports the tools interface. Three tool functions are defined:  \n  ○ read_time – returns current UTC time.  \n  ○ submit_file – submits a file for review by sending content type and file content, saving the file to a “forge” directory.  \n  ○ annotate_foundry – permits setting descriptions on objects like tags or shared files.  \n – The “relay” function is responsible for interfacing with the model. It prepares the payload (using either the simple chat history or a tool call JSON structure) and recursively handles tool call responses by executing the corresponding functions (via “onCall”) before forwarding the results back into the conversation cycle.\n\n3. Architecture and Workflow\n\n• Initialization and Configuration  \n – On startup, the client checks for a “foundry.json” state file, creating one with default settings if not present.  \n – It reads “accounts.json” to establish connections with the configured AI endpoints; these connections use API keys from environment variables.  \n – The client also initializes conversation history (rohaHistory) with a system prompt (“I am testing foundry client. You are a helpful assistant”).\n\n• File and Directory Operations  \n – Commands such as “/cd” and “/dir” allow the user to manage current working directories – aiding in file selection for sharing.  \n – The client uses Deno APIs for file operations, including reading, writing, statting files, and computing file hashes using SHA‑256.\n\n• Command Processing  \n – Input lines that begin with a “/” are interpreted as commands. Otherwise, they are treated as chat messages from the user.  \n – A command “callCommand” function handles a wide range of commands: listing accounts, toggling configuration flags, sharing files, managing tags, and handling model selection.\n – Commands such as “/reset” clear shared files and conversation history; “/history” lists recent conversation activities; “/save” and “/load” allow the user to persist or restore sessions.\n\n• ANSI and Markdown Rendering  \n – The client can render markdown content with ANSI escape sequences for styling (headers, bold, italics, bullets).  \n – There is a fallback plain output mode if ANSI rendering is not enabled.\n\n• Isolation and Sandbox Execution  \n – A helper function “isolateCode” is provided to run external JavaScript code (from an “isolation/test.js” file) in a sandboxed environment with restricted permissions. This supports a “runCode” routine that demonstrates isolated execution.\n\n4. Additional Files and Documentation\n\n• foundry.md – This markdown file provides an overview of the available commands and the machine interface (tool calls) for the client.\n• welcome.txt – A welcome banner displayed on startup.\n• LICENSE.txt and build.bat – These files establish project licensing (MIT License) and build instructions for compiling the Deno application.\n• The “forge” subdirectory is used for storing file submissions and conversation snapshots.\n• The “isolation” subdirectory contains a sandbox for testing code execution, distinct from the main workflow.\n\n5. Summary\n\nThe Nitrologic Foundry Client is a robust research tool designed for interacting with language models while integrating file sharing and conversation management. With its modular tool calls, command interface, and detailed configuration options, it becomes a flexible environment for testing model capabilities – particularly for those models that support an interactive tools interface. The design elegantly combines interactive terminal I/O, file system operations, and API integrations in a portable Deno runtime environment.\n\n─────────────────────────────────────────────  \nConcluding Remarks\n\nThe Foundry Client, as demonstrated by the provided source code and accompanying materials, reflects thoughtful design aimed at research and interactive testing. Its support for both chat-based interactions and contextual file sharing makes it well suited for scenarios where version tracking and iterative model evaluation are needed. Future enhancements—such as improved error handling, richer command completion (e.g., arrow navigation), and expanded tool integrations—could further extend its capabilities.\n\n─────────────────────────────────────────────  \nEnd of Report\n\nFeel free to adjust or expand any sections as needed for your reporting purposes.\nno way to verbose\nBelow is a report summarizing and analyzing the Nitrologic Foundry Client based on the source code and accompanying documentation.\n\n─────────────────────────────────────────────  \nNitrologic Foundry Client Report  \n─────────────────────────────────────────────\n\n1. Overview\n\nThe Nitrologic Foundry Client is an experimental command‑line research tool built on Deno. It is designed to facilitate model evaluation, interactive chat sessions, and file sharing. The client interacts with multiple language model endpoints (such as those provided by OpenAI, Deepseek, Gemini, and XAI) and supports both chat and file submission through a unified interface.\n\n2. Key Features\n\n• Interactive Chat Interface and Conversation History  \n – The client runs in a terminal and uses raw input mode to capture user commands and messages.  \n – Conversation history is maintained in an array (“rohaHistory”), starting with a system prompt that defines the client’s role.  \n – Users may save and reload conversation sessions, allowing for persistent session management.\n\n• File Sharing and Commit Workflow  \n – The “/share” command allows a user to submit either files or entire directories.  \n – Shared files are tracked via metadata including file path, size, modification time, and a computed SHA‑256 hash.  \n – A “/push” (or “/commit”) command scans the shared files for modifications or deletions, updates history, and integrates file “submissions” into the conversation for review.\n\n• Configurable Options and Command Set  \n – Multiple configuration flags control aspects such as:  \n  • Automatic file commit on start  \n  • ANSI-based markdown rendering for enhanced terminal output  \n  • Slow reading (output pacing), verbose logging, and even special “broken” modes for ANSI blocks  \n – Commands such as “/config” allow users to toggle these features.  \n – Additional commands include “/cd” (to change directory), “/dir” (to list files), “/model” (to select or switch language models), and “/reset” (to clear history and file shares).\n\n• Model and Tool Functionality  \n – The client supports model interactions using a “relay” function that sends the conversation history as a payload to the selected model endpoint.  \n – Some models support “tool calls,” and the client defines three tool functions:  \n  ○ read_time – Returns the current UTC time  \n  ○ submit_file – Accepts content and its MIME type to save a file in the local “forge” directory  \n  ○ annotate_foundry – Lets the user annotate or set descriptions on file shares or tags  \n – These tools support enhanced interactions when the underlying model can invoke external functions during a conversation.\n\n• ANSI and Markdown Rendering  \n – The client renders markdown content using ANSI escape sequences (for headers, bold, italics, and bullet lists), improving readability in terminal outputs when enabled.  \n – A fallback plain text mode is available if ANSI rendering is turned off.\n\n• Sandbox Code Execution  \n – A dedicated “isolation” module demonstrates running external JavaScript code in an isolated environment with limited permissions. This reinforces the client’s role as a research and testing platform.\n\n3. Architecture and Workflow\n\n• Initialization and Startup  \n – On launch, the client checks for a persistent state file (“foundry.json”). If not found, it creates a default configuration.  \n – It reads an “accounts.json” file to load provider configurations and uses environment variables to obtain API keys for connecting to endpoints.\n\n• Conversation Handling  \n – User input is processed in two categories: commands (prefixed with “/”) and regular chat messages.  \n – The “callCommand” function handles a variety of commands (e.g., file management, configuration toggles, model selection) and directs appropriate actions.  \n – The “relay” function packages the chat history (or a squashed version of it) and sends it to the AI endpoint using either a simple completion or a tool invocation model, with recursive handling of tool responses as needed.\n\n• File and Directory Management  \n – The client uses Deno’s filesystem API to change directories (“/cd”), list directory contents (“/dir”), and compute file hash values for file integrity checking.  \n – Shared files are maintained in an internal list (roha.sharedFiles) and include optional tags that can be annotated post sharing.\n\n• Configurability and Logging  \n – The client supports multiple configuration options stored within the state file, allowing toggles for behaviors such as automatic commit at startup and slow output pacing.  \n – There is also an option to log all output to a “foundry.log” file.\n\n4. Supporting Files and Documentation\n\n• foundry.md – A markdown document that describes available commands and the machine interface (tool calls) for the client.  \n• welcome.txt – Provides a graphical welcome message on startup.  \n• LICENSE.txt – Contains the MIT License terms under which the source is released.  \n• build.bat – A batch script to compile the application using Deno’s compile command, ensuring necessary permissions are granted.  \n• The “forge” directory – A local repository for submitted files and session snapshots.  \n• The “isolation” directory – Contains sandboxed test code that is executed at startup to verify isolated code execution capabilities.\n\n5. Summary and Concluding Remarks\n\nThe Nitrologic Foundry Client is a well-structured research tool merging interactive chat, file management, and model tool-call support. Its versatility lies in the ability to manage conversation sessions, track and submit file changes, and toggle between different aspects of its behavior with a simple command interface. The modular design—combining terminal I/O, file system manipulation, and API integration via Deno—makes it a useful platform for model evaluation and interactive research.\n\nFuture enhancements might include richer command-line navigation (such as arrow key support and auto-completion), improved error handling around API calls, and greater configurability for advanced users. As it stands, the Foundry Client provides a compelling example of combining AI interactivity with common file management tasks in a terminal-based environment.\n\n─────────────────────────────────────────────  \nEnd of Report\n\nFeel free to adjust or expand upon these sections based on further testing or additional project requirements.\nwould a git history of the original project help with a report on each functional block of code added to foundry.js\nYes, absolutely. A comprehensive git history would provide a detailed record of when and how each functional block was added or modified. This history can be invaluable for several reasons:\n\n• It provides commit messages and diffs that explain the intent behind changes. This context can help you understand the purpose and evolution of features like the chat interface, file sharing, configuration settings, and tooling integration.\n\n• You can trace the incremental changes made in each commit to see how different functionalities emerged. This would allow you to map certain commits to specific features (e.g., the addition of sandbox execution, ANSI rendering, or the tool_call interface).\n\n• It offers insight into debugging and performance improvements, as well as any architectural refactoring. For example, reviewing changes that affected error handling or logging could be useful in assessing the robustness of each component.\n\n• It aids in documenting the development process. You can refer to specific commits in your report to illustrate the evolution of Foundry.js, making your analysis more precise and informative.\n\nIn summary, leveraging the git history would indeed help produce a detailed report that covers each functional block of code added to Foundry.js, describing the evolution of the project and clarifying how its various capabilities came together over time.\nwhat is the git command to provide a list of diffs in historical order?\nYou can use \"git log -p\" to see a commit-by-commit diff. To list these diffs in chronological (oldest-to-newest) order, add the \"--reverse\" flag:\n\n  git log --reverse -p\n\nThis command will show each commit’s changes (patches) starting with the oldest.\nPlease review source for bugs and all content if notable changes detected, thanks."
	},
	{
		"role": "user",
		"name": "forge",
		"content": "// foundry.js\r\n// a research client for evaluating models\r\n// (c)2025 Simon Armstrong\r\n\r\n// deno run --allow-run --allow-env --allow-net --allow-read --allow-write roha.js\r\n\r\nimport { contentType } from \"https://deno.land/std@0.224.0/media_types/mod.ts\";\r\nimport { resolve } from \"https://deno.land/std/path/mod.ts\";\r\nimport OpenAI from \"https://deno.land/x/openai@v4.67.2/mod.ts\";\r\n\r\nconst foundryVersion = \"rc1\";\r\nconst rohaTitle=\"foundry \"+foundryVersion;\r\nconst rohaMihi=\"I am testing foundry client. You are a helpful assistant.\";\r\n\r\nconst slowMillis = 20;\r\n\r\nconst decoder = new TextDecoder(\"utf-8\");\r\nconst encoder = new TextEncoder();\r\n\r\nconst terminalColumns=120;\r\n\r\nconst flagNames={\r\n\tcommitonstart : \"commit shared files on start\",\r\n\ttools : \"enable model tool interface\",\r\n\tansi : \"markdown ANSI rendering\",\r\n\tslow : \"output at reading speed\",\r\n\tverbose : \"emit debug information\",\r\n\tbroken : \"ansi background blocks\",\r\n\tlogging : \"log all output to file\",\r\n\tresetcounters : \"factory reset when reset\",\r\n\treturntopush : \"hit return to /push - it is under test\"\r\n};\r\n\r\nconst emptyRoha={\r\n\tconfig:{\r\n\t\tcommitonstart:true,\r\n\t\tansi:true,\r\n\t\tslow:false,\r\n\t\tverbose:false,\r\n\t\tbroken:false,\r\n\t\tlogging:false,\r\n\t\tresetcounters:false,\r\n\t\treturntopush:false\r\n\t},\r\n\ttags:{},\r\n\tmodels:{},\r\n\tband:{},\r\n\tsharedFiles:[],\r\n\tsaves:[],\r\n\tcounters:{}\r\n};\r\n\r\nfunction addBand(){\r\n\tlet id=\"member\"+increment(\"members\");\r\n\troha.band[id]={};\r\n}\r\n\r\nfunction listBand(){\r\n\tlet band=[];\r\n\tfor(let id in roha.band){\r\n\t\tlet member=roha.band[id];\r\n\t\tband.push(member);\r\n\t}\r\n\tband.push(\"add\");\r\n\tfor(let i=0;i<band.length;i++){\r\n\t\techo(i,band[i]);\r\n\t}\r\n\tmemberList=band;\r\n}\r\n\r\nfunction annotateTag(name,description){\r\n\tif(!name){\r\n\t\tthrow(\"null name\");\r\n\t}\r\n\tif(!(name in roha.tags)) {\r\n\t\troha.tags[name]={};\r\n//\t\tthrow(\"tag not found \"+name);\r\n\t}\r\n\troha.tags[name].description=description;\r\n}\r\n\r\nfunction annotateShare(name,description){\r\n\tlet index=roha.sharedFiles.findIndex(item => item.id === name);\r\n\tif(index==-1) throw(\"share id not found\");\r\n\troha.sharedFiles[index].description=description;\r\n\techo(\"file share description annotated\");\r\n}\r\n\r\nfunction increment(key){\r\n\tlet i=0;\r\n\tif(key in roha.counters){\r\n\t\ti=roha.counters[key]+1;\r\n\t}\r\n\troha.counters[key]=i;\r\n\treturn i\r\n}\r\n\r\nvar tagList=[];\r\nvar modelList=[];\r\nvar shareList=[]; //typically biggest to smallest\r\nvar memberList=[];\r\n\r\nconst emptyModel={\r\n\tname:\"empty\",account:\"\",hidden:false,prompts:0,completion:0\r\n}\r\n\r\nconst emptyTag={\r\n}\r\n\r\n// const emptyShare={path,size,modified,hash,tag,id}\r\n\r\nlet roha=emptyRoha;\r\nlet rohaCalls=0;\r\nlet listCommand=\"\";\r\nlet rohaShares=[];\r\nlet currentDir = Deno.cwd();\r\nvar rohaHistory;\r\n\r\nfunction resetHistory(){\r\n\trohaHistory = [{role:\"system\",content:rohaMihi}];\r\n}\r\n\r\nfunction listHistory(){\r\n\tlet history=rohaHistory;\r\n\tfor(let i=0;i<history.length;i++){\r\n\t\tlet item=history[i];\r\n\t\tlet content=readable(item.content).substring(0,90)\r\n\t\techo(i,item.role,item.name||\"foundry\",\"-\",content);\r\n\t}\r\n\tif(roha.config.broken){\r\n\t\tlet flat=squashMessages(rohaHistory);\r\n\t\tfor(let i=0;i<flat.length;i++){\r\n\t\t\tlet item=flat[i];\r\n\t\t\tlet content=readable(item.content).substring(0,90);\r\n\t\t\techo(\"flat\",i,item.role,item.name||\"broken\",content);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction rohaPush(content,name=\"foundry\"){\r\n\trohaHistory.push({role:\"user\",name,content});\r\n}\r\n\r\nresetHistory();\r\n\r\n// roaTools\r\n\r\nconst rohaTools = [{\r\n\ttype: \"function\",\r\n\tfunction:{\r\n\t\tname: \"read_time\",\r\n\t\tdescription: \"Returns current time in UTC\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {},\r\n\t\t\trequired: []\r\n\t\t}\r\n\t}\r\n},{\r\n\ttype: \"function\",\r\n\tfunction:{\r\n\t\tname: \"submit_file\",\r\n\t\tdescription: \"Submit a file for review\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {\r\n\t\t\t\tcontentType:{type:\"string\"},\r\n\t\t\t\tcontent:{type:\"string\"}\r\n\t\t\t},\r\n\t\t\trequired: [\"contentType\",\"content\"]\r\n\t\t}\r\n\t}\r\n},{\r\n\ttype: \"function\",\r\n\tfunction: {\r\n\t\tname: \"annotate_foundry\",\r\n\t\tdescription: \"Set description of any object\",\r\n\t\tparameters: {\r\n\t\t\ttype: \"object\",\r\n\t\t\tproperties: {\r\n\t\t\t\tname: { type: \"string\" },\r\n\t\t\t\ttype: { type:\"string\" },\r\n\t\t\t\tdescription: { type: \"string\" }\r\n\t\t\t},\r\n\t\t\trequired: [\"name\",\"type\",\"description\"]\r\n\t\t}\r\n\t}\r\n}];\r\n\r\nasync function sleep(ms) {\r\n\tawait new Promise(function(resolve) {setTimeout(resolve, ms);});\r\n}\r\n\r\nfunction measure(o){\r\n\tlet total=JSON.stringify(o).length;\r\n\treturn total;\r\n}\r\n\r\nlet outputBuffer = [];\r\nlet printBuffer = [];\r\n\r\nfunction print(){\r\n\tlet args=arguments.length?Array.from(arguments):[];\r\n\tlet lines=args.join(\" \").split(\"\\n\");\r\n\tfor(let line of lines){\r\n\t\tprintBuffer.push(line.trimEnd());\r\n\t}\r\n}\r\n\r\nfunction echo(){\r\n\tlet args=arguments.length?Array.from(arguments):[];\r\n\tlet lines=args.join(\" \").split(\"\\n\");\r\n\tfor(let line of lines){\r\n\t\toutputBuffer.push(line.trimEnd());\r\n\t}\r\n}\r\n\r\nfunction stripAnsi(text) {\r\n\treturn text.replace(/\\x1B\\[\\d+(;\\d+)*[mK]/g, '');\r\n}\r\n\r\nasync function log(lines,id){\r\n\tif(roha.config.logging){\r\n\t\tconst time = new Date().toISOString();\r\n\t\tlet list=[];\r\n\t\tfor(let line of lines.split(\"\\n\")){\r\n\t\t\tline=stripAnsi(line);\r\n\t\t\tline=time+\" [\"+id+\"] \"+line+\"\\n\";\r\n\t\t\tlist.push(line);\r\n\t\t}\r\n\t\tawait Deno.writeTextFile(\"foundry.log\",list.join(),{append:true});\r\n\t}\r\n}\r\n\r\nasync function flush() {\r\n\tconst delay = roha.config.slow ? slowMillis : 0;\r\n\tfor (const line of printBuffer) {\r\n\t\tconsole.log(line);\r\n\t\tlog(line,\"model\");\r\n\t}\r\n\tprintBuffer=[];\r\n\tfor (const line of outputBuffer) {\r\n\t\tconsole.log(line);\r\n\t\tlog(line,\"stdout\");\r\n\t\tawait sleep(delay);\r\n\t}\r\n\toutputBuffer=[];\r\n}\r\n\r\nfunction wordWrap(text,cols=terminalColumns){\r\n\tvar result=[];\r\n\tvar pos=0;\r\n\twhile(pos<text.length){\r\n\t\tlet line=text.substring(pos,pos+cols);\r\n\t\tlet n=line.length;\r\n\t\tif(n==cols){\r\n\t\t\tvar i=line.lastIndexOf(\" \",n);\r\n\t\t\tif(i>0){\r\n\t\t\t\tline=line.substring(0,i);\r\n\t\t\t\tn=i+1;\r\n\t\t\t}\r\n\t\t}\r\n\t\tresult.push(line);\r\n\t\tpos+=n;\r\n\t}\r\n\treturn result.join(\"\\n\");\r\n}\r\n\r\n// main roha application starts here\r\n\r\nconst MaxFileSize=65536;\r\n\r\nconst appDir = Deno.cwd();\r\nconst rohaPath = resolve(appDir,\"foundry.json\");\r\nconst accountsPath = resolve(appDir,\"accounts.json\");\r\nconst forgePath=resolve(appDir,\"forge\");\r\n\r\nconst modelAccounts = JSON.parse(await Deno.readTextFile(accountsPath));\r\n\r\nasync function pathExists(path) {\r\n\ttry {\r\n\t\tconst stat = await Deno.stat(path);\r\n\t\tif (!stat.isFile) return false;\r\n\t\treturn true;\r\n\t} catch (error) {\r\n\t\tif (error instanceof Deno.errors.NotFound) return false;\r\n\t\tif (error instanceof Deno.errors.PermissionDenied) return false;\r\n\t\tthrow error;\r\n\t}\r\n}\r\n\r\nconst fileExists = await pathExists(rohaPath);\r\nif (!fileExists) {\r\n\tawait Deno.writeTextFile(rohaPath, JSON.stringify(emptyRoha));\r\n\techo(\"Created new\",rohaPath);\r\n}\r\n\r\nconst rohaAccount={};\r\nfor(let account in modelAccounts){\r\n\tlet endpoint = await connectAccount(account);\r\n\tif(endpoint) rohaAccount[account]=endpoint;\r\n}\r\n\r\nfunction stringify(value, seen = new WeakSet(), keyName = \"\") {\r\n\tif (typeof value === \"string\") return value;\r\n\tif (value === null || typeof value !== \"object\") return String(value);\r\n\tif (typeof value === \"function\") return \"[function]\";\r\n\tif (seen.has(value)) return keyName ? `[circular (${keyName})]` :\"[circular]\";\r\n\tseen.add(value);\r\n\tif (Array.isArray(value)) {\r\n\t\tconst items = value.map((item, index) => stringify(item, seen,\r\n\t\tString(index)));\r\n\t\treturn `[${items.join(\",\\n\")}]`;\r\n\t}\r\n\tconst entries = Object.entries(value).map(([key, val]) => `${key}: ${stringify(val, seen, key)}`);\r\n\treturn `{${entries.join(\",\\n\")}}`;\r\n}\r\n\r\nasync function connectAccount(account) {\r\n\tlet verbose=false;//roha.config.verbose;\r\n\techo(\"Connecting to account:\", account);\r\n\tconst config = modelAccounts[account];\r\n\tif (!config) return null;\r\n\ttry{\r\n\t\tconst apiKey = Deno.env.get(config.env);\r\n\t\tconst endpoint = new OpenAI({ apiKey, baseURL: config.url });\r\n\t\tif(verbose){\r\n\t\t\tfor(const [key, value] of Object.entries(endpoint)){\r\n\t\t\t\tlet content=stringify(value);\r\n\t\t\t\techo(\"endpoint:\"+key+\":\"+content);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst models = await endpoint.models.list();\r\n\t\tconst list=[];\r\n\t\tfor (const model of models.data) {\r\n\t\t\tlet name=model.id+\"@\"+account;\r\n\t\t\tlist.push(name);\r\n\t\t\tif(verbose) echo(\"model - \",JSON.stringify(model,null,\"\\t\"));\r\n\t\t}\r\n\t\tlist.sort();\r\n\t\tmodelList=modelList.concat(list);\r\n\t\treturn endpoint;\r\n\t}catch(error){\r\n\t// Error: 429 \"Your team ac0a3c9a-0e58-4e3c-badd-be853c027a7f has either used all available credits or \r\n\t// reached its monthly spending limit. To continue making API requests, please purchase more credits or \r\n\t// raise your spending limit.\"\r\n\t\techo(error);\r\n\t}\r\n\treturn null;\r\n}\r\n\r\nasync function resetModel(name){\r\n\tgrokModel=name;\r\n\tgrokFunctions=true;\r\n\trohaHistory.push({role:\"system\",content:\"Model changed to \"+name+\".\"});\r\n\techo(\"with model\",name,grokFunctions)\r\n\tawait writeRoha();\r\n}\r\n\r\nfunction dropShares(){\r\n\tfor(let item of rohaHistory){\r\n\t\tif(item && item.role===\"user\" && item.user===\"forge\"){\r\n\t\t\titem.user=\"drop\";\r\n\t\t\titem.content=\"dropped path \"+(item.path||\"\");\t\t\t\r\n\t\t}\r\n\t}\r\n\trohaShares=[];\r\n\techo(\"all shares dropped\");\r\n}\r\n\r\nfunction listShare(){\r\n\tconst list=[];\r\n\tlet count=0;\r\n\tlet sorted = roha.sharedFiles.slice();\r\n\tsorted.sort((a, b) => b.size - a.size);\r\n\tfor (const share of sorted) {\r\n\t\tlet shared=(rohaShares.includes(share.path))?\"*\":\"\";\r\n\t\tlet tags=\"[\"+share.tag+\"]\";\r\n\t\tlet info=(share.description)?share.description:\"\";\r\n\t\techo((count++),share.path,share.size,shared,tags,info);\r\n\t\tlist.push(share.id);\r\n\t}\r\n\tshareList=list;\r\n}\r\n\r\nfunction listSaves(){\r\n\tlet saves=roha.saves||[];\r\n\tfor(let i=0;i<saves.length;i++){\r\n\t\techo(i,saves[i]);\r\n\t}\r\n}\r\n\r\nasync function saveHistory(name) {\r\n\ttry {\r\n\t\tlet timestamp=Math.floor(Date.now()/1000).toString(16);\r\n\t\tlet filename=(name||\"transmission-\"+timestamp)+\".json\";\r\n\t\tlet filePath = resolve(forgePath,filename);\r\n\t\tlet line=\"Saved session \"+filename+\".\";\r\n\t\trohaHistory.push({role:\"system\",content:line});\r\n\t\tawait Deno.writeTextFile(filePath,JSON.stringify(rohaHistory,null,\"\\t\"));\r\n\t\techo(line);\r\n\t\troha.saves.push(filename);\r\n\t\tawait writeRoha();\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error saving history:\", error.message);\r\n\t}\r\n}\r\n\r\nasync function loadHistory(filename){\r\n\tvar history;\r\n\ttry {\r\n\t\tconst fileContent = await Deno.readTextFile(filename);\r\n\t\thistory = JSON.parse(fileContent);\r\n\t\techo(\"History restored from \"+filename);\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error restoring history:\", error.message);\r\n\t\techo(\"console error\");\r\n\t\thistory=[{role:\"system\",content: \"You are a helpful assistant.\"}];\r\n\t}\r\n\treturn history;\r\n}\r\n\r\nconst ansiBackgrounds = [\r\n\t{ name: \"dark0\", code: \"\\x1b[48;5;232m\" }, // #1c2526\r\n\t{ name: \"dark1\", code: \"\\x1b[48;5;233m\" }, // #2e3436\r\n\t{ name: \"dark2\", code: \"\\x1b[48;5;234m\" }, // #3d4446\r\n\t{ name: \"dark3\", code: \"\\x1b[48;5;235m\" }, // #4e5456\r\n\t{ name: \"charcoal\", code: \"\\x1b[48;5;236m\" }, // #606668\r\n\t{ name: \"darkBlue\", code: \"\\x1b[48;5;17m\" }, // #00005f\r\n\t{ name: \"darkGreen\", code: \"\\x1b[48;5;23m\" }, // #003f3f\r\n\t{ name: \"darkMutedPurple\", code: \"\\x1b[48;5;54m\" }, // #5f00af\r\n\t{ name: \"veryDarkBlue\", code: \"\\x1b[48;5;18m\" }, // #000087\r\n\t{ name: \"darkCharcoal\", code: \"\\x1b[48;5;239m\" }, // #4e4e4e\r\n\t{ name: \"mutedNavy\", code: \"\\x1b[48;5;19m\" }, // #0000af\r\n\t{ name: \"deepGray\", code: \"\\x1b[48;5;240m\" } // #585858\r\n];\r\n\r\nconst ansiMoveToEnd = \"\\x1b[999B\";\r\nconst ansiSaveCursor = \"\\x1b[s\";\r\nconst ansiRestoreCursor = \"\\x1b[u\";\r\n\r\nconst ansiReplyBlock = ansiBackgrounds[0].code;\r\nconst ansiCodeBlock = ansiBackgrounds[6].code;\r\n\r\nconst rohaPrompt=\">\";\r\n\r\nconst ansiItalics = \"\\x1b[3m\";\r\nconst ansiReset = \"\\x1b[0m\";\r\nconst ansiPurple = \"\\x1b[1;35m\";\r\n\r\nfunction mdToAnsi(md) {\r\n\tlet broken=roha.config.broken;\r\n\tconst lines = md.split(\"\\n\");\r\n\tlet inCode = false;\r\n\tconst result = broken?[ansiReplyBlock]:[];\r\n\tfor (let line of lines) {\r\n\t\tline=line.trimEnd();\r\n\t\tlet trim=line.trim();\r\n\t\tif (trim.startsWith(\"```\")) {\r\n\t\t\tinCode = !inCode;\r\n\t\t\tif(inCode){\r\n\t\t\t\tresult.push(ansiCodeBlock);\r\n\t\t\t\tlet codeType=trim.substring(3);\r\n\t\t\t\techo(\"inCode \"+codeType);\r\n\t\t\t}else{\r\n\t\t\t\tif (broken) result.push(ansiReplyBlock);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif (!inCode) {\r\n\t\t\t\t// headershow\r\n\t\t\t\tconst header = line.match(/^#+/);\r\n\t\t\t\tif (header) {\r\n\t\t\t\t\tconst level = header[0].length;\r\n\t\t\t\t\tline = line.substring(level).trim();\r\n\t\t\t\t\tline = ansiPurple + line + ansiReset;\r\n\t\t\t\t}\r\n\t\t\t\t// bullets\r\n\t\t\t\tif (line.startsWith('-') || line.startsWith('*') || line.startsWith('+')) {\r\n\t\t\t\t\tline = '• ' + line.substring(1).trim();\r\n\t\t\t\t}\r\n\t\t\t\t// bold\r\n\t\t\t\tif (line.includes(\"**\")) {\r\n\t\t\t\t\tline = line.replace(/\\*\\*(.*?)\\*\\*/g, \"\\x1b[1m$1\\x1b[0m\");\r\n\t\t\t\t}\r\n\t\t\t\t// italic\r\n\t\t\t\tline = line.replace(/\\*(.*?)\\*/g, \"\\x1b[3m$1\\x1b[0m\");\r\n\t\t\t\tline = line.replace(/_(.*?)_/g, \"\\x1b[3m$1\\x1b[0m\");\r\n\t\t\t\t// wordwrap\r\n\t\t\t\tline=wordWrap(line,terminalColumns);\r\n\t\t\t}\r\n\t\t\tresult.push(line.trimEnd());\r\n\t\t}\r\n\t}\r\n\tresult.push(ansiReset);\r\n\treturn result.join(\"\\n\");\r\n}\r\n\r\nasync function hashFile(filePath) {\r\n\tconst fileContent = await Deno.readFile(filePath);\r\n\tconst hashBuffer = await crypto.subtle.digest(\"SHA-256\", fileContent);\r\n\tconst hashArray = new Uint8Array(hashBuffer);\r\n\treturn Array.from(hashArray).map(byte => byte.toString(16).padStart(2, '0')).join('');\r\n}\r\n\r\nasync function readRoha(){\r\n\ttry {\r\n\t\tconst fileContent = await Deno.readTextFile(rohaPath);\r\n\t\troha = JSON.parse(fileContent);\r\n\t\tif(!roha.saves) roha.saves=[];\r\n\t\tif(!roha.counters) roha.counters={};\r\n\t\tif(!roha.band) roha.band={};\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error reading or parsing\",rohaPath,error);\r\n\t\troha=emptyRoha;\r\n\t}\r\n}\r\n\r\nasync function writeRoha(){\r\n\ttry {\r\n\t\troha.model=grokModel;\r\n\t\tawait Deno.writeTextFile(rohaPath, JSON.stringify(roha, null, \"\\t\"));\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error writing\",rohaPath,error);\r\n\t}\r\n}\r\n\r\nasync function resetRoha(){\r\n\trohaShares = [];\r\n\troha.sharedFiles=[];\r\n\troha.tags={};\r\n\tif(roha.config.resetcounters) roha.counters={};\r\n\tincrement(\"resets\");\r\n\tawait writeRoha();\r\n\tresetHistory();\r\n\techo(\"resetRoha\",\"All shares and history reset.\");\r\n}\r\n\r\nfunction resolvePath(dir,filename){\r\n\tlet path=resolve(dir,filename);\r\n\tpath = path.replace(/\\\\/g, \"/\");\r\n\treturn path;\r\n}\r\n\r\n// a raw mode prompt replacement\r\n\r\n// arrow navigation and tab completion incoming\r\n\r\nconst reader = Deno.stdin.readable.getReader();\r\nconst writer = Deno.stdout.writable.getWriter();\r\n\r\nasync function prompt2(message) {\r\n\tif (message) {\r\n\t\tawait writer.write(encoder.encode(message));\r\n\t\tawait writer.ready;\r\n\t}\r\n\tDeno.stdin.setRaw(true);\r\n\tlet inputBuffer = new Uint8Array(0);\r\n\ttry {\r\n\t\twhile (true) {\r\n\t\t\tconst { value, done } = await reader.read();\r\n\t\t\tif (done || !value) break;\r\n\t\t\tfor (const byte of value) {\r\n\t\t\t\tif (byte === 0x7F || byte === 0x08) { // Backspace\r\n\t\t\t\t\tif (inputBuffer.length > 0) {\r\n\t\t\t\t\t\tinputBuffer = inputBuffer.slice(0, -1);\r\n\t\t\t\t\t\tawait writer.write(new Uint8Array([0x08, 0x20, 0x08])); // Erase last char\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (byte === 0x1b) { // Escape sequence\r\n\t\t\t\t\tif(value.length==1){\r\n\t\t\t\t\t\tDeno.exit(0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(value.length==3){\r\n\t\t\t\t\t\tif(value[1]==0xf4 && value[2]==0x50){\r\n\t\t\t\t\t\t\techo(\"F1\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (byte === 0x0A || byte === 0x0D) { // Enter key\r\n\t\t\t\t\tawait writer.write(encoder.encode(\"\\r\\n\"));\r\n\t\t\t\t\tlet line = decoder.decode(inputBuffer);\r\n\t\t\t\t\tline=line.trim();\r\n\t\t\t\t\tlog(line,\"stdin\");\r\n\t\t\t\t\treturn line;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tawait writer.write(new Uint8Array([byte]));\r\n\t\t\t\t\tconst buf = new Uint8Array(inputBuffer.length + 1);\r\n\t\t\t\t\tbuf.set(inputBuffer);\r\n\t\t\t\t\tbuf[inputBuffer.length] = byte;\r\n\t\t\t\t\tinputBuffer = buf;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} finally {\r\n\t\tDeno.stdin.setRaw(false);\r\n\t}\r\n}\r\n\r\n// callers to addShare expected to await writeRoha after\r\n\r\nconst eventList=[];\r\n\r\nasync function watchPaths(paths,handler){\r\n\tconst watcher = Deno.watchFs(paths,{recursive:false});\r\n\tfor await (const event of watcher) {\r\n\t\teventList.push(event);\r\n\t}\r\n}\r\n\r\nasync function addShare(share){\r\n\tshare.id=\"share\"+increment(\"shares\");\r\n\troha.sharedFiles.push(share);\r\n\tif(share.tag) {\r\n\t\tawait setTag(share.tag,share.id);\r\n\t}\r\n}\r\n\r\nasync function shareDir(dir,tag) {\r\n\ttry {\r\n\t\tconst paths=[];\r\n\t\tconst files = await Deno.readDir(dir);\r\n\t\tfor await (const file of files) {\r\n\t\t\tif (file.isFile && !file.name.startsWith(\".\")) {\r\n\t\t\t\tpaths.push(resolvePath(dir, file.name));\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (const path of paths) {\r\n//\t\t\techo(\"statting path:\"+path+\":\");\r\n\t\t\tconst info = await Deno.stat(path);\r\n\t\t\tlet size=info.size;\r\n\t\t\tlet modified=info.mtime.getTime();\r\n\t\t\tconst hash = await hashFile(path);\r\n\t\t\tawait addShare({path,size,modified,hash,tag})\r\n\t\t}\r\n\t\tawait writeRoha(); // TODO: check a dirty flag\r\n\t} catch (error) {\r\n\t\tconsole.error(\"### Error\"+error);\r\n\t}\r\n}\r\n\r\nfunction fileType(extension){\r\n\treturn contentType(extension) || 'application/octet-stream';\r\n}\r\n\r\nconst textExtensions = [\r\n\t\"js\", \"txt\", \"json\", \"md\",\r\n\t\"css\",\"html\", \"svg\",\r\n\t\"cpp\", \"c\", \"h\", \"cs\",\r\n\t\"sh\", \"bat\",\r\n\t\"log\",\"py\",\"csv\",\"xml\",\"ini\"\r\n];\r\n\r\nasync function shareFile(path,tag) {\r\n\tlet fileContent=null;\r\n\ttry {\r\n\t\tfileContent = await Deno.readFile(path);\r\n\t} catch (error) {\r\n\t\tconsole.error(\"shareFile path:\"+path+\" error:\", error);\r\n\t\treturn;\r\n\t}\r\n\tif(path.endsWith(\"rules.txt\")){\r\n\t\tlet lines=decoder.decode(fileContent).split(\"\\n\");\r\n\t\tfor(let line of lines ){\r\n\t\t\tif (line) rohaHistory.push({role:\"system\",content: line});\r\n\t\t}\r\n\t}else{\r\n\t\tconst length=fileContent.length;\r\n\t\tif(length>0 && length<MaxFileSize){\r\n\t\t\tconst extension = path.split('.').pop();\r\n\t\t\tconst type = fileType(extension);\r\n\t\t\tif (textExtensions.includes(extension)) {\r\n\t\t\t\tlet txt = decoder.decode(fileContent);\r\n\t\t\t\tif(txt.length){\r\n\t\t\t\t\tlet metadata=JSON.stringify({path,length,type,tag});\r\n\t\t\t\t\trohaPush(metadata);\r\n\t\t\t\t\trohaPush(txt,\"forge\");\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tconst base64Encoded = btoa(String.fromCharCode(...new Uint8Array(fileContent)));\r\n\t\t\t\tconst mimeType = fileType(extension);\r\n\t\t\t\tlet metadata=JSON.stringify({path,length,type,mimeType,tag});\r\n\t\t\t\trohaPush(metadata);\r\n\t\t\t\tlet binary=`File content: MIME=${mimeType}, Base64=${base64Encoded}`;\r\n\t\t\t\trohaPush(binary,\"forge\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n//\tif(roha.config.verbose)echo(\"roha shared file \" + path);\r\n\tif (!rohaShares.includes(path)) rohaShares.push(path);\r\n}\r\n\r\nasync function commitShares(tag) {\r\n\tlet dirty = false;\r\n\tconst validShares = [];\r\n\tconst removedPaths = [];\r\n\tfor (const share of roha.sharedFiles) {\r\n\t\tif (tag && share.tag !== tag) {\r\n\t\t\tvalidShares.push(share);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tconst info = await Deno.stat(share.path);\r\n\t\t\tconst modified = share.modified !== info.mtime.getTime();\r\n\t\t\tconst isShared = rohaShares.includes(share.path);\r\n\t\t\tif (modified || !isShared) {\r\n\t\t\t\tawait shareFile(share.path,tag);\r\n\t\t\t\tshare.modified = info.mtime.getTime();\r\n\t\t\t\tdirty = true;\r\n\t\t\t}\r\n\t\t\tvalidShares.push(share);\r\n\t\t} catch (error) {\r\n\t\t\tremovedPaths.push(share.path);\r\n\t\t\tdirty = true;\r\n\t\t}\r\n\t}\r\n\r\n\tif (removedPaths.length) {\r\n\t\troha.sharedFiles = validShares;\r\n\t\tawait writeRoha();\r\n\t\techo(`Invalid shares detected:\\n${removedPaths.join('\\n')}`);\r\n\t}\r\n\r\n\tif (dirty&&tag) {\r\n\t\tlet invoke=\"feel free to call annotate_foundry to tag \"+tag;\r\n\t\trohaHistory.push({role:\"system\",content:invoke});\r\n\t}\r\n\r\n\treturn dirty;\r\n}\r\n\r\nasync function setTag(name,note){\r\n\tlet tags=roha.tags||{};\r\n\tlet tag=(tags[name])?tags[name]:{name,info:[]};\r\n\ttag.info.push(note);\r\n\ttags[name]=tag;\r\n\troha.tags=tags;\r\n\tawait writeRoha();\r\n//\tlet invoke=`New tag \"${name}\" added. Describe all shares with this tag.`;\r\n//\trohaHistory.push({role:\"system\",content:invoke});\r\n}\r\nfunction listCounters(){\r\n\tlet keys=Object.keys(roha.counters);\r\n\tlet i=0;\r\n\tfor(let key of keys){\r\n\t\tlet count=roha.counters[key];\r\n\t\techo((i++),key,count);\r\n\t}\r\n}\r\nfunction listTags(){\r\n\tlet tags=roha.tags||{};\r\n\tlet keys=Object.keys(tags);\r\n\tlet list=[];\r\n\tfor(let i=0;i<keys.length;i++){\r\n\t\tlet tag=tags[keys[i]];\r\n\t\tconst name=tag.name||\"?????\";\r\n\t\techo(i,name,\"(\"+tag.info.length+\")\");\r\n\t\tlet info=tag.description;\r\n\t\tif(info) echo(\"\",info);\r\n\t\tlist.push(name);\r\n\t}\r\n\ttagList=list;\r\n}\r\n\r\nfunction listAccounts(){\r\n\tlet list=[];\r\n\tfor(let key in modelAccounts){\r\n\t\tlet value=modelAccounts[key];\r\n\t\tlist.push(key);\r\n\t}\r\n\tfor(let i=0;i<list.length;i++){\r\n\t\techo(i,list[i]);\r\n\t}\r\n}\r\n\r\nasync function showHelp() {\r\n\ttry {\r\n\t\tconst md = await Deno.readTextFile(\"foundry.md\");\r\n\t\techo(mdToAnsi(md));\r\n\t} catch (e) {\r\n\t\techo(\"Error loading help file: \" + e.message);\r\n\t}\r\n}\r\n\r\nfunction readable(text){\r\n\ttext=text.replace(/\\s+/g, \" \");\r\n\treturn text;\r\n}\r\n\r\nasync function callCommand(command) {\r\n\tlet dirty=false;\r\n\tlet words = command.split(\" \",2);\r\n\ttry {\r\n\t\tswitch (words[0]) {\r\n\t\t\tcase \"band\":\r\n\t\t\t\tlistBand();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"counter\":\r\n\t\t\t\tlistCounters();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"tag\":\r\n\t\t\t\tawait listTags();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"account\":\r\n\t\t\t\tawait listAccounts();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"help\":\r\n\t\t\t\tawait showHelp();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"config\":\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\tlet flag=words[1].trim();\r\n\t\t\t\t\tif(flag.length && !isNaN(flag)){\r\n\t\t\t\t\t\tflag=Object.keys(flagNames)[flag|0];\r\n\t\t\t\t\t\techo(\"flag\",flag);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(flag in flagNames){\r\n\t\t\t\t\t\troha.config[flag]=!roha.config[flag];\r\n\t\t\t\t\t\techo(flag+\" - \"+flagNames[flag]+\" is \"+(roha.config[flag]?\"true\":\"false\"));\r\n\t\t\t\t\t\tawait writeRoha();\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlet count=0;\r\n\t\t\t\t\tfor(let flag in flagNames){\r\n\t\t\t\t\t\techo((count++),flag,\":\",flagNames[flag],\":\",(roha.config[flag]?\"true\":\"false\"))\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistCommand=\"config\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"time\":\r\n\t\t\t\techo(\"Current time:\", new Date().toString());\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"history\":\r\n\t\t\t\tlistHistory();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"load\":\r\n\t\t\t\tlet save=words[1];\r\n\t\t\t\tif(save){\r\n\t\t\t\t\tif(save.length && !isNaN(save)) save=roha.saves[save|0];\r\n\t\t\t\t\tif(roha.saves.includes(save)){\r\n\t\t\t\t\t\tlet history=await loadHistory(save);\r\n\t\t\t\t\t\trohaHistory=history;\r\n\t\t\t\t\t\techo(\"a new history is set\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlistSaves();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"save\":\r\n\t\t\t\tlet savename=words.slice(1).join(\" \");\r\n\t\t\t\tsaveHistory(savename);\r\n\t\t\t\tawait writeRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"model\":\r\n\t\t\t\tlet name=words[1];\r\n\t\t\t\tif(name){\r\n\t\t\t\t\tif(name.length&&!isNaN(name)) name=modelList[name|0];\r\n\t\t\t\t\tif(modelList.includes(name)){\r\n\t\t\t\t\t\tresetModel(name);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor(let i=0;i<modelList.length;i++){\r\n\t\t\t\t\t\tlet name=modelList[i];\r\n\t\t\t\t\t\tlet attr=(name==grokModel)?\"*\":\"\";\r\n\t\t\t\t\t\techo(i,name,attr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlistCommand=\"model\";\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"reset\":\r\n\t\t\t\tawait resetRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"cd\":\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\tconst newDir = words[1];\r\n\t\t\t\t\tif (newDir.length) Deno.chdir(newDir);\r\n\t\t\t\t}\r\n\t\t\t\tcurrentDir = Deno.cwd();\r\n\t\t\t\techo(\"Changed directory to\", currentDir);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"dir\":\r\n\t\t\t\tconst files = Deno.readDirSync(currentDir);\r\n\t\t\t\techo(\"Contents of\", currentDir + \":\");\r\n\t\t\t\tfor (const file of files) {\r\n\t\t\t\t\tlet name=(file.isDirectory)?\"[\"+file.name+\"]\":file.name;\r\n\t\t\t\t\techo(name);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"drop\":\r\n\t\t\t\tdropShares();\r\n\t\t\t\tawait writeRoha();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"share\":\r\n\t\t\t\tif (words.length==1){\r\n\t\t\t\t\tlistShare();\r\n\t\t\t\t}else{\r\n\t\t\t\t\tconst filename = words.slice(1).join(\" \");\r\n\t\t\t\t\tconst path = resolvePath(Deno.cwd(), filename);\r\n\t\t\t\t\tconst info = await Deno.stat(path);\r\n\t\t\t\t\tconst tag = await prompt2(\"Enter tag name (optional):\");\r\n\t\t\t\t\tif(info.isDirectory){\r\n\t\t\t\t\t\techo(\"Share directory path:\",path);\r\n\t\t\t\t\t\tawait shareDir(path,tag);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlet size=info.size;\r\n\t\t\t\t\t\tlet modified=info.mtime.getTime();\r\n\t\t\t\t\t\techo(\"Share file path:\",path,\" size:\",info.size,\" \");\r\n\t\t\t\t\t\tconst hash = await hashFile(path);\r\n\t\t\t\t\t\techo(\"hash:\",hash);\r\n\t\t\t\t\t\tawait addShare({path,size,modified,hash,tag});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tawait writeRoha();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"push\":\r\n\t\t\tcase \"commit\":\r\n\t\t\t\tlet tag=\"\";\r\n\t\t\t\tif(words.length>1){\r\n\t\t\t\t\ttag=words[1];\r\n\t\t\t\t}\r\n\t\t\t\tdirty=await commitShares(tag);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\techo(\"Command not recognised\");\r\n\t\t\t\treturn false; // Command not recognized\r\n\t\t}\r\n\t} catch (error) {\r\n\t\techo(\"Error processing command:\", error.message);\r\n\t}\r\n\tincrement(\"calls\");\r\n\treturn dirty;\r\n}\r\n\r\necho(rohaTitle,\"running from \"+rohaPath);\r\nawait readRoha();\r\n\r\nlet grokModel = roha.model||\"deepseek-chat@deepseek\";\r\nlet grokFunctions=true;\r\nlet grokUsage = 0;\r\n\r\necho(\"present [\",grokModel,\"]\");\r\necho(\"shares count:\",roha.sharedFiles.length)\r\necho(\"use /help for latest and exit to quit\");\r\necho(\"\");\r\n\r\nlet sessions=increment(\"sessions\");\r\nif(sessions==0){\r\n\tlet welcome=await Deno.readTextFile(\"welcome.txt\");\r\n\techo(welcome);\r\n\tawait writeRoha();\r\n}\r\n\r\nif(roha.config){\r\n\tif(roha.config.commitonstart) await commitShares();\r\n}else{\r\n\troha.config={};\r\n}\r\n\r\nfunction extensionForType(contentType) {\r\n\tif (contentType.includes(\"markdown\")) return \".md\";\r\n\tif (contentType.includes(\"json\")) return \".json\";\r\n\tif (contentType.includes(\"javascript\")) return \".js\";\r\n\treturn \".txt\";\r\n}\r\n\r\nasync function onCall(toolCall) {\r\n\tlet verbose=roha.config.verbose;\r\n\tswitch(toolCall.function.name) {\r\n\t\tcase \"read_time\":\r\n\t\t\treturn {time: new Date().toISOString()};\r\n\t\tcase \"submit_file\":\r\n\t\t\tlet args=JSON.parse(toolCall.function.arguments);\r\n\t\t\techo(args.contentType);\r\n\t\t\tif (verbose) echo(args.content);\r\n\t\t\tlet timestamp=Math.floor(Date.now()/1000).toString(16);\r\n\t\t\tlet extension=extensionForType(args.contentType)\r\n\t\t\tlet name= \"submission-\"+timestamp+extension;\r\n\t\t\tlet filePath = resolve(forgePath,name);\r\n\t\t\tawait Deno.writeTextFile(filePath, args.content);\r\n\t\t\techo(\"File saved to:\", filePath);\r\n\t\t\treturn { success: true, path: filePath };\r\n\t\tcase \"annotate_foundry\":\r\n\t\t\ttry {\r\n\t\t\t\tconst { name, type, description } = JSON.parse(toolCall.function.arguments || \"{}\");\r\n\t\t\t\tswitch(type){\r\n\t\t\t\t\tcase \"tag\":\r\n\t\t\t\t\t\tannotateTag(name,description);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"share\":\r\n\t\t\t\t\t\tannotateShare(name,description);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tawait writeRoha(); // Persist changes\r\n\t\t\t\treturn { success: true, updated: 1 };\r\n\t\t\t} catch (error) {\r\n\t\t\t\techo(\"annotate_foundry error:\",error);\r\n\t\t\t\treturn { success: false, updated: 0 };\r\n\t\t\t}\r\n\t}\r\n\tconsole.error(\"onCall error - call simon\");\r\n}\r\n\r\nfunction squashMessages(history) {\r\n\tif (history.length < 2) return history;\r\n\tconst squashed = [history[0]];\r\n\tlet system=[];\r\n\tlet other=[];\r\n\tfor(let item of history){\r\n\t\tif(item.role==\"system\") system.push(item); else other.push(item);\r\n\t}\r\n\tfor(let list of [system,other]){\r\n\t\tlet last=null;\r\n\t\tfor (let i = 0; i < list.length; i++) {\r\n\t\t\tconst current=list[i];\r\n\t\t\tif(last){\r\n\t\t\t\tlast.content += \"\\n\" + current.content;\r\n\t\t\t} else {\r\n\t\t\t\tsquashed.push(current);\r\n\t\t\t\tlast=current;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn squashed;\r\n}\r\n\r\nasync function isolateCode(path,cwd) {\r\n\ttry {\r\n\t\tconst readAllow = `--allow-read=${cwd}`;\r\n\t\tconst writeAllow = `--allow-write=${cwd}`;\r\n\t\tconst cmd = [\"deno\", \"run\", \"--no-remote\", readAllow, writeAllow, path];\r\n\t\tconst process = Deno.run({ cmd, stdout: \"piped\", stderr: \"piped\" });\r\n\t\tconst [stdout, stderr] = await Promise.all([process.output(), process.stderrOutput()]);\r\n\t\tconst status = await process.status();\r\n\t\tprocess.close();\r\n\t\treturn {\r\n\t\t\tsuccess: status.success,\r\n\t\t\toutput: new TextDecoder().decode(stdout),\r\n\t\t\terror: new TextDecoder().decode(stderr)\r\n\t\t};\r\n\t} catch (err) {\r\n\t\treturn { success: false, output: \"\", error: err.message };\r\n\t}\r\n}\r\n\r\nasync function runCode(){\r\n\tlet result = await isolateCode(\"isolation/test.js\", \"isolation\");\r\n\t//echo(\"RunCode Result:\", result.success ? \"Success\" : \"Failed\");\r\n\tif (result.output) echo(\"[isolation] \", result.output);\r\n\tif (result.error) echo(\"Error:\", result.error);\r\n\t// todo: add save on exit\r\n}\r\n\r\nasync function relay() {\r\n\tconst verbose=roha.config.verbose;\r\n\ttry {\r\n\t\tconst modelAccount=grokModel.split(\"@\");\r\n\t\tlet model=modelAccount[0];\r\n\t\tlet account=modelAccount[1];\r\n\t\tlet endpoint=rohaAccount[account];\r\n\t\tlet usetools=grokFunctions&&roha.config.tools;\r\n\t\tconst payload = usetools?{ model, messages:rohaHistory, tools: rohaTools }:{ model, messages:squashMessages(rohaHistory) };\r\n\t\tconst completion = await endpoint.chat.completions.create(payload);\r\n\t\tif (completion.model != model) {\r\n\t\t\techo(\"[relay model alert model:\" + completion.model + \" grokModel:\" + grokModel + \"]\");\r\n\t\t\tgrokModel=completion.model+\"@\"+account;\r\n\t\t}\r\n\t\tif (verbose) {\r\n\t\t\t// echo(\"relay completion:\" + JSON.stringify(completion, null, \"\\t\"));\r\n\t\t}\r\n\t\tlet system = completion.system_fingerprint;\r\n\t\tlet usage = completion.usage;\r\n\t\tlet size = measure(rohaHistory);\r\n\t\tgrokUsage += usage.prompt_tokens | 0 + usage.completion_tokens | 0;\r\n\t\tlet status = \"[model \" + grokModel + \" \" + usage.prompt_tokens + \" \" + usage.completion_tokens + \" \" + grokUsage + \" \" + size + \"]\";\r\n\t\techo(status);\r\n\t\tvar reply = \"<blank>\";\r\n\t\tfor (const choice of completion.choices) {\r\n\t\t\tlet calls = choice.message.tool_calls;\r\n\t\t\t// choice has index message{role,content,refusal,annotations} finish_reason\r\n\t\t\tif (calls) {\r\n\t\t\t\tincrement(\"calls\");\r\n\t\t\t\techo(\"relay calls in progress\");\r\n\t\t\t\t// Generate tool_calls with simple, unique IDs\r\n\t\t\t\tconst toolCalls = calls.map((tool, index) => ({\r\n\t\t\t\t\tid: `call_${rohaCalls++}`,\r\n\t\t\t\t\ttype: \"function\",\r\n\t\t\t\t\tfunction: {\r\n\t\t\t\t\t\tname: tool.function.name,\r\n\t\t\t\t\t\targuments: tool.function.arguments || \"{}\"\r\n\t\t\t\t\t}\r\n\t\t\t\t}));\r\n\t\t\t\t// Add assistant message with tool_calls\r\n\t\t\t\tlet content=choice.message.content || \"\";\r\n\t\t\t\trohaHistory.push({role:\"assistant\",content,tool_calls: toolCalls});\r\n\t\t\t\tif(verbose) echo(\"tooling \"+content);\r\n\t\t\t\t// Add tool responses\r\n\t\t\t\tfor (let i = 0; i < calls.length; i++) {\r\n\t\t\t\t\tconst tool = calls[i];\r\n\t\t\t\t\tconst result = await onCall(tool);\r\n\t\t\t\t\tif (result){\r\n\t\t\t\t\t\tlet content=JSON.stringify(result);\r\n\t\t\t\t\t\trohaHistory.push({\r\n\t\t\t\t\t\t\trole: \"tool\",\r\n\t\t\t\t\t\t\ttool_call_id: toolCalls[i].id,\r\n\t\t\t\t\t\t\tname: tool.function.name,\r\n\t\t\t\t\t\t\tcontent\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\techo(\"no oncall result\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn relay(); // Recursive call to process tool results\r\n\t\t\t}\r\n\t\t\treply = choice.message.content;\r\n\t\t\tif (roha.config && roha.config.ansi) {\r\n//\t\t\t\techo(ansiSaveCursor);\r\n\t\t\t\tprint(mdToAnsi(reply));\r\n//\t\t\t\techo(ansiRestoreCursor);\r\n\t\t\t} else {\r\n\t\t\t\tprint(wordWrap(reply));\r\n\t\t\t}\r\n\t\t}\r\n\t\trohaHistory.push({ role: \"assistant\", content: reply });\r\n\t} catch (error) {\r\n\t\tlet line=error.message || String(error);\r\n\t\t//Error during API call: Error: 400 \"This model's maximum prompt length is 131072 but the request contains 165547 tokens.\"\r\n\t\tif(line.includes(\"maximum prompt length\")){\r\n\t\t\techo(\"maximum prompt length exceeded, switch model or drop shares to continue\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconsole.error(\"Error during API call:\", error);\t\r\n\t\tif(grokFunctions){\r\n\t\t\techo(\"resetting grokFunctions\")\r\n\t\t\tgrokFunctions=false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nasync function chat() {\r\n\tdance:\r\n\twhile (true) {\r\n\t\tlet lines=[];\r\n//\t\techo(ansiMoveToEnd);\r\n\t\twhile (true) {\r\n\t\t\tawait flush();\r\n\t\t\tlet line=\"\";\r\n\t\t\tif(listCommand){\r\n\t\t\t\tline=await prompt2(\"#\");\r\n\t\t\t\tif(line.length && !isNaN(line)){\r\n\t\t\t\t\tlet index=line|0;\r\n\t\t\t\t\tawait callCommand(listCommand+\" \"+index);\r\n\t\t\t\t}\r\n\t\t\t\tlistCommand=\"\";\r\n\t\t\t}else{\r\n\t\t\t\tline=await prompt2(rohaPrompt);\r\n\t\t\t}\r\n\t\t\tif (line === '') {\r\n\t\t\t\tif(roha.config.returntopush && !lines.length) {\r\n\t\t\t\t\techo(\"auto pushing...\");\r\n\t\t\t\t\tawait callCommand(\"push\");\r\n\t\t\t\t\tawait relay();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (line === \"exit\") {\r\n\t\t\t\techo(\"Ending the conversation...\");\r\n\t\t\t\tbreak dance;\r\n\t\t\t}\r\n\t\t\tif (line.startsWith(\"/\")) {\r\n\t\t\t\tconst command = line.substring(1).trim();\r\n\t\t\t\tlet dirty=await callCommand(command);\r\n\t\t\t\tif(dirty){\r\n\t\t\t\t\tlines.push(\"Please review source for bugs and all content if notable changes detected, thanks.\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlines.push(line.trim());\r\n\t\t}\r\n\r\n\t\tif (lines.length){\r\n\t\t\tconst query=lines.join(\"\\n\");\r\n\t\t\tif(query.length){\r\n\t\t\t\trohaHistory.push({ role: \"user\", content: query });\r\n\t\t\t\tawait relay();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nDeno.addSignalListener(\"SIGINT\", () => {Deno.exit(0);});\r\n\r\n//only windows Deno.addSignalListener(\"SIGBREAK\", () => {echo(\"SIGBREAK\");});\r\n\r\nawait runCode(\"isolation/test.js\",\"isolation\");\r\n\r\nchat();\r\n"
	},
	{
		"role": "user",
		"name": "foundry",
		"content": "{\"path\":\"C:/nitrologic/foundry/release/accounts.json\",\"length\":362,\"type\":\"application/json; charset=UTF-8\"}"
	},
	{
		"role": "user",
		"name": "forge",
		"content": "{\r\n\t\"gemini\":{\r\n\t\t\"env\":\"GEMINI_API_KEY\",\r\n\t\t\"url\":\"https://generativelanguage.googleapis.com/v1beta/openai\"\r\n\t},\r\n\t\"deepseek\":{\r\n\t\t\"env\":\"DEEPSEEK_API_KEY\",\r\n\t\t\"url\":\"https://api.deepseek.com\"\r\n\t},\r\n\t\"xai\": {\r\n\t\t\"env\": \"XAI_API_KEY\",\r\n\t\t\"url\": \"https://api.x.ai/v1\"\r\n\t},\r\n\t\"openai\": {\r\n\t\t\"env\": \"OPENAI_API_KEY\",\r\n\t\t\"url\": \"https://api.openai.com/v1\"\r\n\t}\r\n  }\r\n"
	},
	{
		"role": "user",
		"name": "foundry",
		"content": "{\"path\":\"C:/nitrologic/foundry/release/foundry.md\",\"length\":2601,\"type\":\"text/markdown; charset=UTF-8\"}"
	},
	{
		"role": "user",
		"name": "forge",
		"content": "# foundry command line client\r\n\r\nA command line application designed to chat and share files.\r\n\r\n## foundry machine interface\r\n\r\nThe foundry functional interface uses tools and tool_calls.\r\n\r\nOnly recent models provide tools interface, foundry should fall \r\nback to a no tools completion mode.\r\n\r\nSee the OpenAI API spec for more tool role details.\r\n\r\n### read_time\r\n\r\n### submit_file\r\n\r\n### annotate_foundry\r\n\r\n## foundry user interface\r\n\r\ncommands with no arguments may often prompt for a # index from\r\nthe items displayed\r\n\r\n### /config\r\n\r\nToggle configuration flags.\r\n\r\nAdjust settings to suit current preferences.\r\n\r\nDefault values are typically:\r\n\r\n* 0 commitonstart : commit shared files on start : true\r\n* 1 ansi : markdown ANSI rendering : true\r\n* 2 slow : output at reading speed : true\r\n* 3 verbose : emit debug information : true\r\n* 4 broken : ansi background blocks : false\r\n* 5 logging : log all output to file : true\r\n* 6 resetcounters : at reset zero all counters : true\r\n\r\n### /share\r\n\r\nShare a file or folder with optional tag.\r\n\r\nFiles are added to the share list used by the /push /commit command.\r\n\r\n### /drop\r\n\r\nDrop all files currently shared\r\n\r\n### /push /commit\r\n\r\nRefresh shared files. \r\n\r\nDetects changes or deletions and updates the chat history.\r\n\r\nPosts new versions of file content if modified.\r\n\r\n### /reset\r\n\r\nClear all shared files and conversation history.\r\n\r\n### /history\r\n\r\nList a summary of recent conversation entries. \r\n\r\nProvides a quick overview of chat history.\r\n\r\n### /cd\r\n\r\nChange the working directory. \r\n\r\nUser can navigate to a desired directory for file operations.\r\n\r\n### /dir\r\n\r\nList the contents of the current working directory. \r\n\r\nHelps user view available files and folders to share.\r\n\r\n\r\n### /model\r\n\r\nSelect an AI model.\r\n\r\nUser can choose a model by name or index from the accounts available.\r\n\r\n### /counters\r\n\r\nList the internal application counters.\r\n\r\n### /tag\r\n\r\nDescribe all tags in use.\r\n\r\nDisplays tag name, count of shares tagged and description.\r\n\r\n### /account\r\n\r\nDisplay current account information.\r\n\r\n### /save [name]\r\n\r\nSave the current conversation history. \r\n\r\nCreates a snapshot file of the conversation.\r\n\r\nThe default name is currently .roa-save-HEX32_TIME.json\r\n\r\n### /load\r\n\r\nLoad a saved conversation history snapshot.\r\n\r\nUser can specify a save index or file name to restore previous chats.\r\n\r\n\r\n### /time\r\n\r\nDisplay the current system time. \r\n\r\nHelps user verify system status.\r\n\r\n### /help\r\n\r\nIf you are reading this file, it may be due to the use of this command.\r\n\r\nIf you still need help visit the project page.\r\n"
	},
	{
		"role": "user",
		"name": "foundry",
		"content": "{\"path\":\"C:/nitrologic/foundry/release/LICENSE.txt\",\"length\":1753,\"type\":\"text/plain; charset=UTF-8\"}"
	},
	{
		"role": "user",
		"name": "forge",
		"content": "MIT License\r\n\r\nCopyright (c) 2025 Simon Armstrong\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is                                            \r\nfurnished to do so, subject to the following conditions:                                                         \r\n                                                                                                                 \r\nThe above copyright notice and this permission notice shall be included in all                                   \r\ncopies or substantial portions of the Software.                                                                  \r\n                                                                                                                 \r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                       \r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                         \r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                                      \r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                           \r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                                    \r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE                                    \r\nSOFTWARE. "
	},
	{
		"role": "user",
		"name": "foundry",
		"content": "{\"path\":\"C:/nitrologic/foundry/release/welcome.txt\",\"length\":481,\"type\":\"text/plain; charset=UTF-8\"}"
	},
	{
		"role": "user",
		"name": "forge",
		"content": "preceed with caution\r\n\r\n  o---/\\     /---o     \\---/     /---/\\     o---/\\     \\---o     /---/\\ \r\n  |    \\/   /    |     |    /   /    \\/    |    \\/   /    |     |    \\/ \r\n#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #\r\n\r\n\tWELCOME TO FOUNDRY\r\n\r\n\tA COMMAND LINE TOOL FOR CHATTING AND SHARING FILES\r\n\r\n\tTHE MAGIC WORD IS HAPUKA\r\n\r\n\tTHIS FILE IS PART OF THE ROHA CLIENT DISTRIBUTION\r\n\r\n#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #+#+# #\r\n"
	},
	{
		"role": "user",
		"name": "foundry",
		"content": "{\"path\":\"C:/nitrologic/foundry/release/forge/readme.txt\",\"length\":67,\"type\":\"text/plain; charset=UTF-8\"}"
	},
	{
		"role": "user",
		"name": "forge",
		"content": "local storage for shared files submitted for review by foundry rc1\n"
	},
	{
		"role": "user",
		"name": "foundry",
		"content": "{\"path\":\"C:/nitrologic/foundry/release/isolation/readme.txt\",\"length\":103,\"type\":\"text/plain; charset=UTF-8\"}"
	},
	{
		"role": "user",
		"name": "forge",
		"content": "a sandbox for foundry rc1 runs\r\n\r\nrun foundry run\r\n\r\nthis stuff is post rc1 - what is going on here?\r\n "
	},
	{
		"role": "user",
		"name": "foundry",
		"content": "{\"path\":\"C:/nitrologic/foundry/release/isolation/test.js\",\"length\":180,\"type\":\"application/javascript; charset=UTF-8\"}"
	},
	{
		"role": "user",
		"name": "forge",
		"content": "\r\nfunction hexDate(){\r\n    let s=Date.now()/1e3|0;\r\n    return s.toString(16);\r\n}\r\n\r\nconsole.log(\"radio   live transmission\");\r\n\r\nconsole.log(hexDate());\r\nconsole.log(hexDate());\r\n"
	},
	{
		"role": "user",
		"name": "foundry",
		"content": "{\"path\":\"C:/nitrologic/foundry/.gitignore\",\"length\":55,\"type\":\"application/octet-stream\",\"mimeType\":\"application/octet-stream\"}"
	},
	{
		"role": "user",
		"name": "forge",
		"content": "File content: MIME=application/octet-stream, Base64=Zm91bmRyeS5sb2cKZm91bmRyeS5qc29uCnNhdmVzCnJlbGVhc2UKcmMxL2ZvdW5kcnkuZXhlCg=="
	},
	{
		"role": "user",
		"name": "foundry",
		"content": "{\"path\":\"C:/nitrologic/foundry/build.bat\",\"length\":88,\"type\":\"application/x-msdownload\"}"
	},
	{
		"role": "user",
		"name": "forge",
		"content": "deno compile --allow-run --allow-env --allow-net --allow-read --allow-write foundry.js\r\n"
	},
	{
		"role": "user",
		"content": "i would like to prepare a report on the nitrologic foundry client"
	},
	{
		"role": "assistant",
		"content": "Below is a draft report on the Nitrologic Foundry Client:\n\n─────────────────────────────────────────────  \nNitrologic Foundry Client Report  \n─────────────────────────────────────────────\n\n1. Overview\n\nThe Nitrologic Foundry Client is a command‑line research client designed to interact with language models and manage file sharing. Written in JavaScript/TypeScript for execution with Deno, the client leverages several permissions (run, env, net, read, write) and is intended for experimentation with model evaluations, conversation histories, and file submission workflows.\n\n2. Key Features\n\n• Chat Interface and History Management  \n – The client provides an interactive prompt (using raw mode via Deno’s stdin reader) that accepts chat messages and commands.  \n – It maintains a conversation history (“rohaHistory”) for both user queries and model responses, allowing for conversation snapshots and history restoration via save and load functionality.  \n – A “relay” function communicates with model endpoints (using the OpenAI client libraries and several API providers such as GEMINI, DEEPSEEK, XAI, and OpenAI) and appears to support models that have tool call capabilities.\n\n• File Sharing and Submission  \n – The “/share” command enables users to designate files or directories for sharing. Individual files are processed (for text, JSON, markdown, etc.) or converted to Base64 for binary content.  \n – A sharing mechanism tracks file metadata (path, size, modification time, hash) and tags shared files.  \n – The client supports a “/push” or “/commit” command that scans shared files, detects modifications or deletions, and—if changes are detected—updates the chat history and files submitted for review.\n\n• Configuration and Customization  \n – Several configuration flags allow toggling features such as committing shares on start, ANSI rendering of markdown, slow output, verbose debugging information, and logging (to a file “foundry.log”).  \n – The “/config” command lists available flags, which include:  \n  • commitonstart  (commit shared files on start)  \n  • tools        (enable model tool interface)  \n  • ansi         (render using ANSI/markdown)  \n  • slow         (output at reading speed)  \n  • verbose       (emit debug information)  \n  • broken        (ansi background blocks via alternate colors)  \n  • logging       (log all output to file)  \n  • resetcounters  (reset counters on reset)  \n  • returntopush  (prompt to “push” when returning)\n\n• Model Management and Tooling Interface  \n – The client supports selecting models via the “/model” command. The list of available models is gathered from multiple API endpoints (configured in the “accounts.json” file) and stored in a list (“modelList”).  \n – It uses tool call functions if the selected model supports the tools interface. Three tool functions are defined:  \n  ○ read_time – returns current UTC time.  \n  ○ submit_file – submits a file for review by sending content type and file content, saving the file to a “forge” directory.  \n  ○ annotate_foundry – permits setting descriptions on objects like tags or shared files.  \n – The “relay” function is responsible for interfacing with the model. It prepares the payload (using either the simple chat history or a tool call JSON structure) and recursively handles tool call responses by executing the corresponding functions (via “onCall”) before forwarding the results back into the conversation cycle.\n\n3. Architecture and Workflow\n\n• Initialization and Configuration  \n – On startup, the client checks for a “foundry.json” state file, creating one with default settings if not present.  \n – It reads “accounts.json” to establish connections with the configured AI endpoints; these connections use API keys from environment variables.  \n – The client also initializes conversation history (rohaHistory) with a system prompt (“I am testing foundry client. You are a helpful assistant”).\n\n• File and Directory Operations  \n – Commands such as “/cd” and “/dir” allow the user to manage current working directories – aiding in file selection for sharing.  \n – The client uses Deno APIs for file operations, including reading, writing, statting files, and computing file hashes using SHA‑256.\n\n• Command Processing  \n – Input lines that begin with a “/” are interpreted as commands. Otherwise, they are treated as chat messages from the user.  \n – A command “callCommand” function handles a wide range of commands: listing accounts, toggling configuration flags, sharing files, managing tags, and handling model selection.\n – Commands such as “/reset” clear shared files and conversation history; “/history” lists recent conversation activities; “/save” and “/load” allow the user to persist or restore sessions.\n\n• ANSI and Markdown Rendering  \n – The client can render markdown content with ANSI escape sequences for styling (headers, bold, italics, bullets).  \n – There is a fallback plain output mode if ANSI rendering is not enabled.\n\n• Isolation and Sandbox Execution  \n – A helper function “isolateCode” is provided to run external JavaScript code (from an “isolation/test.js” file) in a sandboxed environment with restricted permissions. This supports a “runCode” routine that demonstrates isolated execution.\n\n4. Additional Files and Documentation\n\n• foundry.md – This markdown file provides an overview of the available commands and the machine interface (tool calls) for the client.\n• welcome.txt – A welcome banner displayed on startup.\n• LICENSE.txt and build.bat – These files establish project licensing (MIT License) and build instructions for compiling the Deno application.\n• The “forge” subdirectory is used for storing file submissions and conversation snapshots.\n• The “isolation” subdirectory contains a sandbox for testing code execution, distinct from the main workflow.\n\n5. Summary\n\nThe Nitrologic Foundry Client is a robust research tool designed for interacting with language models while integrating file sharing and conversation management. With its modular tool calls, command interface, and detailed configuration options, it becomes a flexible environment for testing model capabilities – particularly for those models that support an interactive tools interface. The design elegantly combines interactive terminal I/O, file system operations, and API integrations in a portable Deno runtime environment.\n\n─────────────────────────────────────────────  \nConcluding Remarks\n\nThe Foundry Client, as demonstrated by the provided source code and accompanying materials, reflects thoughtful design aimed at research and interactive testing. Its support for both chat-based interactions and contextual file sharing makes it well suited for scenarios where version tracking and iterative model evaluation are needed. Future enhancements—such as improved error handling, richer command completion (e.g., arrow navigation), and expanded tool integrations—could further extend its capabilities.\n\n─────────────────────────────────────────────  \nEnd of Report\n\nFeel free to adjust or expand any sections as needed for your reporting purposes."
	},
	{
		"role": "user",
		"content": "no way to verbose"
	},
	{
		"role": "assistant",
		"content": "Below is a report summarizing and analyzing the Nitrologic Foundry Client based on the source code and accompanying documentation.\n\n─────────────────────────────────────────────  \nNitrologic Foundry Client Report  \n─────────────────────────────────────────────\n\n1. Overview\n\nThe Nitrologic Foundry Client is an experimental command‑line research tool built on Deno. It is designed to facilitate model evaluation, interactive chat sessions, and file sharing. The client interacts with multiple language model endpoints (such as those provided by OpenAI, Deepseek, Gemini, and XAI) and supports both chat and file submission through a unified interface.\n\n2. Key Features\n\n• Interactive Chat Interface and Conversation History  \n – The client runs in a terminal and uses raw input mode to capture user commands and messages.  \n – Conversation history is maintained in an array (“rohaHistory”), starting with a system prompt that defines the client’s role.  \n – Users may save and reload conversation sessions, allowing for persistent session management.\n\n• File Sharing and Commit Workflow  \n – The “/share” command allows a user to submit either files or entire directories.  \n – Shared files are tracked via metadata including file path, size, modification time, and a computed SHA‑256 hash.  \n – A “/push” (or “/commit”) command scans the shared files for modifications or deletions, updates history, and integrates file “submissions” into the conversation for review.\n\n• Configurable Options and Command Set  \n – Multiple configuration flags control aspects such as:  \n  • Automatic file commit on start  \n  • ANSI-based markdown rendering for enhanced terminal output  \n  • Slow reading (output pacing), verbose logging, and even special “broken” modes for ANSI blocks  \n – Commands such as “/config” allow users to toggle these features.  \n – Additional commands include “/cd” (to change directory), “/dir” (to list files), “/model” (to select or switch language models), and “/reset” (to clear history and file shares).\n\n• Model and Tool Functionality  \n – The client supports model interactions using a “relay” function that sends the conversation history as a payload to the selected model endpoint.  \n – Some models support “tool calls,” and the client defines three tool functions:  \n  ○ read_time – Returns the current UTC time  \n  ○ submit_file – Accepts content and its MIME type to save a file in the local “forge” directory  \n  ○ annotate_foundry – Lets the user annotate or set descriptions on file shares or tags  \n – These tools support enhanced interactions when the underlying model can invoke external functions during a conversation.\n\n• ANSI and Markdown Rendering  \n – The client renders markdown content using ANSI escape sequences (for headers, bold, italics, and bullet lists), improving readability in terminal outputs when enabled.  \n – A fallback plain text mode is available if ANSI rendering is turned off.\n\n• Sandbox Code Execution  \n – A dedicated “isolation” module demonstrates running external JavaScript code in an isolated environment with limited permissions. This reinforces the client’s role as a research and testing platform.\n\n3. Architecture and Workflow\n\n• Initialization and Startup  \n – On launch, the client checks for a persistent state file (“foundry.json”). If not found, it creates a default configuration.  \n – It reads an “accounts.json” file to load provider configurations and uses environment variables to obtain API keys for connecting to endpoints.\n\n• Conversation Handling  \n – User input is processed in two categories: commands (prefixed with “/”) and regular chat messages.  \n – The “callCommand” function handles a variety of commands (e.g., file management, configuration toggles, model selection) and directs appropriate actions.  \n – The “relay” function packages the chat history (or a squashed version of it) and sends it to the AI endpoint using either a simple completion or a tool invocation model, with recursive handling of tool responses as needed.\n\n• File and Directory Management  \n – The client uses Deno’s filesystem API to change directories (“/cd”), list directory contents (“/dir”), and compute file hash values for file integrity checking.  \n – Shared files are maintained in an internal list (roha.sharedFiles) and include optional tags that can be annotated post sharing.\n\n• Configurability and Logging  \n – The client supports multiple configuration options stored within the state file, allowing toggles for behaviors such as automatic commit at startup and slow output pacing.  \n – There is also an option to log all output to a “foundry.log” file.\n\n4. Supporting Files and Documentation\n\n• foundry.md – A markdown document that describes available commands and the machine interface (tool calls) for the client.  \n• welcome.txt – Provides a graphical welcome message on startup.  \n• LICENSE.txt – Contains the MIT License terms under which the source is released.  \n• build.bat – A batch script to compile the application using Deno’s compile command, ensuring necessary permissions are granted.  \n• The “forge” directory – A local repository for submitted files and session snapshots.  \n• The “isolation” directory – Contains sandboxed test code that is executed at startup to verify isolated code execution capabilities.\n\n5. Summary and Concluding Remarks\n\nThe Nitrologic Foundry Client is a well-structured research tool merging interactive chat, file management, and model tool-call support. Its versatility lies in the ability to manage conversation sessions, track and submit file changes, and toggle between different aspects of its behavior with a simple command interface. The modular design—combining terminal I/O, file system manipulation, and API integration via Deno—makes it a useful platform for model evaluation and interactive research.\n\nFuture enhancements might include richer command-line navigation (such as arrow key support and auto-completion), improved error handling around API calls, and greater configurability for advanced users. As it stands, the Foundry Client provides a compelling example of combining AI interactivity with common file management tasks in a terminal-based environment.\n\n─────────────────────────────────────────────  \nEnd of Report\n\nFeel free to adjust or expand upon these sections based on further testing or additional project requirements."
	},
	{
		"role": "user",
		"content": "would a git history of the original project help with a report on each functional block of code added to foundry.js"
	},
	{
		"role": "assistant",
		"content": "Yes, absolutely. A comprehensive git history would provide a detailed record of when and how each functional block was added or modified. This history can be invaluable for several reasons:\n\n• It provides commit messages and diffs that explain the intent behind changes. This context can help you understand the purpose and evolution of features like the chat interface, file sharing, configuration settings, and tooling integration.\n\n• You can trace the incremental changes made in each commit to see how different functionalities emerged. This would allow you to map certain commits to specific features (e.g., the addition of sandbox execution, ANSI rendering, or the tool_call interface).\n\n• It offers insight into debugging and performance improvements, as well as any architectural refactoring. For example, reviewing changes that affected error handling or logging could be useful in assessing the robustness of each component.\n\n• It aids in documenting the development process. You can refer to specific commits in your report to illustrate the evolution of Foundry.js, making your analysis more precise and informative.\n\nIn summary, leveraging the git history would indeed help produce a detailed report that covers each functional block of code added to Foundry.js, describing the evolution of the project and clarifying how its various capabilities came together over time."
	},
	{
		"role": "user",
		"content": "what is the git command to provide a list of diffs in historical order?"
	},
	{
		"role": "assistant",
		"content": "You can use \"git log -p\" to see a commit-by-commit diff. To list these diffs in chronological (oldest-to-newest) order, add the \"--reverse\" flag:\n\n  git log --reverse -p\n\nThis command will show each commit’s changes (patches) starting with the oldest."
	},
	{
		"role": "user",
		"content": "Please review source for bugs and all content if notable changes detected, thanks."
	},
	{
		"role": "assistant",
		"content": "Below are several observations after reviewing the Foundry.js source code. Note that I did not run the code, so some comments are based solely on static review:\n\n──────────────────────────────\n1. General Observations\n\n• The code is organized as a monolithic script with many global variables (for example, roha, rohaHistory, modelList, etc.). In a long‐term project you might want to refactor parts into separate modules for clarity and maintainability.\n\n• The use of raw terminal I/O (via Deno.stdin.setRaw(true)) appears to be handled with a try…finally block in prompt2, which is good. However, ensure that every possible error path (including asynchronous exceptions) correctly resets raw mode.\n\n──────────────────────────────\n2. Specific Functional Sections and Potential Issues\n\nPrompt Handling (prompt2 function):\n – The function sets raw mode and reads bytes. The finally clause resets raw mode.\n – There is a branch for when the escape (0x1b) byte is encountered. In that branch, if the value length equals 1 the code calls Deno.exit(0) immediately. This abrupt termination might bypass any cleanup not covered by finally—double-check that this is acceptable.\n – The handling of escape sequences (when value length equals 3) is very specific (checks for 0xf4 and 0x50). Confirm that these assumptions are accurate for all platforms you intend to support.\n\nFile and Share Handling:\n – In shareFile, the code distinguishes between text files and binary files based solely on file extension. This works in many cases, but be aware that the list of text extensions might need updates as you add more file types.\n – The commitShares function uses Deno.stat; if a file has been removed, the error is caught and its path is added to removedPaths. This seems fine, but you might want to log such removals more prominently.\n\nCommand Processing (callCommand function):\n – The switch statement handles numerous commands. Most commands catch errors and print error messages via echo, which is helpful.\n – When the command is not recognized, the function returns false. It may be useful to also log this or provide additional guidance to the user.\n\nRelay and Tool Calling:\n – The relay() function recursively calls itself after processing tool calls. Make sure that the recursion terminates as expected when no further tool calls are returned; an inadvertent design might cause infinite recursion if the model repeatedly sends tool call instructions.\n – Some merging of messages happens in squashMessages. The function concatenates system and non‑system messages separately but be sure that the resulting history still meets your model’s expected format.\n – Every time a tool call is processed, rohaCalls is incremented. Although this works in a single‑threaded environment, ensure that the counter remains reliable over long sessions if scaling out.\n\nGlobal State:\n – Various globals (roha, rohaHistory, modelList, etc.) are mutated. A potential improvement is ensuring that state is encapsulated so unit tests can validate individual blocks.\n – Some functions (e.g. resetRoha, writeRoha, readRoha) manipulate the JSON state file. In a production scenario, consider adding error handling or a backup of state to prevent corruption.\n\nLogging and ANSI Rendering:\n – The log() function writes to a “foundry.log” file if the logging flag is enabled. Ensure that concurrent writes (if any) are managed (though Deno.run in a single script generally is single‑threaded).\n – ANSI rendering in mdToAnsi appears to transform markdown styling based on simple regexes. Test that this works as expected across different terminals and that the “broken” mode (using alternate ANSI backgrounds) behaves as intended.\n\n──────────────────────────────\n3. Recommendations\n\n• Consider modularizing the code further to separate concerns (e.g. prompt handling, file sharing, model communication, logging).\n\n• Add more thorough error handling around critical sections (for example, when reading/writing state files, or when parsing JSON data).\n\n• If infinite recursion is possible in relay() because of model tool calls, you might want to set a maximum recursion depth or check for termination conditions.\n\n• Writing unit tests for separate modules would help catch future regressions.\n\n• Make sure that any platform-specific assumptions (the behavior of Deno.stdin, raw mode, etc.) are tested on all target environments.\n\n──────────────────────────────\nConclusion\n\nOverall, the code appears functional and well-commented; most issues noted are suggestions for improved maintainability and robustness rather than critical bugs. A detailed git history would indeed help track changes and verify that modifications (especially those affecting the core logic such as relay(), prompt2, and file handling) were intentional and tested. Reviewing each commit could offer additional context for design decisions and further highlight areas for improvement.\n\nIf you have any further questions or need help refactoring specific modules, please let me know!"
	},
	{
		"role": "system",
		"content": "Saved session tokens.json."
	}
]